<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Hashing to Elliptic Curves</title>

  
<style type="text/css">/*<![CDATA[*/

body {
  font: 16px "Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 24px;
  margin: 75px auto;
  max-width: 624px;
  padding: 0 5px;
}

.title, .filename, h1, h2, h3, h4, h5 {
  font: 16px "Roboto Condensed","Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  font-size-adjust: 0.5;
  font-weight: bold;
  color: #333;
  line-height: 100%;
  margin: 1.2em 0 0.3em;
}
.title, #rfc\.title h1 { font-size: 32px; }
h1, section h1, h2, section h2, section h3, nav h2 { font-size: 20px; }
h3, section h4, h4, section h5 { font-size: 16px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header, table#rfc\.headerblock {
  width: 100%;
}
table.header td, table#rfc\.headerblock td {
  border: none;
  background-color: transparent;
  color: black;
  padding: 0;
}
.filename {
  display: block;
  color: rgb(119, 119, 119);
  font-size: 20px;
  font-weight: normal;
  line-height: 100%;
  margin: 10px 0 32px;
}
#rfc\.abstract+p, #rfc\.abstract+p code, #rfc\.abstract+p samp, #rfc\.abstract+p tt {
  font-size: 20px;
  line-height: 28px;
}

samp, tt, code, pre, span.tt {
  font-size: 13.5px;
  font-family: Consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure, caption {
  font-style: italic;
  margin: 0 1.5em;
  text-align: left;
}

address {
  margin: 16px 2px;
  line-height: 20px;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn, address b {
  font-weight: normal;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}
hr.noprint {
  display: none;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

p, ol, ul, li {
  padding: 0;
}
p {
  margin: 0.5em 0;
}
ol, ul {
  margin: 0.2em 0 0.2em 2em;
}
li {
  margin: 0.2em 0;
}
address {
  font-style: normal;
}

ul.toc ul {
  margin: 0 0 0 2em;
}
ul.toc li {
  list-style: none;
  margin: 0;
}

@media screen and (min-width: 924px) {
  body {
    padding-right: 350px;
  }
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    z-index: 1;
    overflow: auto;
    overscroll-behavior: contain;
  }
  body>#rfc\.toc {
    top: 55px;
  }
  body>ul.toc {
    top: 100px;
  }

  ul.toc {
    margin: 0 0 0 4px;
    font-size: 12px;
    line-height: 20px;
  }
  ul.toc ul {
    margin-left: 1.2em;
  }
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>
  <meta name="viewport" content="initial-scale=1.0">


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 How to use this document">
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Requirements">
<link href="#rfc.section.2" rel="Chapter" title="2 Background">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Elliptic curves">
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Terminology">
<link href="#rfc.section.2.2.1" rel="Chapter" title="2.2.1 Mappings">
<link href="#rfc.section.2.2.2" rel="Chapter" title="2.2.2 Encodings">
<link href="#rfc.section.2.2.3" rel="Chapter" title="2.2.3 Random oracle encodings">
<link href="#rfc.section.2.2.4" rel="Chapter" title="2.2.4 Serialization">
<link href="#rfc.section.2.2.5" rel="Chapter" title="2.2.5 Domain separation">
<link href="#rfc.section.3" rel="Chapter" title="3 Roadmap">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Domain separation requirements">
<link href="#rfc.section.4" rel="Chapter" title="4 Utility Functions">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 sgn0 variants">
<link href="#rfc.section.4.1.1" rel="Chapter" title="4.1.1 Big endian variant">
<link href="#rfc.section.4.1.2" rel="Chapter" title="4.1.2 Little endian variant">
<link href="#rfc.section.5" rel="Chapter" title="5 Hashing to a Finite Field">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Security considerations">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Performance considerations">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Implementation">
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 Alternative hash_to_base functions">
<link href="#rfc.section.6" rel="Chapter" title="6 Deterministic Mappings">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Choosing a mapping function">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Interface">
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Notation">
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 Sign of the resulting point">
<link href="#rfc.section.6.5" rel="Chapter" title="6.5 Exceptional cases">
<link href="#rfc.section.6.6" rel="Chapter" title="6.6 Mappings for Weierstrass curves">
<link href="#rfc.section.6.6.1" rel="Chapter" title="6.6.1 Shallue-van de Woestijne Method">
<link href="#rfc.section.6.6.2" rel="Chapter" title="6.6.2 Simplified Shallue-van de Woestijne-Ulas Method">
<link href="#rfc.section.6.6.3" rel="Chapter" title="6.6.3 Simplified SWU for AB == 0">
<link href="#rfc.section.6.7" rel="Chapter" title="6.7 Mappings for Montgomery curves">
<link href="#rfc.section.6.7.1" rel="Chapter" title="6.7.1 Elligator 2 Method">
<link href="#rfc.section.6.8" rel="Chapter" title="6.8 Mappings for Twisted Edwards curves">
<link href="#rfc.section.6.8.1" rel="Chapter" title="6.8.1 Rational maps from Montgomery to twisted Edwards curves">
<link href="#rfc.section.6.8.2" rel="Chapter" title="6.8.2 Elligator 2 Method">
<link href="#rfc.section.6.9" rel="Chapter" title="6.9 Mappings for Supersingular curves">
<link href="#rfc.section.6.9.1" rel="Chapter" title="6.9.1 Boneh-Franklin Method">
<link href="#rfc.section.6.9.2" rel="Chapter" title="6.9.2 Elligator 2, A == 0 Method">
<link href="#rfc.section.7" rel="Chapter" title="7 Clearing the cofactor">
<link href="#rfc.section.8" rel="Chapter" title="8 Suites for Hashing">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Defining a new hash-to-curve suite">
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 Suite ID naming conventions">
<link href="#rfc.section.8.3" rel="Chapter" title="8.3 Suites for NIST P-256">
<link href="#rfc.section.8.4" rel="Chapter" title="8.4 Suites for NIST P-384">
<link href="#rfc.section.8.5" rel="Chapter" title="8.5 Suites for NIST P-521">
<link href="#rfc.section.8.6" rel="Chapter" title="8.6 Suites for curve25519 and edwards25519">
<link href="#rfc.section.8.7" rel="Chapter" title="8.7 Suites for curve448 and edwards448">
<link href="#rfc.section.8.8" rel="Chapter" title="8.8 Suites for secp256k1">
<link href="#rfc.section.8.9" rel="Chapter" title="8.9 Suites for BLS12-381">
<link href="#rfc.section.8.9.1" rel="Chapter" title="8.9.1 BLS12-381 G1">
<link href="#rfc.section.8.9.2" rel="Chapter" title="8.9.2 BLS12-381 G2">
<link href="#rfc.section.9" rel="Chapter" title="9 IANA Considerations">
<link href="#rfc.section.10" rel="Chapter" title="10 Security Considerations">
<link href="#rfc.section.11" rel="Chapter" title="11 Acknowledgements">
<link href="#rfc.section.12" rel="Chapter" title="12 Contributors">
<link href="#rfc.references" rel="Chapter" title="13 References">
<link href="#rfc.references.1" rel="Chapter" title="13.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="13.2 Informative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A Related Work">
<link href="#rfc.appendix.B" rel="Chapter" title="B Rational maps">
<link href="#rfc.appendix.B.1" rel="Chapter" title="B.1 Twisted Edwards to Weierstrass and Montgomery curves">
<link href="#rfc.appendix.B.2" rel="Chapter" title="B.2 Montgomery to Weierstrass curves">
<link href="#rfc.appendix.C" rel="Chapter" title="C Isogeny maps for Suites">
<link href="#rfc.appendix.C.1" rel="Chapter" title="C.1 3-isogeny map for secp256k1">
<link href="#rfc.appendix.C.2" rel="Chapter" title="C.2 11-isogeny map for BLS12-381 G1">
<link href="#rfc.appendix.C.3" rel="Chapter" title="C.3 3-isogeny map for BLS12-381 G2">
<link href="#rfc.appendix.D" rel="Chapter" title="D Sample Code">
<link href="#rfc.appendix.D.1" rel="Chapter" title="D.1 Interface and projective coordinate systems">
<link href="#rfc.appendix.D.2" rel="Chapter" title="D.2 Simplified SWU for p = 3 (mod 4)">
<link href="#rfc.appendix.D.3" rel="Chapter" title="D.3 curve25519 (Elligator 2)">
<link href="#rfc.appendix.D.4" rel="Chapter" title="D.4 edwards25519 (Elligator 2)">
<link href="#rfc.appendix.D.5" rel="Chapter" title="D.5 curve448 (Elligator 2)">
<link href="#rfc.appendix.D.6" rel="Chapter" title="D.6 edwards448 (Elligator 2)">
<link href="#rfc.appendix.E" rel="Chapter" title="E Scripts for parameter generation">
<link href="#rfc.appendix.E.1" rel="Chapter" title="E.1 Finding Z for the Shallue and van de Woestijne map">
<link href="#rfc.appendix.E.2" rel="Chapter" title="E.2 Finding Z for Simplified SWU">
<link href="#rfc.appendix.E.3" rel="Chapter" title="E.3 Finding Z for Elligator 2">
<link href="#rfc.appendix.F" rel="Chapter" title="F sqrt functions">
<link href="#rfc.appendix.F.1" rel="Chapter" title="F.1 p = 3 (mod 4)">
<link href="#rfc.appendix.F.2" rel="Chapter" title="F.2 p = 5 (mod 8)">
<link href="#rfc.appendix.F.3" rel="Chapter" title="F.3 p = 9 (mod 16)">
<link href="#rfc.appendix.F.4" rel="Chapter" title="F.4 Constant-time Tonelli-Shanks algorithm">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.34.0 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Faz-Hernandez, A., Scott, S., Sullivan, N., Wahby, R., and C. Wood" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-irtf-cfrg-hash-to-curve-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2019-11-17" />
  <meta name="dct.abstract" content="This document specifies a number of algorithms that may be used to encode or hash an arbitrary string to a point on an elliptic curve." />
  <meta name="description" content="This document specifies a number of algorithms that may be used to encode or hash an arbitrary string to a point on an elliptic curve." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Network Working Group</td>
<td class="right">A. Faz-Hernandez</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Cloudflare</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">S. Scott</td>
</tr>
<tr>
<td class="left">Expires: May 20, 2020</td>
<td class="right">Cornell Tech</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">N. Sullivan</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Cloudflare</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">R. Wahby</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Stanford University</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">C. Wood</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Apple Inc.</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">November 17, 2019</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Hashing to Elliptic Curves<br />
  <span class="filename">draft-irtf-cfrg-hash-to-curve-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document specifies a number of algorithms that may be used to encode or hash an arbitrary string to a point on an elliptic curve.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on May 20, 2020.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2019 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<ul><li>1.1.   <a href="#rfc.section.1.1">How to use this document</a>
</li>
<li>1.2.   <a href="#rfc.section.1.2">Requirements</a>
</li>
</ul><li>2.   <a href="#rfc.section.2">Background</a>
</li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Elliptic curves</a>
</li>
<li>2.2.   <a href="#rfc.section.2.2">Terminology</a>
</li>
<ul><li>2.2.1.   <a href="#rfc.section.2.2.1">Mappings</a>
</li>
<li>2.2.2.   <a href="#rfc.section.2.2.2">Encodings</a>
</li>
<li>2.2.3.   <a href="#rfc.section.2.2.3">Random oracle encodings</a>
</li>
<li>2.2.4.   <a href="#rfc.section.2.2.4">Serialization</a>
</li>
<li>2.2.5.   <a href="#rfc.section.2.2.5">Domain separation</a>
</li>
</ul></ul><li>3.   <a href="#rfc.section.3">Roadmap</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Domain separation requirements</a>
</li>
</ul><li>4.   <a href="#rfc.section.4">Utility Functions</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">sgn0 variants</a>
</li>
<ul><li>4.1.1.   <a href="#rfc.section.4.1.1">Big endian variant</a>
</li>
<li>4.1.2.   <a href="#rfc.section.4.1.2">Little endian variant</a>
</li>
</ul></ul><li>5.   <a href="#rfc.section.5">Hashing to a Finite Field</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Security considerations</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Performance considerations</a>
</li>
<li>5.3.   <a href="#rfc.section.5.3">Implementation</a>
</li>
<li>5.4.   <a href="#rfc.section.5.4">Alternative hash_to_base functions</a>
</li>
</ul><li>6.   <a href="#rfc.section.6">Deterministic Mappings</a>
</li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Choosing a mapping function</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">Interface</a>
</li>
<li>6.3.   <a href="#rfc.section.6.3">Notation</a>
</li>
<li>6.4.   <a href="#rfc.section.6.4">Sign of the resulting point</a>
</li>
<li>6.5.   <a href="#rfc.section.6.5">Exceptional cases</a>
</li>
<li>6.6.   <a href="#rfc.section.6.6">Mappings for Weierstrass curves</a>
</li>
<ul><li>6.6.1.   <a href="#rfc.section.6.6.1">Shallue-van de Woestijne Method</a>
</li>
<li>6.6.2.   <a href="#rfc.section.6.6.2">Simplified Shallue-van de Woestijne-Ulas Method</a>
</li>
<li>6.6.3.   <a href="#rfc.section.6.6.3">Simplified SWU for AB == 0</a>
</li>
</ul><li>6.7.   <a href="#rfc.section.6.7">Mappings for Montgomery curves</a>
</li>
<ul><li>6.7.1.   <a href="#rfc.section.6.7.1">Elligator 2 Method</a>
</li>
</ul><li>6.8.   <a href="#rfc.section.6.8">Mappings for Twisted Edwards curves</a>
</li>
<ul><li>6.8.1.   <a href="#rfc.section.6.8.1">Rational maps from Montgomery to twisted Edwards curves</a>
</li>
<li>6.8.2.   <a href="#rfc.section.6.8.2">Elligator 2 Method</a>
</li>
</ul><li>6.9.   <a href="#rfc.section.6.9">Mappings for Supersingular curves</a>
</li>
<ul><li>6.9.1.   <a href="#rfc.section.6.9.1">Boneh-Franklin Method</a>
</li>
<li>6.9.2.   <a href="#rfc.section.6.9.2">Elligator 2, A == 0 Method</a>
</li>
</ul></ul><li>7.   <a href="#rfc.section.7">Clearing the cofactor</a>
</li>
<li>8.   <a href="#rfc.section.8">Suites for Hashing</a>
</li>
<ul><li>8.1.   <a href="#rfc.section.8.1">Defining a new hash-to-curve suite</a>
</li>
<li>8.2.   <a href="#rfc.section.8.2">Suite ID naming conventions</a>
</li>
<li>8.3.   <a href="#rfc.section.8.3">Suites for NIST P-256</a>
</li>
<li>8.4.   <a href="#rfc.section.8.4">Suites for NIST P-384</a>
</li>
<li>8.5.   <a href="#rfc.section.8.5">Suites for NIST P-521</a>
</li>
<li>8.6.   <a href="#rfc.section.8.6">Suites for curve25519 and edwards25519</a>
</li>
<li>8.7.   <a href="#rfc.section.8.7">Suites for curve448 and edwards448</a>
</li>
<li>8.8.   <a href="#rfc.section.8.8">Suites for secp256k1</a>
</li>
<li>8.9.   <a href="#rfc.section.8.9">Suites for BLS12-381</a>
</li>
<ul><li>8.9.1.   <a href="#rfc.section.8.9.1">BLS12-381 G1</a>
</li>
<li>8.9.2.   <a href="#rfc.section.8.9.2">BLS12-381 G2</a>
</li>
</ul></ul><li>9.   <a href="#rfc.section.9">IANA Considerations</a>
</li>
<li>10.   <a href="#rfc.section.10">Security Considerations</a>
</li>
<li>11.   <a href="#rfc.section.11">Acknowledgements</a>
</li>
<li>12.   <a href="#rfc.section.12">Contributors</a>
</li>
<li>13.   <a href="#rfc.references">References</a>
</li>
<ul><li>13.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>13.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Related Work</a>
</li>
<li>Appendix B.   <a href="#rfc.appendix.B">Rational maps</a>
</li>
<ul><li>B.1.   <a href="#rfc.appendix.B.1">Twisted Edwards to Weierstrass and Montgomery curves</a>
</li>
<li>B.2.   <a href="#rfc.appendix.B.2">Montgomery to Weierstrass curves</a>
</li>
</ul><li>Appendix C.   <a href="#rfc.appendix.C">Isogeny maps for Suites</a>
</li>
<ul><li>C.1.   <a href="#rfc.appendix.C.1">3-isogeny map for secp256k1</a>
</li>
<li>C.2.   <a href="#rfc.appendix.C.2">11-isogeny map for BLS12-381 G1</a>
</li>
<li>C.3.   <a href="#rfc.appendix.C.3">3-isogeny map for BLS12-381 G2</a>
</li>
</ul><li>Appendix D.   <a href="#rfc.appendix.D">Sample Code</a>
</li>
<ul><li>D.1.   <a href="#rfc.appendix.D.1">Interface and projective coordinate systems</a>
</li>
<li>D.2.   <a href="#rfc.appendix.D.2">Simplified SWU for p = 3 (mod 4)</a>
</li>
<li>D.3.   <a href="#rfc.appendix.D.3">curve25519 (Elligator 2)</a>
</li>
<li>D.4.   <a href="#rfc.appendix.D.4">edwards25519 (Elligator 2)</a>
</li>
<li>D.5.   <a href="#rfc.appendix.D.5">curve448 (Elligator 2)</a>
</li>
<li>D.6.   <a href="#rfc.appendix.D.6">edwards448 (Elligator 2)</a>
</li>
</ul><li>Appendix E.   <a href="#rfc.appendix.E">Scripts for parameter generation</a>
</li>
<ul><li>E.1.   <a href="#rfc.appendix.E.1">Finding Z for the Shallue and van de Woestijne map</a>
</li>
<li>E.2.   <a href="#rfc.appendix.E.2">Finding Z for Simplified SWU</a>
</li>
<li>E.3.   <a href="#rfc.appendix.E.3">Finding Z for Elligator 2</a>
</li>
</ul><li>Appendix F.   <a href="#rfc.appendix.F">sqrt functions</a>
</li>
<ul><li>F.1.   <a href="#rfc.appendix.F.1">p = 3 (mod 4)</a>
</li>
<li>F.2.   <a href="#rfc.appendix.F.2">p = 5 (mod 8)</a>
</li>
<li>F.3.   <a href="#rfc.appendix.F.3">p = 9 (mod 16)</a>
</li>
<li>F.4.   <a href="#rfc.appendix.F.4">Constant-time Tonelli-Shanks algorithm</a>
</li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">Many cryptographic protocols require a procedure that encodes an arbitrary input, e.g., a password, to a point on an elliptic curve. This procedure is known as hashing to an elliptic curve. Prominent examples of cryptosystems that hash to elliptic curves include Simple Password Exponential Key Exchange <a href="#J96" class="xref">[J96]</a>, Password Authenticated Key Exchange <a href="#BMP00" class="xref">[BMP00]</a>, Identity-Based Encryption <a href="#BF01" class="xref">[BF01]</a> and Boneh-Lynn-Shacham signatures <a href="#BLS01" class="xref">[BLS01]</a>.</p>
<p id="rfc.section.1.p.2">Unfortunately for implementors, the precise hash function that is suitable for a given scheme is not necessarily included in the description of the protocol.  Compounding this problem is the need to pick a suitable curve for the specific protocol.</p>
<p id="rfc.section.1.p.3">This document aims to bridge this gap by providing a thorough set of recommended algorithms for a range of curve types.  Each algorithm conforms to a common interface: it takes as input an arbitrary-length bit string and produces as output a point on an elliptic curve.  We provide implementation details for each algorithm, describe the security rationale behind each recommendation, and give guidance for elliptic curves that are not explicitly covered.</p>
<p id="rfc.section.1.p.4">This document does not cover rejection sampling methods, sometimes known as &#8220;try-and-increment&#8221; or &#8220;hunt-and-peck,&#8221; because the goal is to describe algorithms that can plausibly be made constant time. Use of these rejection methods is NOT RECOMMENDED, because they have been a perennial cause of side-channel vulnerabilities.</p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> <a href="#howto" id="howto">How to use this document</a>
</h1>
<p id="rfc.section.1.1.p.1">This document is intended for use by both implementors and protocol designers.</p>
<p id="rfc.section.1.1.p.2">For implementors, the necessary and sufficient level of specification is a hash-to-curve suite, which fixes all of the parameters listed in <a href="#suites" class="xref">Section 8</a>, plus a domain separation tag (<a href="#domain-separation" class="xref">Section 3.1</a>).  Starting from working operations on the target elliptic curve and its base field, a hash-to-curve suite requires implementing the specified encoding function (<a href="#roadmap" class="xref">Section 3</a>), its constituent subroutines (<a href="#hashtobase" class="xref">Section 5</a>, <a href="#mappings" class="xref">Section 6</a>, <a href="#cofactor-clearing" class="xref">Section 7</a>), and a few utility functions (<a href="#utility" class="xref">Section 4</a>).</p>
<p id="rfc.section.1.1.p.3">Correspondingly, designers specifying a protocol that requires hashing to an elliptic curve should either choose an existing hash-to-curve suite or specify a new one (see <a href="#new-suite" class="xref">Section 8.1</a>).  In addition, designers should choose a domain separation tag following the guidelines in <a href="#domain-separation" class="xref">Section 3.1</a>.</p>
<h1 id="rfc.section.1.2">
<a href="#rfc.section.1.2">1.2.</a> <a href="#requirements" id="requirements">Requirements</a>
</h1>
<p id="rfc.section.1.2.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in <a href="#RFC2119" class="xref">[RFC2119]</a>.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#background" id="background">Background</a>
</h1>
<h1 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> <a href="#bg-curves" id="bg-curves">Elliptic curves</a>
</h1>
<p id="rfc.section.2.1.p.1">The following is a brief definition of elliptic curves, with an emphasis on important parameters and their relation to hashing to curves.  For further reference on elliptic curves, consult <a href="#CFADLNV05" class="xref">[CFADLNV05]</a> or <a href="#W08" class="xref">[W08]</a>.</p>
<p id="rfc.section.2.1.p.2">Let F be the finite field GF(q) of prime characteristic p. In most cases F is a prime field, so q = p. Otherwise, F is an extension field, so q = p^m for an integer m &gt; 1. This document writes elements of extension fields in a primitive element or polynomial basis, i.e., as a vector of m elements of GF(p) written in ascending order by degree.  The entries of this vector are indexed in ascending order starting from 1, i.e., x = (x_1, x_2, &#8230;, x_m).  For example, if q = p^2 and the primitive element basis is (1, i), then x = (a, b) corresponds to the element a + b * i, where x_1 = a and x_2 = b.</p>
<p id="rfc.section.2.1.p.3">An elliptic curve E is specified by an equation in two variables and a finite field F. An elliptic curve equation takes one of several standard forms, including (but not limited to) Weierstrass, Montgomery, and Edwards.</p>
<p id="rfc.section.2.1.p.4">The curve E induces an algebraic group whose elements are those points with coordinates (x, y) satisfying the curve equation, and where x and y are elements of F.  This group has order n, meaning that there are n distinct points.  This document uses additive notation for the elliptic curve group operation.</p>
<p id="rfc.section.2.1.p.5">For security reasons, groups of prime order MUST be used. Elliptic curves induce subgroups of prime order. Let G be a subgroup of the curve of prime order r, where n = h * r.  In this equation, h is an integer called the cofactor.  An algorithm that takes as input an arbitrary point on the curve E and produces as output a point in the subgroup G of E is said to &#8220;clear the cofactor.&#8221; Such algorithms are discussed in <a href="#cofactor-clearing" class="xref">Section 7</a>.</p>
<p id="rfc.section.2.1.p.6">Certain hash-to-curve algorithms restrict the form of the curve equation, the characteristic of the field, and/or the parameters of the curve. For each algorithm presented, this document lists the relevant restrictions.</p>
<p id="rfc.section.2.1.p.7">Summary of quantities:</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="center">Symbol</th>
<th class="left">Meaning</th>
<th class="left">Relevance</th>
</tr></thead>
<tbody>
<tr>
<td class="center">F,q,p</td>
<td class="left">Finite field F of characteristic p and #F = q = p^m.</td>
<td class="left">For prime fields, q = p; otherwise, q = p^m and m&gt;1.</td>
</tr>
<tr>
<td class="center">E</td>
<td class="left">Elliptic curve.</td>
<td class="left">E is specified by an equation and a field F.</td>
</tr>
<tr>
<td class="center">n</td>
<td class="left">Number of points on the elliptic curve E.</td>
<td class="left">n = h * r, for h and r defined below.</td>
</tr>
<tr>
<td class="center">G</td>
<td class="left">A subgroup of the elliptic curve.</td>
<td class="left">Destination group to which bit strings are encoded.</td>
</tr>
<tr>
<td class="center">r</td>
<td class="left">Order of G.</td>
<td class="left">This number MUST be prime.</td>
</tr>
<tr>
<td class="center">h</td>
<td class="left">Cofactor, h &gt;= 1.</td>
<td class="left">An integer satisfying n = h * r.</td>
</tr>
</tbody>
</table>
<h1 id="rfc.section.2.2">
<a href="#rfc.section.2.2">2.2.</a> <a href="#terminology" id="terminology">Terminology</a>
</h1>
<p id="rfc.section.2.2.p.1">In this section, we define important terms used in the rest of this document.</p>
<h1 id="rfc.section.2.2.1">
<a href="#rfc.section.2.2.1">2.2.1.</a> <a href="#term-mapping" id="term-mapping">Mappings</a>
</h1>
<p id="rfc.section.2.2.1.p.1">A mapping is a deterministic function from an element of the field F to a point on an elliptic curve E defined over F.</p>
<p id="rfc.section.2.2.1.p.2">In general, the set of all points that a mapping can produce over all possible inputs may be only a subset of the points on an elliptic curve (i.e., the mapping may not be surjective).  In addition, a mapping may output the same point for two or more distinct inputs (i.e., the mapping may not be injective).  For example, consider a mapping from F to an elliptic curve having n points: if the number of elements of F is not equal to n, then this mapping cannot be bijective (i.e., both injective and surjective) since it is defined to be deterministic.</p>
<p id="rfc.section.2.2.1.p.3">Mappings may also be invertible, meaning that there is an efficient algorithm that, for any point P output by the mapping, outputs an x in F such that applying the mapping to x outputs P.  Some of the mappings given in <a href="#mappings" class="xref">Section 6</a> are invertible, but this document does not discuss inversion algorithms.</p>
<h1 id="rfc.section.2.2.2">
<a href="#rfc.section.2.2.2">2.2.2.</a> <a href="#term-encoding" id="term-encoding">Encodings</a>
</h1>
<p id="rfc.section.2.2.2.p.1">Encodings are closely related to mappings.  Like a mapping, an encoding is a function that outputs a point on an elliptic curve.  In contrast to a mapping, however, the input to an encoding is an arbitrary bit string.  Encodings can be deterministic or probabilistic.  Deterministic encodings are preferred for security, because probabilistic ones can leak information through side channels.</p>
<p id="rfc.section.2.2.2.p.2">This document constructs deterministic encodings by composing a hash function H with a deterministic mapping.  In particular, H takes as input an arbitrary bit string and outputs an element of F.  The deterministic mapping takes that element as input and outputs a point on an elliptic curve E defined over F.  Since the hash function H takes arbitrary bit strings as inputs, it cannot be injective: the set of inputs is larger than the set of outputs, so there must be distinct inputs that give the same output (i.e., there must be collisions).  Thus, any encoding built from H is also not injective.</p>
<p id="rfc.section.2.2.2.p.3">Like mappings, encodings may be invertible, meaning that there is an efficient algorithm that, for any point P output by the encoding, outputs a bit string s such that applying the encoding to s outputs P.  The hash function used by all encodings specified in this document (<a href="#hashtobase" class="xref">Section 5</a>) is not invertible; thus, the encodings are also not invertible.</p>
<h1 id="rfc.section.2.2.3">
<a href="#rfc.section.2.2.3">2.2.3.</a> <a href="#term-rom" id="term-rom">Random oracle encodings</a>
</h1>
<p id="rfc.section.2.2.3.p.1">Two different types of encodings are possible: nonuniform encodings, whose output distribution is not uniformly random, and random oracle encodings, whose output distribution is indistinguishable from uniformly random.  Some protocols require a random oracle for security, while others can be securely instantiated with a nonuniform encoding.  When the required encoding is not clear, applications SHOULD use a random oracle.</p>
<p id="rfc.section.2.2.3.p.2">Care is required when constructing a random oracle from a mapping function.  A simple but insecure approach is to use the output of a cryptographically secure hash function H as the input to the mapping.  Because in general the mapping is not surjective, the output of this construction is distinguishable from uniformly random, i.e., it does not behave like a random oracle.</p>
<p id="rfc.section.2.2.3.p.3">Brier et al. <a href="#BCIMRT10" class="xref">[BCIMRT10]</a> describe two generic constructions whose outputs are indifferentiable from a random oracle when the constructions are instantiated with appropriate hash functions modeled as random oracles.  Farashahi et al. <a href="#FFSTV13" class="xref">[FFSTV13]</a> and Tibouchi and Kim <a href="#TK17" class="xref">[TK17]</a> refine the analysis of one of these constructions.  That construction is described in <a href="#roadmap" class="xref">Section 3</a>.</p>
<h1 id="rfc.section.2.2.4">
<a href="#rfc.section.2.2.4">2.2.4.</a> <a href="#term-serialization" id="term-serialization">Serialization</a>
</h1>
<p id="rfc.section.2.2.4.p.1">A procedure related to encoding is the conversion of an elliptic curve point to a bit string.  This is called serialization, and is typically used for compactly storing or transmitting points.  The reverse operation, deserialization, converts a bit string to an elliptic curve point.  For example, <a href="#SEC1" class="xref">[SEC1]</a> and <a href="#p1363a" class="xref">[p1363a]</a> give standard methods for serialization and deserialization.</p>
<p id="rfc.section.2.2.4.p.2">Deserialization is different from encoding in that only certain strings (namely, those output by the serialization procedure) can be deserialized.  In contrast, this document is concerned with encodings from arbitrary bit strings to elliptic curve points.  This document does not cover serialization or deserialization.</p>
<h1 id="rfc.section.2.2.5">
<a href="#rfc.section.2.2.5">2.2.5.</a> <a href="#term-domain-separation" id="term-domain-separation">Domain separation</a>
</h1>
<p id="rfc.section.2.2.5.p.1">Cryptographic protocols that use random oracles are often analyzed under the assumption that random oracles answer only queries generated by that protocol.  In practice, this assumption does not hold if two protocols query the same random oracle.  Concretely, consider protocols P1 and P2 that query random oracle R: if P1 and P2 both query R on the same value x, the security analysis of one or both protocols may be invalidated.</p>
<p id="rfc.section.2.2.5.p.2">A common approach to addressing this issue is called domain separation, which allows a single random oracle to simulate multiple, independent oracles.  This is effected by ensuring that each simulated oracle sees queries that are distinct from those seen by all other simulated oracles.  For example, to simulate two oracles R1 and R2 given a single oracle R, one might define</p>
<pre>
R1(x) := R("R1" || x)
R2(x) := R("R2" || x)
</pre>
<p id="rfc.section.2.2.5.p.3">In this example, &#8220;R1&#8221; and &#8220;R2&#8221; are called domain separation tags; they ensure that queries to R1 and R2 cannot result in identical queries to R.  Thus, it is safe to treat R1 and R2 as independent oracles.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#roadmap" id="roadmap">Roadmap</a>
</h1>
<p id="rfc.section.3.p.1">This section presents a general framework for encoding bit strings to points on an elliptic curve. To construct these encodings, we rely on three basic functions:</p>
<p></p>

<ul>
<li>The function hash_to_base, {0, 1}^* x {0, 1, 2} -&gt; F, hashes arbitrary-length bit strings to elements of a finite field; its implementation is defined in <a href="#hashtobase" class="xref">Section 5</a>.</li>
<li>The function map_to_curve, F -&gt; E, calculates a point on the elliptic curve E from an element of the finite field F over which E is defined.  <a href="#mappings" class="xref">Section 6</a> describes mappings for a range of curve families.</li>
<li>The function clear_cofactor, E -&gt; G, sends any point on the curve E to the subgroup G of E. <a href="#cofactor-clearing" class="xref">Section 7</a> describes methods to perform this operation.</li>
</ul>
<p id="rfc.section.3.p.3">We describe two high-level encoding functions (<a href="#term-encoding" class="xref">Section 2.2.2</a>).  Although these functions have the same interface, the distributions of their outputs are different.</p>
<p></p>

<ul><li>Nonuniform encoding (encode_to_curve). This function encodes bit strings to points in G.  The distribution of the output is not uniformly random in G.</li></ul>
<pre>
encode_to_curve(alpha)

Input: alpha, an arbitrary-length bit string.
Output: P, a point in G.

Steps:
1. u = hash_to_base(alpha, 2)
2. Q = map_to_curve(u)
3. P = clear_cofactor(Q)
4. return P
</pre>
<p></p>

<ul><li>Random oracle encoding (hash_to_curve). This function encodes bit strings to points in G.  This function is suitable for applications requiring a random oracle returning points in G, provided that map_to_curve is &#8220;well distributed&#8221; (<a href="#FFSTV13" class="xref">[FFSTV13]</a>, Def. 1).  All of the map_to_curve functions defined in <a href="#mappings" class="xref">Section 6</a> meet this requirement.</li></ul>
<pre>
hash_to_curve(alpha)

Input: alpha, an arbitrary-length bit string.
Output: P, a point in G.

Steps:
1. u0 = hash_to_base(alpha, 0)
2. u1 = hash_to_base(alpha, 1)
3. Q0 = map_to_curve(u0)
4. Q1 = map_to_curve(u1)
5. R = Q0 + Q1 // Point addition
6. P = clear_cofactor(R)
7. return P
</pre>
<p id="rfc.section.3.p.6">Instances of these functions are given in <a href="#suites" class="xref">Section 8</a>, which defines a list of suites that specify a full set of parameters matching elliptic curves and algorithms.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#domain-separation" id="domain-separation">Domain separation requirements</a>
</h1>
<p id="rfc.section.3.1.p.1">All uses of the encoding functions defined in this document MUST include domain separation (<a href="#term-domain-separation" class="xref">Section 2.2.5</a>) to avoid interfering with other uses of similar functionality.</p>
<p id="rfc.section.3.1.p.2">Protocols that instantiate multiple, independent hash functions based on either hash_to_curve or encode_to_curve MUST enforce domain separation between those hash functions.  This requirement applies both in the case of multiple hashes to the same curve and in the case of multiple hashes to different curves.  (This is because the hash_to_base primitive (<a href="#hashtobase" class="xref">Section 5</a>) requires domain separation to guarantee independent outputs.)</p>
<p id="rfc.section.3.1.p.3">Domain separation is enforced with a domain separation tag (DST), which is an octet string.  Care is required when selecting and using a domain separation tag.  The following requirements apply:</p>
<p></p>

<ol>
<li>Tags MUST be supplied as the DST parameter to hash_to_base, as described in <a href="#hashtobase" class="xref">Section 5</a>.</li>
<li>Tags MUST begin with a fixed protocol identification string.  This identification string should be unique to the protocol.</li>
<li>Tags SHOULD include a protocol version number.</li>
<li>For protocols that define multiple ciphersuites, each ciphersuite&#8217;s tag MUST be different. For this purpose, it is RECOMMENDED to include a ciphersuite identifier in each tag.</li>
<li>For protocols that use multiple encodings, either to the same curve or to different curves, each encoding MUST use a different tag.  For this purpose, it is RECOMMENDED to include the encoding&#8217;s Suite ID (<a href="#suites" class="xref">Section 8</a>) in the domain separation tag.  For independent encodings based on the same suite, each tag should also include a distinct identifier, e.g., &#8220;ENC1&#8221; and &#8220;ENC2&#8221;.</li>
</ol>
<p id="rfc.section.3.1.p.5">As an example, consider a fictional protocol named Quux that defines several different ciphersuites.  A reasonable choice of tag is &#8220;QUUX-V&lt;xx&gt;-CS&lt;yy&gt;&#8221;, where &lt;xx&gt; and &lt;yy&gt; are two-digit numbers indicating the version and ciphersuite, respectively.</p>
<p id="rfc.section.3.1.p.6">As another example, consider a fictional protocol named Baz that requires two independent random oracles, where one oracle outputs points on the curve E1 and the other outputs points on the curve E2.  Reasonable choices of tags for the E1 and E2 oracles are &#8220;BAZ-V&lt;xx&gt;-CS&lt;yy&gt;-E1&#8221; and &#8220;BAZ-V&lt;xx&gt;-CS&lt;yy&gt;-E2&#8221;, respectively, where &lt;xx&gt; and &lt;yy&gt; are as described above.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#utility" id="utility">Utility Functions</a>
</h1>
<p id="rfc.section.4.p.1">Algorithms in this document make use of utility functions described below.</p>
<p id="rfc.section.4.p.2">For security reasons, all field operations, comparisons, and assignments MUST be implemented in constant time (i.e., execution time MUST NOT depend on the values of the inputs), and without branching.  Guidance on implementing these low-level operations in constant time is beyond the scope of this document.</p>
<p></p>

<ul>
<li>CMOV(a, b, c): If c is False, CMOV returns a, otherwise it returns b.  To prevent against timing attacks, this operation must run in constant time, without revealing the value of c.  Commonly, implementations assume that the selector c is 1 for True or 0 for False. In this case, given a bit string C, the desired selector c can be computed by OR-ing all bits of C together. The resulting selector will be either 0 if all bits of C are zero, or 1 if at least one bit of C is 1.</li>
<li>is_square(x): This function returns True whenever the value x is a square in the field F. Due to Euler&#8217;s criterion, this function can be calculated in constant time as</li>
</ul>
<pre>
is_square(x) := { True,  if x^((q - 1) / 2) is 0 or 1 in F;
                { False, otherwise.
</pre>
<p></p>

<ul>
<li>sqrt(x): The sqrt operation is a multi-valued function, i.e. there exist two roots of x in the field F whenever x is square.  To maintain compatibility across implementations while allowing implementors leeway for optimizations, this document does not require sqrt() to return a particular value. Instead, as explained in <a href="#point-sign" class="xref">Section 6.4</a>, any higher-level function that computes square roots also specifies how to determine the sign of the result.  <br><br> The preferred way of computing square roots is to fix a deterministic algorithm particular to F. We give several algorithms in <a href="#appx-sqrt" class="xref">Appendix F</a>.  Regardless of the method chosen, the sqrt function should be implemented in a way that resists timing side channels, i.e., in constant time.</li>
<li>sgn0(x): This function returns either +1 or -1 indicating the &#8220;sign&#8221; of x, where sgn0(x) == -1 just when x is &#8220;negative&#8221;.  In other words, this function always considers 0 to be positive.  This function may be implemented in multiple ways; <a href="#sgn0-variants" class="xref">Section 4.1</a> defines two variants.  Throughout the document, sgn0 is used generically to mean either of these variants.  Each suite in <a href="#suites" class="xref">Section 8</a> specifies the sgn0 variant to be used.</li>
<li>abs(x): The absolute value of x is defined in terms of sgn0 in the natural way, namely, abs(x) := sgn0(x) * x.</li>
<li>inv0(x): This function returns the multiplicative inverse of x in F, extended to all of F by fixing inv0(0) == 0.  To implement inv0 in constant time, compute inv0(x) := x^(q - 2).  Notice on input 0, the output is 0 as required.</li>
<li>I2OSP and OS2IP: These functions are used to convert an octet string to and from a non-negative integer as described in <a href="#RFC8017" class="xref">[RFC8017]</a>.</li>
<li>a || b: denotes the concatenation of bit strings a and b.</li>
</ul>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#sgn0-variants" id="sgn0-variants">sgn0 variants</a>
</h1>
<p id="rfc.section.4.1.p.1">This section defines two ways of determining the &#8220;sign&#8221; of an element of F.  The variant that should be used is a matter of convention.  Other sgn0 variants are possible, but the two given below cover commonly used notions of sign.</p>
<p id="rfc.section.4.1.p.2">It is RECOMMENDED to select the variant that matches the point decompression method of the target curve.  In particular, since point decompression requires computing a square root and then choosing the sign of the resulting point, all decompression methods specify, implicitly or explicitly, a method for determining the sign of an element of F.  It is convenient for hash-to-curve and decompression to agree on a notion of sign, since this may permit simpler implementations.</p>
<p id="rfc.section.4.1.p.3">See <a href="#bg-curves" class="xref">Section 2.1</a> for a discussion of representing elements of extension fields as vectors; this representation is used in both of the sgn0 variants below.</p>
<p id="rfc.section.4.1.p.4">Note that any valid sgn0 function for extension fields must iterate over the entire vector representation of the input element.  To see why, imagine a function sgn0* that ignores the final entry in its input vector, and consider a field element x = (0, x_2).  Since sgn0* ignores x_2, sgn0*(x) == sgn0*(-x), which is incorrect when x_2 != 0.  The same argument applies to all entries of any x, establishing the claim.</p>
<h1 id="rfc.section.4.1.1">
<a href="#rfc.section.4.1.1">4.1.1.</a> <a href="#sgn0-be" id="sgn0-be">Big endian variant</a>
</h1>
<p id="rfc.section.4.1.1.p.1">The following sgn0 variant is defined such that sgn0_be(x) = -1 just when the big-endian encoding of x is lexically greater than the encoding of -x.</p>
<p id="rfc.section.4.1.1.p.2">This variant SHOULD be used when points on the target elliptic curve are serialized using the SORT compression method given in IEEE 1363a-2004 <a href="#p1363a" class="xref">[p1363a]</a>, Section 5.5.6.1.2, and other similar methods.</p>
<pre>
sgn0_be(x)

Parameters:
- F, a finite field of characteristic p and order q = p^m.
- p, the characteristic of F (see immediately above).
- m, the extension degree of F, m &gt;= 1 (see immediately above).

Input: x, an element of F.
Output: -1 or 1 (an integer).

Notation: x_i is the i^th element of the vector representation of x.

Steps:
1. sign = 0
2. for i in (m, m - 1, ..., 1):
3.   sign_i = CMOV(1, -1, x_i &gt; ((p - 1) / 2))
4.   sign_i = CMOV(sign_i, 0, x_i == 0)
5.   sign = CMOV(sign, sign_i, sign == 0)
6. return CMOV(sign, 1, sign == 0)    // Regard x == 0 as positive
</pre>
<h1 id="rfc.section.4.1.2">
<a href="#rfc.section.4.1.2">4.1.2.</a> <a href="#sgn0-le" id="sgn0-le">Little endian variant</a>
</h1>
<p id="rfc.section.4.1.2.p.1">The following sgn0 variant is defined such that sgn0_le(x) = -1 just when x != 0 and the parity of the least significant nonzero entry of the vector representation of x is 1.</p>
<p id="rfc.section.4.1.2.p.2">This variant SHOULD be used when points on the target elliptic curve are serialized using any of the following methods:</p>
<p></p>

<ul>
<li>the LSB compression method given in IEEE 1363a-2004 <a href="#p1363a" class="xref">[p1363a]</a>, Section 5.5.6.1.1,</li>
<li>the method given in <a href="#SEC1" class="xref">[SEC1]</a> Section 2.3.3, or</li>
<li>the method given in ANSI X9.62-1998 <a href="#x9.62" class="xref">[x9.62]</a>, Section 4.2.1.</li>
</ul>
<p id="rfc.section.4.1.2.p.4">This variant is also compatible with the compression method specified for the Ed25519 and Ed448 elliptic curves <a href="#RFC8032" class="xref">[RFC8032]</a>.</p>
<pre>
sgn0_le(x)

Parameters:
- F, a finite field of characteristic p and order q = p^m.
- p, the characteristic of F (see immediately above).
- m, the extension degree of F, m &gt;= 1 (see immediately above).

Input: x, an element of F.
Output: -1 or 1 (an integer).

Notation: x_i is the i^th element of the vector representation of x.

Steps:
1. sign = 0
2. for i in (1, 2, ..., m):
3.   sign_i = CMOV(1, -1, x_i mod 2 == 1)
4.   sign_i = CMOV(sign_i, 0, x_i == 0)
5.   sign = CMOV(sign, sign_i, sign == 0)
6. return CMOV(sign, 1, sign == 0)     // regard x == 0 as positive
</pre>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#hashtobase" id="hashtobase">Hashing to a Finite Field</a>
</h1>
<p id="rfc.section.5.p.1">The hash_to_base function hashes a string msg of any length into an element of a field F. This function is parametrized by the field F (<a href="#bg-curves" class="xref">Section 2.1</a>) and by H, a cryptographic hash function that outputs b bits.</p>
<p id="rfc.section.5.p.2">Implementors MUST NOT use rejection sampling to generate a uniformly random element of F.  The reason is that these procedures are difficult to implement in constant time, and later well-meaning &#8220;optimizations&#8221; may silently render an implementation non-constant-time.</p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#hashtobase-sec" id="hashtobase-sec">Security considerations</a>
</h1>
<p id="rfc.section.5.1.p.1">For security, hash_to_base should be collision resistant and its output distribution should be uniform over F. To this end, hash_to_base requires a cryptographic hash function H which satisfies the following properties:</p>
<p></p>

<ol>
<li>The number of bits output by H should be b &gt;= 2 * k for sufficient collision resistance, where k is the target security level in bits. (This is needed for a birthday bound of approximately 2^(-k).)</li>
<li>H is modeled as a random oracle, so care should be taken when instantiating it.  Hash functions in the SHA-2 <a href="#FIPS180-4" class="xref">[FIPS180-4]</a> and SHA-3 <a href="#FIPS202" class="xref">[FIPS202]</a> families are typical and RECOMMENDED choices.</li>
</ol>
<p id="rfc.section.5.1.p.3">For example, for 128-bit security, b &gt;= 256 bits; in this case, SHA256 would be an appropriate choice for H.</p>
<p id="rfc.section.5.1.p.4">Ensuring that the hash_to_base output is a uniform random element of F requires care, even when H is modeled as a random oracle. For example, if H is SHA256 and F is a field of characteristic p = 2^255 - 19, then the result of reducing H(msg) (a 256-bit integer) modulo p is slightly more likely to be in [0, 37] than if the value were selected uniformly at random.  In this example the bias is negligible, but in general it can be significant.</p>
<p id="rfc.section.5.1.p.5">To control bias, the input msg should be hashed to an integer comprising at least ceil(log2(p)) + k bits; reducing this integer modulo p gives bias at most 2^-k, which is a safe choice for a cryptosystem with k-bit security.  To obtain such an integer, HKDF <a href="#RFC5869" class="xref">[RFC5869]</a> is used to expand the input msg to a L-byte string, where L = ceil((ceil(log2(p)) + k) / 8); this string is then interpreted as an integer via OS2IP <a href="#RFC8017" class="xref">[RFC8017]</a>. For example, for p a 255-bit prime and k = 128-bit security, L = ceil((255 + 128) / 8) = 48 bytes.</p>
<p id="rfc.section.5.1.p.6">Finally, hash_to_base appends one zero byte to msg in the invocation of HKDF-Extract.  This ensures that the use of HKDF in hash_to_base is indifferentiable from a random oracle (see <a href="#LBB19" class="xref">[LBB19]</a>, Lemma 8 and <a href="#DRST12" class="xref">[DRST12]</a>, Theorems 4.3 and 4.4).  (In particular, this approach works because it ensures that the final byte of each HMAC invocation in HKDF-Extract and HKDF-Expand is distinct.)</p>
<p><a href="#domain-separation" class="xref">Section 3.1</a> discusses requirements for domain separation and recommendations for choosing domain separation tags. The hash_to_curve function takes such a tag as a parameter, DST; this is the REQUIRED method for applying domain separation.</p>
<p><a href="#hashtobase-impl" class="xref">Section 5.3</a> details the hash_to_base procedure.</p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#hashtobase-perf" id="hashtobase-perf">Performance considerations</a>
</h1>
<p id="rfc.section.5.2.p.1">The hash_to_base function uses HKDF-Extract to combine the input msg and domain separation tag DST into a short digest, which is then passed to HKDF-Expand <a href="#RFC5869" class="xref">[RFC5869]</a>.  For short messages, this entails at most two extra invocations of H, which is a negligible overhead in the context of hashing to elliptic curves.</p>
<p id="rfc.section.5.2.p.2">A related issue is that the random oracle construction described in <a href="#roadmap" class="xref">Section 3</a> requires evaluating two independent hash functions H0 and H1 on msg.  One way to instantiate independent hashes is to append a counter to the value being hashed, e.g., H(msg || 0) and H(msg || 1).  If msg is long, however, this is either inefficient (because it entails hashing msg twice) or requires non-black-box use of H (e.g., partial evaluation).</p>
<p id="rfc.section.5.2.p.3">To sidestep both of these issues, hash_to_base takes a second argument, ctr, which it passes to HKDF-Expand.  This means that two invocations of hash_to_base on the same msg with different ctr values both start with identical invocations of HKDF-Extract.  This is an improvement because it allows sharing one evaluation of HKDF-Extract among multiple invocations of hash_to_base, i.e., by factoring out the common computation.</p>
<h1 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> <a href="#hashtobase-impl" id="hashtobase-impl">Implementation</a>
</h1>
<p id="rfc.section.5.3.p.1">The following procedure implements hash_to_base.</p>
<pre>
hash_to_base(msg, ctr)

Parameters:
- DST, a domain separation tag (see discussion above).
- H, a cryptographic hash function.
- F, a finite field of characteristic p and order q = p^m.
- p, the characteristic of F (see immediately above).
- m, the extension degree of F, m &gt;= 1 (see immediately above).
- L = ceil((ceil(log2(p)) + k) / 8), where k is the security
  parameter of the cryptosystem (e.g., k = 128).
- HKDF-Extract and HKDF-Expand are as defined in RFC5869,
  instantiated with the hash function H.

Inputs:
- msg is the message to hash.
- ctr is 0, 1, or 2.
  This is used to efficiently create independent
  instances of hash_to_base (see discussion above).

Output:
- u, an element in F.

Steps:
1. msg_prime = HKDF-Extract(DST, msg || I2OSP(0, 1))
2. info_pfx = "H2C" || I2OSP(ctr, 1)   // "H2C" is a 3-byte ASCII string
3. for i in (1, ..., m):
4.   info = info_pfx || I2OSP(i, 1)
5.   t = HKDF-Expand(msg_prime, info, L)
6.   e_i = OS2IP(t) mod p
7. u = (e_1, ..., e_m)
8. return u
</pre>
<h1 id="rfc.section.5.4">
<a href="#rfc.section.5.4">5.4.</a> <a href="#hashtobase-alt" id="hashtobase-alt">Alternative hash_to_base functions</a>
</h1>
<p id="rfc.section.5.4.p.1">The hash_to_base function is suitable for use with a wide range of hash functions, including SHA-2 <a href="#FIPS180-4" class="xref">[FIPS180-4]</a>, SHA-3 <a href="#FIPS202" class="xref">[FIPS202]</a>, BLAKE2 <a href="#RFC7693" class="xref">[RFC7693]</a>, and others.  In some cases, however, implementors may wish to replace the HKDF-based function defined in this section with one built on a different pseudorandom function.  This section briefly describes the REQUIRED way of doing so.</p>
<p id="rfc.section.5.4.p.2">The security considerations of <a href="#hashtobase-sec" class="xref">Section 5.1</a> continue to apply.  In particular, an alternative hash_to_base function:</p>
<p></p>

<ul>
<li>MUST give collision resistance commensurate with the security level of the target elliptic curve.</li>
<li>MUST be built on a pseudorandom function that is designed for use in applications requiring cryptographic randomness.</li>
<li>MUST NOT use rejection sampling.</li>
<li>MUST output an element of F whose statistical distance from uniform is commensurate with the security level of the target elliptic curve.  It is RECOMMENDED to follow the guidelines for controlling bias in <a href="#hashtobase-sec" class="xref">Section 5.1</a>.</li>
<li>MUST give independent output values for distinct (msg, ctr) inputs.</li>
<li>MUST support domain separation via a supplied domain separation tag (DST).  Care is required when implementing domain separation: this document assumes that instantiating hash_to_base with distinct DSTs yields independent hash functions.</li>
</ul>
<p id="rfc.section.5.4.p.4">The efficiency considerations of <a href="#hashtobase-perf" class="xref">Section 5.2</a> should also be followed.  In particular, it SHOULD be possible to hash one msg with multiple ctr values without requiring multiple passes over msg.</p>
<p id="rfc.section.5.4.p.5">Finally, the Suite ID value MUST be modified to indicate that an alternative hash_to_base function is being used.  <a href="#suiteIDformat" class="xref">Section 8.2</a> gives details.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#mappings" id="mappings">Deterministic Mappings</a>
</h1>
<p id="rfc.section.6.p.1">The mappings in this section are suitable for constructing either nonuniform or random oracle encodings using the constructions of <a href="#roadmap" class="xref">Section 3</a>.  Certain mappings restrict the form of the curve or its parameters.  For each mapping presented, this document lists the relevant restrictions.</p>
<p id="rfc.section.6.p.2">Note that mappings in this section are not interchangeable: different mappings will almost certainly output different points when evaluated on the same input.</p>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> <a href="#choosing-mapping" id="choosing-mapping">Choosing a mapping function</a>
</h1>
<p id="rfc.section.6.1.p.1">This section gives brief guidelines on choosing a mapping function for a given elliptic curve.  Note that the suites given in <a href="#suites" class="xref">Section 8</a> are recommended mappings for the respective curves.</p>
<p id="rfc.section.6.1.p.2">If the target elliptic curve is a supersingular curve supported by either the Boneh-Franklin method (<a href="#bfmap" class="xref">Section 6.9.1</a>) or the Elligator 2 method for A == 0 (<a href="#ell2a0" class="xref">Section 6.9.2</a>), that mapping is the recommended one.</p>
<p id="rfc.section.6.1.p.3">Otherwise, if the target elliptic curve is a Montgomery curve (<a href="#montgomery" class="xref">Section 6.7</a>), the Elligator 2 method (<a href="#elligator2" class="xref">Section 6.7.1</a>) is recommended.  Similarly, if the target elliptic curve is a twisted Edwards curve (<a href="#twisted-edwards" class="xref">Section 6.8</a>), the twisted Edwards Elligator 2 method (<a href="#ell2edwards" class="xref">Section 6.8.2</a>) is recommended.</p>
<p id="rfc.section.6.1.p.4">The remaining cases are Weierstrass curves.  For curves supported by the Simplified SWU method (<a href="#simple-swu" class="xref">Section 6.6.2</a>), that mapping is the recommended one.  Otherwise, the Simplified SWU method for AB == 0 (<a href="#simple-swu-AB0" class="xref">Section 6.6.3</a>) is recommended if the goal is best performance, while the Shallue-van de Woestijne method (<a href="#svdw" class="xref">Section 6.6.1</a>) is recommended if the goal is simplicity of implementation.  (The reason for this distinction is that the Simplified SWU method for AB == 0 requires implementing an isogeny map in addition to the mapping function, while the Shallue-van de Woestijne method does not.)</p>
<p id="rfc.section.6.1.p.5">The Shallue-van de Woestijne method (<a href="#svdw" class="xref">Section 6.6.1</a>) works with any curve, and may be used in cases where a generic mapping is required.  Note, however, that this mapping is almost always more computationally expensive than the curve-specific recommendations above.</p>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> <a href="#interface" id="interface">Interface</a>
</h1>
<p id="rfc.section.6.2.p.1">The generic interface shared by all mappings in this section is as follows:</p>
<pre>
(x, y) = map_to_curve(u)
</pre>
<p id="rfc.section.6.2.p.2">The input u and outputs x and y are elements of the field F.  The coordinates (x, y) specify a point on an elliptic curve defined over F.  Note that the point (x, y) is not a uniformly random point. If uniformity is required for security, the random oracle construction of <a href="#roadmap" class="xref">Section 3</a> MUST be used instead.</p>
<h1 id="rfc.section.6.3">
<a href="#rfc.section.6.3">6.3.</a> <a href="#notation" id="notation">Notation</a>
</h1>
<p id="rfc.section.6.3.p.1">As a rough style guide the following convention is used:</p>
<p></p>

<ul>
<li>All arithmetic operations are performed over a field F, unless explicitly stated otherwise.</li>
<li>u: the input to the mapping function.  This is an element of F produced by the hash_to_base function.</li>
<li>(x, y): are the affine coordinates of the point output by the mapping.  Indexed values are used when the algorithm calculates some candidate values.</li>
<li>t1, t2, &#8230;: are reusable temporary variables. For notable variables, distinct names are used easing the debugging process when correlating with test vectors.</li>
<li>c1, c2, &#8230;: are constant values, which can be computed in advance.</li>
</ul>
<h1 id="rfc.section.6.4">
<a href="#rfc.section.6.4">6.4.</a> <a href="#point-sign" id="point-sign">Sign of the resulting point</a>
</h1>
<p id="rfc.section.6.4.p.1">In general, elliptic curves have equations of the form y^2 = g(x).  Most of the mappings in this section first identify an x such that g(x) is square, then take a square root to find y. Since there are two square roots when g(x) != 0, this results in an ambiguity regarding the sign of y.</p>
<p id="rfc.section.6.4.p.2">To resolve this ambiguity, the mappings in this section specify the sign of the y-coordinate in terms of the input to the mapping function.  Two main reasons support this approach. First, this covers elliptic curves over any field in a uniform way, and second, it gives implementors leeway to optimize their square-root implementations.</p>
<h1 id="rfc.section.6.5">
<a href="#rfc.section.6.5">6.5.</a> <a href="#map-exceptions" id="map-exceptions">Exceptional cases</a>
</h1>
<p id="rfc.section.6.5.p.1">Mappings may have have exceptional cases, i.e., inputs u on which the mapping is undefined. These cases must be handled carefully, especially for constant-time implementations.</p>
<p id="rfc.section.6.5.p.2">For each mapping in this section, we discuss the exceptional cases and show how to handle them in constant time. Note that all implementations SHOULD use inv0 (<a href="#utility" class="xref">Section 4</a>) to compute multiplicative inverses, to avoid exceptional cases that result from attempting to compute the inverse of 0.</p>
<h1 id="rfc.section.6.6">
<a href="#rfc.section.6.6">6.6.</a> <a href="#weierstrass" id="weierstrass">Mappings for Weierstrass curves</a>
</h1>
<p id="rfc.section.6.6.p.1">The following mappings apply to elliptic curves defined by the equation E: y^2 = g(x) = x^3 + A * x + B, where 4 * A^3 + 27 * B^2 != 0.</p>
<h1 id="rfc.section.6.6.1">
<a href="#rfc.section.6.6.1">6.6.1.</a> <a href="#svdw" id="svdw">Shallue-van de Woestijne Method</a>
</h1>
<p id="rfc.section.6.6.1.p.1">Shallue and van de Woestijne <a href="#SW06" class="xref">[SW06]</a> describe a mapping that applies to essentially any elliptic curve.  (Note, however, that this mapping is more expensive to evaluate than the other mappings in this document.)</p>
<p id="rfc.section.6.6.1.p.2">The parameterization given below is for Weierstrass curves; its derivation is detailed in <a href="#W19" class="xref">[W19]</a>.  This parameterization also works for Montgomery (<a href="#montgomery" class="xref">Section 6.7</a>) and twisted Edwards (<a href="#twisted-edwards" class="xref">Section 6.8</a>) curves via the rational maps given in <a href="#appx-rational-map" class="xref">Appendix B</a>: first evaluate the Shallue-van de Woestijne mapping to an equivalent Weierstrass curve, then map that point to the target Montgomery or twisted Edwards curve using the corresponding rational map.</p>
<p id="rfc.section.6.6.1.p.3">Preconditions: A Weierstrass curve y^2 = x^3 + A * x + B over F = GF(p^m) where p &gt; 5 and odd.</p>
<p id="rfc.section.6.6.1.p.4">Constants:</p>
<p></p>

<ul>
<li>A and B, the parameter of the Weierstrass curve.</li>
<li>Z, an element of F meeting the below criteria.  <a href="#svdw-z-code" class="xref">Appendix E.1</a> gives a Sage <a href="#SAGE" class="xref">[SAGE]</a> script that outputs the RECOMMENDED Z.  <ol>
<li>g(Z) != 0 in F.</li>
<li>-(3 * Z^2 + 4 * A) / (4 * g(Z)) != 0 in F.</li>
<li>-(3 * Z^2 + 4 * A) / (4 * g(Z)) is square in F.</li>
<li>At least one of g(Z) and g(-Z / 2) is square in F.</li>
</ol>
</li>
</ul>
<p id="rfc.section.6.6.1.p.6">Sign of y: Inputs u and -u give the same x-coordinate.  Thus, we set sgn0(y) == sgn0(u).</p>
<p id="rfc.section.6.6.1.p.7">Exceptions: The exceptional cases for u occur when (1 + u^2 * g(Z)) * (1 - u^2 * g(Z)) == 0.  The restrictions on Z given above ensure that implementations that use inv0 to invert this product are exception free.</p>
<p id="rfc.section.6.6.1.p.8">Operations:</p>
<pre>
1. t1 = u^2 * g(Z)
2. t2 = 1 + t1
3. t1 = 1 - t1
4. t3 = inv0(t1 * t2)
5. t4 = u * t1 * t3 * sqrt(-g(Z) * (3 * Z^2 + 4 * A))
6. x1 = -Z / 2 - t4
7. x2 = -Z / 2 + t4
8. t5 = 2 * t2^2 * t3 * sqrt(-g(Z) / (3 * Z^2 + 4 * A))
9. x3 = Z + t5^2
10. If is_square(g(x1)), set x = x1 and y = sqrt(g(x1))
11. Else If is_square(g(x2)), set x = x2 and y = sqrt(g(x2))
12. Else set x = x3 and y = sqrt(g(x3))
13. If sgn0(u) != sgn0(y), set y = -y
14. return (x, y)
</pre>
<h1 id="rfc.section.6.6.1.1">
<a href="#rfc.section.6.6.1.1">6.6.1.1.</a> <a href="#implementation" id="implementation">Implementation</a>
</h1>
<p id="rfc.section.6.6.1.1.p.1">The following procedure implements the Shallue and van de Woestijne method in a straight-line fashion.</p>
<pre>
map_to_curve_svdw(u)
Input: u, an element of F.
Output: (x, y), a point on E.

Constants:
1. c1 = g(Z)
2. c2 = -Z / 2
3. c3 = sqrt(-g(Z) * (3 * Z^2 + 4 * A))         // sgn0(c3) MUST equal 1
4. c4 = -4 * g(Z) / (3 * Z^2 + 4 * A)

Steps:
1.   t1 = u^2
2.   t1 = t1 * c1
3.   t2 = 1 + t1
4.   t1 = 1 - t1
5.   t3 = t1 * t2
6.   t3 = inv0(t3)
7.   t4 = u * t1
8.   t4 = t4 * t3
9.   t4 = t4 * c3
10.  x1 = c2 - t4
11. gx1 = x1^2
12. gx1 = gx1 + A
13. gx1 = gx1 * x1
14. gx1 = gx1 + B
15.  e1 = is_square(gx1)
16.  x2 = c2 + t4
17. gx2 = x2^2
18. gx2 = gx2 + A
19. gx2 = gx2 * x2
20. gx2 = gx2 + B
21.  e2 = is_square(gx2) AND NOT e1     // Avoid short-circuit logic ops
22.  x3 = t2^2
23.  x3 = x3 * t3
24.  x3 = x3^2
25.  x3 = x3 * c4
26.  x3 = x3 + Z
27.   x = CMOV(x3, x1, e1)      // x = x1 if gx1 is square, else x = x3
28.   x = CMOV(x, x2, e2)       // x = x2 if gx2 is square and gx1 is not
29.  gx = x^2
30.  gx = gx + A
31.  gx = gx * x
32.  gx = gx + B
33.   y = sqrt(gx)
34.  e3 = sgn0(u) == sgn0(y)
35.   y = CMOV(-y, y, e3)       // Select correct sign of y
36. return (x, y)
</pre>
<h1 id="rfc.section.6.6.2">
<a href="#rfc.section.6.6.2">6.6.2.</a> <a href="#simple-swu" id="simple-swu">Simplified Shallue-van de Woestijne-Ulas Method</a>
</h1>
<p id="rfc.section.6.6.2.p.1">The function map_to_curve_simple_swu(u) implements a simplification of the Shallue-van de Woestijne-Ulas mapping <a href="#U07" class="xref">[U07]</a> described by Brier et al. <a href="#BCIMRT10" class="xref">[BCIMRT10]</a>, which they call the &#8220;simplified SWU&#8221; map. Wahby and Boneh <a href="#WB19" class="xref">[WB19]</a> generalize this mapping to curves over fields of odd characteristic p &gt; 3.</p>
<p id="rfc.section.6.6.2.p.2">Preconditions: A Weierstrass curve y^2 = x^3 + A * x + B over F = GF(p^m) where p &gt; 5 and odd, A != 0, and B != 0.</p>
<p id="rfc.section.6.6.2.p.3">Constants:</p>
<p></p>

<ul>
<li>A and B, the parameters of the Weierstrass curve.</li>
<li>Z, an element of F meeting the below criteria.  <a href="#sswu-z-code" class="xref">Appendix E.2</a> gives a Sage <a href="#SAGE" class="xref">[SAGE]</a> script that outputs the RECOMMENDED Z.  The criteria are:  <ol>
<li>Z is non-square in F,</li>
<li>Z != -1 in F,</li>
<li>the polynomial g(x) - Z is irreducible over F, and</li>
<li>g(B / (Z * A)) is square in F.</li>
</ol>
</li>
</ul>
<p id="rfc.section.6.6.2.p.5">Sign of y: Inputs u and -u give the same x-coordinate.  Thus, we set sgn0(y) == sgn0(u).</p>
<p id="rfc.section.6.6.2.p.6">Exceptions: The exceptional cases are values of u such that Z^2 * u^4 + Z * u^2 == 0. This includes u == 0, and may include other values depending on Z. Implementations must detect this case and set x1 = B / (Z * A), which guarantees that g(x1) is square by the condition on Z given above.</p>
<p id="rfc.section.6.6.2.p.7">Operations:</p>
<pre>
1.  t1 = inv0(Z^2 * u^4 + Z * u^2)
2.  x1 = (-B / A) * (1 + t1)
3.  If t1 == 0, set x1 = B / (Z * A)
4. gx1 = x1^3 + A * x1 + B
5.  x2 = Z * u^2 * x1
6. gx2 = x2^3 + A * x2 + B
7.  If is_square(gx1), set x = x1 and y = sqrt(gx1)
8.  Else set x = x2 and y = sqrt(gx2)
9.  If sgn0(u) != sgn0(y), set y = -y
10. return (x, y)
</pre>
<h1 id="rfc.section.6.6.2.1">
<a href="#rfc.section.6.6.2.1">6.6.2.1.</a> <a href="#implementation-1" id="implementation-1">Implementation</a>
</h1>
<p id="rfc.section.6.6.2.1.p.1">The following procedure implements the simplified SWU mapping in a straight-line fashion.  <a href="#samplecode" class="xref">Appendix D</a> gives an optimized straight-line procedure for P-256 <a href="#FIPS186-4" class="xref">[FIPS186-4]</a>.  For more information on optimizing this mapping, see <a href="#WB19" class="xref">[WB19]</a> Section 4 or the example code found at <a href="#hash2curve-repo" class="xref">[hash2curve-repo]</a>.</p>
<pre>
map_to_curve_simple_swu(u)
Input: u, an element of F.
Output: (x, y), a point on E.

Constants:
1.  c1 = -B / A
2.  c2 = -1 / Z

Steps:
1.   t1 = Z * u^2
2.   t2 = t1^2
3.   x1 = t1 + t2
4.   x1 = inv0(x1)
5.   e1 = x1 == 0
6.   x1 = x1 + 1
7.   x1 = CMOV(x1, c2, e1)    // If (t1 + t2) == 0, set x1 = -1 / Z
8.   x1 = x1 * c1      // x1 = (-B / A) * (1 + (1 / (Z^2 * u^4 + Z * u^2)))
9.  gx1 = x1^2
10. gx1 = gx1 + A
11. gx1 = gx1 * x1
12. gx1 = gx1 + B             // gx1 = g(x1) = x1^3 + A * x1 + B
13.  x2 = t1 * x1             // x2 = Z * u^2 * x1
14.  t2 = t1 * t2
15. gx2 = gx1 * t2            // gx2 = (Z * u^2)^3 * gx1
16.  e2 = is_square(gx1)
17.   x = CMOV(x2, x1, e2)    // If is_square(gx1), x = x1, else x = x2
18.  y2 = CMOV(gx2, gx1, e2)  // If is_square(gx1), y2 = gx1, else y2 = gx2
19.   y = sqrt(y2)
20.  e3 = sgn0(u) == sgn0(y)  // Fix sign of y
21.   y = CMOV(-y, y, e3)
22. return (x, y)
</pre>
<h1 id="rfc.section.6.6.3">
<a href="#rfc.section.6.6.3">6.6.3.</a> <a href="#simple-swu-AB0" id="simple-swu-AB0">Simplified SWU for AB == 0</a>
</h1>
<p id="rfc.section.6.6.3.p.1">Wahby and Boneh <a href="#WB19" class="xref">[WB19]</a> show how to adapt the simplified SWU mapping to Weierstrass curves having A == 0 or B == 0, which the mapping of <a href="#simple-swu" class="xref">Section 6.6.2</a> does not support.  (The case A == B == 0 is excluded because y^2 = x^3 is not an elliptic curve.)</p>
<p id="rfc.section.6.6.3.p.2">This method applies to curves like secp256k1 <a href="#SEC2" class="xref">[SEC2]</a> and to pairing-friendly curves in the Barreto-Lynn-Scott <a href="#BLS03" class="xref">[BLS03]</a>, Barreto-Naehrig <a href="#BN05" class="xref">[BN05]</a>, and other families.</p>
<p id="rfc.section.6.6.3.p.3">This method requires finding another elliptic curve</p>
<pre>
E': y^2 = g'(x) = x^3 + A' * x + B'
</pre>
<p id="rfc.section.6.6.3.p.4">that is isogenous to E and has A&#8217; != 0 and B&#8217; != 0.  (One might do this, for example, using <a href="#SAGE" class="xref">[SAGE]</a>; for details, see <a href="#WB19" class="xref">[WB19]</a>, Appendix A.) This isogeny defines a map iso_map(x&#8217;, y&#8217;) that takes as input a point on E&#8217; and produces as output a point on E.</p>
<p id="rfc.section.6.6.3.p.5">Once E&#8217; and iso_map are identified, this mapping works as follows: on input u, first apply the simplified SWU mapping to get a point on E&#8217;, then apply the isogeny map to that point to get a point on E.</p>
<p id="rfc.section.6.6.3.p.6">Note that iso_map is a group homomorphism, meaning that point addition commutes with iso_map.  Thus, when using this mapping in the hash_to_curve construction of <a href="#roadmap" class="xref">Section 3</a>, one can effect a small optimization by first mapping u0 and u1 to E&#8217;, adding the resulting points on E&#8217;, and then applying iso_map to the sum.  This gives the same result while requiring only one evaluation of iso_map.</p>
<p id="rfc.section.6.6.3.p.7">Preconditions: An elliptic curve E&#8217; with A&#8217; != 0 and B&#8217; != 0 that is isogenous to the target curve E with isogeny map iso_map(x, y) from E&#8217; to E.</p>
<p id="rfc.section.6.6.3.p.8">Helper functions:</p>
<p></p>

<ul>
<li>map_to_curve_simple_swu is the mapping of <a href="#simple-swu" class="xref">Section 6.6.2</a> to E&#8217;</li>
<li>iso_map is the isogeny map from E&#8217; to E</li>
</ul>
<p id="rfc.section.6.6.3.p.10">Sign of y: for this map, the sign is determined by map_to_curve_simple_swu.  No further sign adjustments are necessary.</p>
<p id="rfc.section.6.6.3.p.11">Exceptions: map_to_curve_simple_swu handles its exceptional cases.  Exceptional cases of iso_map MUST return the identity point on E.</p>
<p id="rfc.section.6.6.3.p.12">Operations:</p>
<pre>
1. (x', y') = map_to_curve_simple_swu(u)    // (x', y') is on E'
2.   (x, y) = iso_map(x', y')               // (x, y) is on E
3. return (x, y)
</pre>
<p id="rfc.section.6.6.3.p.13">See <a href="#hash2curve-repo" class="xref">[hash2curve-repo]</a> or <a href="#WB19" class="xref">[WB19]</a>, Section 4.3 for details on implementing the isogeny map.</p>
<h1 id="rfc.section.6.7">
<a href="#rfc.section.6.7">6.7.</a> <a href="#montgomery" id="montgomery">Mappings for Montgomery curves</a>
</h1>
<p id="rfc.section.6.7.p.1">The mapping defined in <a href="#elligator2" class="xref">Section 6.7.1</a> implements Elligator 2 <a href="#BHKL13" class="xref">[BHKL13]</a> for curves defined by the Weierstrass equation y^2 = x^3 + A * x^2 + B * x.</p>
<p id="rfc.section.6.7.p.2">Such a Weierstrass curve is related to the Montgomery curve B&#8217; * t^2 = s^3 + A&#8217; * s^2 + s by the following change of variables:</p>
<p></p>

<ul>
<li>A = A&#8217; / B&#8217;</li>
<li>B = 1 / B&#8217;^2</li>
<li>x = s / B&#8217;</li>
<li>y = t / B&#8217;</li>
</ul>
<p id="rfc.section.6.7.p.4">The Elligator 2 mapping given below returns a point (x, y) on the Weierstrass curve defined above.  This point can be converted to a point (s, t) on the original Montgomery curve by computing</p>
<p></p>

<ul>
<li>s = B&#8217; * x</li>
<li>t = B&#8217; * y</li>
</ul>
<p id="rfc.section.6.7.p.6">Note that when B and B&#8217; are equal to 1, the above two curve equations are identical and no conversion is necessary.  This is the case, for example, for Curve25519 and Curve448 <a href="#RFC7748" class="xref">[RFC7748]</a>.</p>
<h1 id="rfc.section.6.7.1">
<a href="#rfc.section.6.7.1">6.7.1.</a> <a href="#elligator2" id="elligator2">Elligator 2 Method</a>
</h1>
<p id="rfc.section.6.7.1.p.1">Preconditions: A Weierstrass curve y^2 = x^3 + A * x^2 + B * x where A != 0, B != 0, and A^2 - 4 * B is non-zero and non-square in F.</p>
<p id="rfc.section.6.7.1.p.2">Constants:</p>
<p></p>

<ul>
<li>A and B, the parameters of the elliptic curve.</li>
<li>Z, a non-square element of F.  <a href="#elligator-z-code" class="xref">Appendix E.3</a> gives a Sage <a href="#SAGE" class="xref">[SAGE]</a> script that outputs the RECOMMENDED Z.</li>
</ul>
<p id="rfc.section.6.7.1.p.4">Sign of y: Inputs u and -u give the same x-coordinate.  Thus, we set sgn0(y) == sgn0(u).</p>
<p id="rfc.section.6.7.1.p.5">Exceptions: The exceptional case is Z * u^2 == -1, i.e., 1 + Z * u^2 == 0.  Implementations must detect this case and set x1 = -A.  Note that this can only happen when q = 3 (mod 4).</p>
<p id="rfc.section.6.7.1.p.6">Operations:</p>
<pre>
1.  x1 = -A * inv0(1 + Z * u^2)
2.  If x1 == 0, set x1 = -A.
3. gx1 = x1^3 + A * x1^2 + B * x1
4.  x2 = -x1 - A
5. gx2 = x2^3 + A * x2^2 + B * x2
6.  If is_square(gx1), set x = x1 and y = sqrt(gx1)
7.  Else set x = x2 and y = sqrt(gx2)
8.  If sgn0(u) != sgn0(y), set y = -y
9.  return (x, y)
</pre>
<h1 id="rfc.section.6.7.1.1">
<a href="#rfc.section.6.7.1.1">6.7.1.1.</a> <a href="#implementation-2" id="implementation-2">Implementation</a>
</h1>
<p id="rfc.section.6.7.1.1.p.1">The following procedure implements Elligator 2 in a straight-line fashion.  <a href="#samplecode" class="xref">Appendix D</a> gives optimized straight-line procedures for curve25519 and curve448 <a href="#RFC7748" class="xref">[RFC7748]</a>.</p>
<pre>
map_to_curve_elligator2(u)
Input: u, an element of F.
Output: (x, y), a point on E.

Steps:
1.   t1 = u^2
2.   t1 = Z * t1              // Z * u^2
3.   e1 = t1 == -1            // exceptional case: Z * u^2 == -1
4.   t1 = CMOV(t1, 0, e1)     // if t1 == -1, set t1 = 0
5.   x1 = t1 + 1
6.   x1 = inv0(x1)
7.   x1 = -A * x1             // x1 = -A / (1 + Z * u^2)
8.  gx1 = x1 + A
9.  gx1 = gx1 * x1
10. gx1 = gx1 + B
11. gx1 = gx1 * x1            // gx1 = x1^3 + A * x1^2 + B * x1
12.  x2 = -x1 - A
13. gx2 = t1 * gx1
14.  e2 = is_square(gx1)
15.   x = CMOV(x2, x1, e2)    // If is_square(gx1), x = x1, else x = x2
16.  y2 = CMOV(gx2, gx1, e2)  // If is_square(gx1), y2 = gx1, else y2 = gx2
17.   y = sqrt(y2)
18.  e3 = sgn0(u) == sgn0(y)  // Fix sign of y
19.   y = CMOV(-y, y, e3)
20. return (x, y)
</pre>
<h1 id="rfc.section.6.8">
<a href="#rfc.section.6.8">6.8.</a> <a href="#twisted-edwards" id="twisted-edwards">Mappings for Twisted Edwards curves</a>
</h1>
<p id="rfc.section.6.8.p.1">Twisted Edwards curves (a class of curves that includes Edwards curves) are given by the equation a * v^2 + w^2 = 1 + d * v^2 * w^2, with a != 0, d != 0, and a != d <a href="#BBJLP08" class="xref">[BBJLP08]</a>.</p>
<p id="rfc.section.6.8.p.2">These curves are closely related to Montgomery curves (<a href="#montgomery" class="xref">Section 6.7</a>): every twisted Edwards curve is birationally equivalent to a Montgomery curve (<a href="#BBJLP08" class="xref">[BBJLP08]</a>, Theorem 3.2).  This equivalence yields an efficient way of hashing to a twisted Edwards curve: first, hash to the equivalent Montgomery curve, then transform the result into a point on the twisted Edwards curve via a rational map.  This method of hashing to a twisted Edwards curve thus requires identifying a corresponding Montgomery curve and rational map.  We describe how to identify such a curve and map immediately below.</p>
<h1 id="rfc.section.6.8.1">
<a href="#rfc.section.6.8.1">6.8.1.</a> <a href="#rational-map" id="rational-map">Rational maps from Montgomery to twisted Edwards curves</a>
</h1>
<p id="rfc.section.6.8.1.p.1">There are two ways to identify the correct Montgomery curve and rational map for use when hashing to a given twisted Edwards curve.</p>
<p id="rfc.section.6.8.1.p.2">When hashing to a standardized twisted Edwards curve for which a corresponding Montgomery form and rational map are also standardized, the standard Montgomery form and rational map MUST be used to ensure compatibility with existing software.  Two such standardized curves are the edwards25519 and edwards448 curves, which correspond to the Montgomery curves curve25519 and curve448, respectively.  For both of these curves, <a href="#RFC7748" class="xref">[RFC7748]</a> lists both the Montgomery and twisted Edwards forms and gives the corresponding rational maps.</p>
<p id="rfc.section.6.8.1.p.3">The rational map for edwards25519 (<a href="#RFC7748" class="xref">[RFC7748]</a>, Section 4.1) uses the constant sqrt_neg_486664 = sqrt(-486664) (mod 2^255 - 19).  To ensure compatibility, this constant MUST be chosen such that sgn0(sqrt_neg_486664) == 1.  Analogous ambiguities in other standardized rational maps MUST be resolved in the same way: for any constant k whose sign is ambiguous, k MUST be chosen such that sgn0(k) == 1.</p>
<p id="rfc.section.6.8.1.p.4">The 4-isogeny map from curve448 to edwards448 (<a href="#RFC7748" class="xref">[RFC7748]</a>, Section 4.2) is unambiguous with respect to sign.</p>
<p id="rfc.section.6.8.1.p.5">When defining new twisted Edwards curves, a Montgomery equivalent and rational map SHOULD be specified, and the sign of the rational map SHOULD be stated unambiguously.</p>
<p id="rfc.section.6.8.1.p.6">When hashing to a twisted Edwards curve that does not have a standardized Montgomery form or rational map, the following procedure MUST be used to derive them.  For a twisted Edwards curve given by a * v^2 + w^2 = 1 + d * v^2 * w^2, first compute A and B, the parameters of the equivalent Weierstrass curve given by y^2 = x^3 + A * x^2 + B * x, as follows:</p>
<p></p>

<ul>
<li>A = (a + d) / 2</li>
<li>B = (a - d)^2 / 16</li>
</ul>
<p id="rfc.section.6.8.1.p.8">Note that the above curve is given in the Weierstrass form required by the Elligator 2 mapping of <a href="#elligator2" class="xref">Section 6.7.1</a>.  The rational map from the point (x, y) on this Weierstrass curve to the point (v, w) on the twisted Edwards curve is given by</p>
<p></p>

<ul>
<li>B&#8217; = 1 / sqrt(B) = 4 / (a - d)</li>
<li>v = x / y</li>
<li>w = (B&#8217; * x - 1) / (B&#8217; * x + 1)</li>
</ul>
<p id="rfc.section.6.8.1.p.10">For completeness, we give the inverse map in <a href="#appx-rational-map-edw" class="xref">Appendix B.1</a>.  Note that the inverse map is not used when hashing to a twisted Edwards curve.</p>
<p id="rfc.section.6.8.1.p.11">Rational maps may be undefined on certain inputs, e.g., when the denominator of one of the rational functions is zero.  In the map described above, the exceptional cases are y == 0 or B&#8217; * x == -1.  Implementations MUST detect exceptional cases and return the value (v, w) = (0, 1), which is a valid point on all twisted Edwards curves given by the equation above.</p>
<p id="rfc.section.6.8.1.p.12">The following straight-line implementation of the above rational map handles the exceptional cases.  Implementations of other rational maps (e.g., the ones give in <a href="#RFC7748" class="xref">[RFC7748]</a>) are analogous.</p>
<pre>
rational_map(x, y)
Input: (x, y), a point on the curve y^2 = x^3 + A * x^2 + B * x.
Output: (v, w), a point on an equivalent twisted Edwards curve.

1. t1 = x * B'
2. t2 = t1 + 1
3. t3 = y * t2
4. t3 = inv0(t3)
5.  v = t2 * t3
6.  v = v * x
7.  w = t1 - 1
8.  w = w * y
9.  w = w * t3
10. e = w == 0
11. w = CMOV(w, 1, e)
12. return (v, w)
</pre>
<h1 id="rfc.section.6.8.2">
<a href="#rfc.section.6.8.2">6.8.2.</a> <a href="#ell2edwards" id="ell2edwards">Elligator 2 Method</a>
</h1>
<p id="rfc.section.6.8.2.p.1">Preconditions: A twisted Edwards curve E and an equivalent curve M meeting the requirements in <a href="#rational-map" class="xref">Section 6.8.1</a>.</p>
<p id="rfc.section.6.8.2.p.2">Helper functions:</p>
<p></p>

<ul>
<li>map_to_curve_elligator2 is the mapping of <a href="#elligator2" class="xref">Section 6.7.1</a> to the curve M.</li>
<li>rational_map is a function that takes a point (x, y) on M and returns a point (v, w) on E, as defined in <a href="#rational-map" class="xref">Section 6.8.1</a>.</li>
</ul>
<p id="rfc.section.6.8.2.p.4">Sign of y (and w): for this map, the sign is determined by map_to_curve_elligator2.  No further sign adjustments are required.</p>
<p id="rfc.section.6.8.2.p.5">Exceptions: The exceptions for the Elligator 2 mapping are as given in <a href="#elligator2" class="xref">Section 6.7.1</a>.  The exceptions for the rational map are as given in <a href="#rational-map" class="xref">Section 6.8.1</a>.  No other exceptions are possible.</p>
<p id="rfc.section.6.8.2.p.6">The following procedure implements the Elligator 2 mapping for a twisted Edwards curve.  (Note that the output point is denoted (v, w) because it is a point on the target twisted Edwards curve.)</p>
<pre>
map_to_curve_elligator2_edwards(u)
Input: u, an element of F.
Output: (v, w), a point on E.

1. (x, y) = map_to_curve_elligator2(u)      // (x, y) is on M
2. (v, w) = rational_map(x, y)              // (v, w) is on E
3. return (v, w)
</pre>
<h1 id="rfc.section.6.9">
<a href="#rfc.section.6.9">6.9.</a> <a href="#mappings-for-supersingular-curves" id="mappings-for-supersingular-curves">Mappings for Supersingular curves</a>
</h1>
<h1 id="rfc.section.6.9.1">
<a href="#rfc.section.6.9.1">6.9.1.</a> <a href="#bfmap" id="bfmap">Boneh-Franklin Method</a>
</h1>
<p id="rfc.section.6.9.1.p.1">The function map_to_curve_bf(u) implements the Boneh-Franklin method <a href="#BF01" class="xref">[BF01]</a> which covers the supersingular curves defined by y^2 = x^3 + B over a field F such that q = 2 (mod 3).</p>
<p id="rfc.section.6.9.1.p.2">Preconditions: A supersingular curve over F such that q = 2 (mod 3).</p>
<p id="rfc.section.6.9.1.p.3">Constants: B, the parameter of the supersingular curve.</p>
<p id="rfc.section.6.9.1.p.4">Sign of y: determined by sign of u. No adjustments are necessary.</p>
<p id="rfc.section.6.9.1.p.5">Exceptions: none.</p>
<p id="rfc.section.6.9.1.p.6">Operations:</p>
<pre>
1. w = (2 * q - 1) / 3    // Integer arithmetic
2. x = (u^2 - B)^w
3. y = u
4. return (x, y)
</pre>
<h1 id="rfc.section.6.9.1.1">
<a href="#rfc.section.6.9.1.1">6.9.1.1.</a> <a href="#implementation-3" id="implementation-3">Implementation</a>
</h1>
<p id="rfc.section.6.9.1.1.p.1">The following procedure implements the Boneh-Franklin&#8217;s algorithm in a straight-line fashion.</p>
<pre>
map_to_curve_bf(u)
Input: u, an element of F.
Output: (x, y), a point on E.

Constants:
1. c1 = (2 * q - 1) / 3   // Integer arithmetic

Steps:
1. t1 = u^2
2. t1 = t1 - B
3.  x = t1^c1             // x = (u^2 - B)^((2 * q - 1) / 3)
4.  y = u
5. return (x, y)
</pre>
<h1 id="rfc.section.6.9.2">
<a href="#rfc.section.6.9.2">6.9.2.</a> <a href="#ell2a0" id="ell2a0">Elligator 2, A == 0 Method</a>
</h1>
<p id="rfc.section.6.9.2.p.1">The function map_to_curve_ell2A0(u) implements an adaptation of Elligator 2 <a href="#BLMP19" class="xref">[BLMP19]</a> targeting curves given by y^2 = x^3 + B * x over F such that q = 3 (mod 4).</p>
<p id="rfc.section.6.9.2.p.2">Preconditions: An elliptic curve over F such that q = 3 (mod 4).</p>
<p id="rfc.section.6.9.2.p.3">Constants: B, the parameter of the elliptic curve.</p>
<p id="rfc.section.6.9.2.p.4">Sign of y: Inputs u and -u give the same x-coordinate.  Thus, we set sgn0(y) == sgn0(u).</p>
<p id="rfc.section.6.9.2.p.5">Exceptions: none.</p>
<p id="rfc.section.6.9.2.p.6">Operations:</p>
<pre>
1.  x1 = u
2. gx1 = x1^3 + B * x1
3.  x2 = -x1
4. gx2 = -gx1
5. If is_square(gx1), set x = x1 and y = sqrt(gx1)
6. Else set x = x2 and y = sqrt(gx2)
7. If sgn0(u) != sgn0(y), set y = -y.
8. return (x, y)
</pre>
<h1 id="rfc.section.6.9.2.1">
<a href="#rfc.section.6.9.2.1">6.9.2.1.</a> <a href="#implementation-4" id="implementation-4">Implementation</a>
</h1>
<p id="rfc.section.6.9.2.1.p.1">The following procedure implements the Elligator 2 mapping for A == 0 in a straight-line fashion.</p>
<pre>
map_to_curve_ell2A0(u)
Input: u, an element of F.
Output: (x, y), a point on E.

Constants:
1. c1 = (p + 1) / 4         // Integer arithmetic

Steps:
1.  x1 = u
2.  x2 = -x1
3. gx1 = x1^2
4. gx1 = gx1 + B
5. gx1 = gx1 * x1           // gx1 = x1^3 + B * x1
6.   y = gx1^c1             // This is either sqrt(gx1) or sqrt(gx2)
7.  e1 = (y^2) == gx1
8.   x = CMOV(x2, x1, e1)
9.  e2 = sgn0(u) == sgn0(y)
10.  y = CMOV(-y, y, e2)
11. return (x, y)
</pre>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#cofactor-clearing" id="cofactor-clearing">Clearing the cofactor</a>
</h1>
<p id="rfc.section.7.p.1">The mappings of <a href="#mappings" class="xref">Section 6</a> always output a point on the elliptic curve, i.e., a point in a group of order h * r (<a href="#bg-curves" class="xref">Section 2.1</a>). Obtaining a point in G may require a final operation commonly called &#8220;clearing the cofactor,&#8221; which takes as input any point on the curve.</p>
<p id="rfc.section.7.p.2">The cofactor can always be cleared via scalar multiplication by h.  For elliptic curves where h = 1, i.e., the curves with a prime number of points, no operation is required. This applies, for example, to the NIST curves P-256, P-384, and P-521 <a href="#FIPS186-4" class="xref">[FIPS186-4]</a>.</p>
<p id="rfc.section.7.p.3">In some cases, it is possible to clear the cofactor via a faster method than scalar multiplication by h.  These methods are equivalent to (but usually faster than) multiplication by some scalar h_eff whose value is determined by the method and the curve.  Examples of fast cofactor clearing methods include the following:</p>
<p></p>

<ul>
<li>For certain pairing-friendly curves having subgroup G2 over an extension field, Scott et al. <a href="#SBCDK09" class="xref">[SBCDK09]</a> describe a method for fast cofactor clearing that exploits an efficiently-computable endomorphism. Fuentes-Castaneda et al. <a href="#FKR11" class="xref">[FKR11]</a> propose an alternative method that is sometimes more efficient.  Budroni and Pintore <a href="#BP18" class="xref">[BP18]</a> give concrete instantiations of these methods for Barreto-Lynn-Scott pairing-friendly curves <a href="#BLS03" class="xref">[BLS03]</a>.</li>
<li>Wahby and Boneh (<a href="#WB19" class="xref">[WB19]</a>, Section 5) describe a trick due to Scott for fast cofactor clearing on any elliptic curve for which the prime factorization of h and the structure of the elliptic curve group meet certain conditions.</li>
</ul>
<p id="rfc.section.7.p.5">The clear_cofactor function is parameterized by a scalar h_eff.  Specifically,</p>
<pre>
clear_cofactor(P) := h_eff * P
</pre>
<p id="rfc.section.7.p.6">where * represents scalar multiplication.  When a curve does not support a fast cofactor clearing method, h_eff = h and the cofactor MUST be cleared via scalar multiplication.</p>
<p id="rfc.section.7.p.7">When a curve admits a fast cofactor clearing method, clear_cofactor MAY be evaluated either via that method or via scalar multiplication by the equivalent h_eff; these two methods give the same result.  Note that in this case scalar multiplication by the cofactor h does not generally give the same result as the fast method, and SHOULD NOT be used.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#suites" id="suites">Suites for Hashing</a>
</h1>
<p id="rfc.section.8.p.1">This section lists recommended suites for hashing to standard elliptic curves.</p>
<p id="rfc.section.8.p.2">A suite fully specifies the procedure for hashing bit strings to points on a specific elliptic curve group.  Each suite comprises the following parameters:</p>
<p></p>

<ul>
<li>Suite ID, a short name used to refer to a given suite.  The ID also indicates whether a suite is a random oracle or nonuniform encoding (<a href="#term-rom" class="xref">Section 2.2.3</a>, <a href="#roadmap" class="xref">Section 3</a>).  <a href="#suiteIDformat" class="xref">Section 8.2</a> discusses the naming conventions for suite IDs.</li>
<li>E, the target elliptic curve over a field F.</li>
<li>p, the characteristic of the field F.</li>
<li>m, the extension degree of the field F.</li>
<li>sgn0, one of the variants specified in <a href="#sgn0-variants" class="xref">Section 4.1</a>.</li>
<li>H, the hash function used by hash_to_base (<a href="#hashtobase-sec" class="xref">Section 5.1</a>).</li>
<li>L, the length of HKDF-Expand output in hash_to_base (<a href="#hashtobase-sec" class="xref">Section 5.1</a>).</li>
<li>f, a mapping function from <a href="#mappings" class="xref">Section 6</a>.</li>
<li>h_eff, the scalar parameter for clear_cofactor (<a href="#cofactor-clearing" class="xref">Section 7</a>).</li>
</ul>
<p id="rfc.section.8.p.4">In addition to the above parameters, the mapping f may require additional parameters Z, M, rational_map, E&#8217;, and/or iso_map.  These MUST be specified when applicable.</p>
<p id="rfc.section.8.p.5">All applications MUST choose a domain separation tag (DST) for use with hash_to_base (<a href="#hashtobase" class="xref">Section 5</a>), in accordance with the guidelines of <a href="#domain-separation" class="xref">Section 3.1</a>.  In addition, applications whose security requires a random oracle MUST use a suite specifying hash_to_curve (<a href="#roadmap" class="xref">Section 3</a>); see <a href="#suiteIDformat" class="xref">Section 8.2</a>.</p>
<p id="rfc.section.8.p.6">The below table lists the curves for which suites are defined and the subsection that gives the corresponding parameters.</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">E</th>
<th class="left">Section</th>
</tr></thead>
<tbody>
<tr>
<td class="left">NIST P-256</td>
<td class="left"><a href="#suites-p256" class="xref">Section 8.3</a></td>
</tr>
<tr>
<td class="left">NIST P-384</td>
<td class="left"><a href="#suites-p384" class="xref">Section 8.4</a></td>
</tr>
<tr>
<td class="left">NIST P-521</td>
<td class="left"><a href="#suites-p521" class="xref">Section 8.5</a></td>
</tr>
<tr>
<td class="left">curve25519 / edwards25519</td>
<td class="left"><a href="#suites-25519" class="xref">Section 8.6</a></td>
</tr>
<tr>
<td class="left">curve448 / edwards448</td>
<td class="left"><a href="#suites-448" class="xref">Section 8.7</a></td>
</tr>
<tr>
<td class="left">secp256k1</td>
<td class="left"><a href="#suites-secp256k1" class="xref">Section 8.8</a></td>
</tr>
<tr>
<td class="left">BLS12-381</td>
<td class="left"><a href="#suites-bls12381" class="xref">Section 8.9</a></td>
</tr>
</tbody>
</table>
<h1 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> <a href="#new-suite" id="new-suite">Defining a new hash-to-curve suite</a>
</h1>
<p id="rfc.section.8.1.p.1">The RECOMMENDED way to define a new hash-to-curve suite is:</p>
<p></p>

<ol>
<li>E, F, p, and m are determined by the elliptic curve and the field.</li>
<li>Choose a sgn0 variant following the guidelines in <a href="#sgn0-variants" class="xref">Section 4.1</a>.</li>
<li>Choose a hash function H meeting the requirements in <a href="#hashtobase-sec" class="xref">Section 5.1</a>, and compute L as described in that section.</li>
<li>Choose a mapping following the guidelines in <a href="#choosing-mapping" class="xref">Section 6.1</a>, and select any required parameters for that mapping.</li>
<li>Choose h_eff to be either the cofactor of E or, if a fast cofactor clearing method is to be used, a value appropriate to that method as discussed in <a href="#cofactor-clearing" class="xref">Section 7</a>.</li>
<li>Construct a Suite ID following the guidelines in <a href="#suiteIDformat" class="xref">Section 8.2</a>.</li>
</ol>
<p id="rfc.section.8.1.p.3">When hashing to an elliptic curve not listed in this section, corresponding hash-to-curve suites SHOULD be specified as described in this section.</p>
<h1 id="rfc.section.8.2">
<a href="#rfc.section.8.2">8.2.</a> <a href="#suiteIDformat" id="suiteIDformat">Suite ID naming conventions</a>
</h1>
<p id="rfc.section.8.2.p.1">Suite IDs MUST be constructed as follows:</p>
<pre>
CURVE_ID || "-" || HASH_ID || "-" || MAP_ID || "-" || ENC_VAR || "-"
</pre>
<p id="rfc.section.8.2.p.2">The fields CURVE_ID, HASH_ID, MAP_ID, and ENC_VAR are ASCII-encoded strings of at most 64 characters each.  Fields can contain only ASCII characters between 0x21 and 0x7E (inclusive) other than hyphen and underscore (i.e., 0x2d, and 0x5f).  As indicated above, each field (including the last) is followed by a hyphen (&#8220;-&#8220;, ASCII 0x2d); this helps to ensure that Suite IDs are prefix free.</p>
<p id="rfc.section.8.2.p.3">Fields MUST be chosen as follows:</p>
<p></p>

<ul>
<li>CURVE_ID: a human-readable representation of the target elliptic curve.</li>
<li>HASH_ID: a human-readable representation of the hash function used in hash_to_base (<a href="#hashtobase" class="xref">Section 5</a>).  <br><br> If a suite uses an alternative hash_to_base function (<a href="#hashtobase-alt" class="xref">Section 5.4</a>), a short descriptive name MUST be chosen for that function using only the allowed characters listed above.  That name MUST be appended to the HASH_ID field, separated by a colon.  For example, a hash_to_base function based on KMAC128 <a href="#SP.800-185" class="xref">[SP.800-185]</a> might use the short name &#8220;h2b/kmac128&#8221;, and a reasonable value for the HASH_ID field would be &#8220;SHA3:h2b/kmac128&#8221;.</li>
<li>MAP_ID: a human-readable representation of the map_to_curve function (<a href="#mappings" class="xref">Section 6</a>).</li>
<li>ENC_VAR: a string indicating the encoding type and other information.  The first two characters of this string indicate whether the suite represents a hash_to_curve or an encode_to_curve operation (<a href="#roadmap" class="xref">Section 3</a>), as follows:  <ul>
<li>If ENC_VAR begins with &#8220;RO&#8221;, the suite uses hash_to_curve.</li>
<li>If ENC_VAR begins with &#8220;NU&#8221;, the suite uses encode_to_curve.</li>
<li>ENC_VAR MUST NOT begin with any other string.</li>
</ul>
<p> ENC_VAR MAY also be used to encode other information used to identify variants, for example, a version number.  The RECOMMENDED way to do so is to add one or more subfields separated by colons.  For example, &#8220;RO:V02&#8221; is an appropriate ENC_VAR value for the second version of a random-oracle suite, while &#8220;RO:V02:FOO01:BAR17&#8221; might be used to indicate a variant of that suite.</p>
</li>
</ul>
<h1 id="rfc.section.8.3">
<a href="#rfc.section.8.3">8.3.</a> <a href="#suites-p256" id="suites-p256">Suites for NIST P-256</a>
</h1>
<p id="rfc.section.8.3.p.1">This section defines ciphersuites for the NIST P-256 elliptic curve <a href="#FIPS186-4" class="xref">[FIPS186-4]</a>.</p>
<p id="rfc.section.8.3.p.2">The suites P256-SHA256-SSWU-RO- and P256-SHA256-SSWU-NU- share the following parameters, in addition to the common parameters below.</p>
<p></p>

<ul>
<li>f: Simplified SWU method, <a href="#simple-swu" class="xref">Section 6.6.2</a>
</li>
<li>Z: -10</li>
</ul>
<p id="rfc.section.8.3.p.4">The suites P256-SHA256-SVDW-RO- and P256-SHA256-SVDW-NU- share the following parameters, in addition to the common parameters below.</p>
<p></p>

<ul>
<li>f: Shallue-van de Woestijne method, <a href="#svdw" class="xref">Section 6.6.1</a>
</li>
<li>Z: -3</li>
</ul>
<p id="rfc.section.8.3.p.6">The common parameters for the above suites are:</p>
<p></p>

<ul>
<li>E: y^2 = x^3 + A * x + B, where <ul>
<li>A = -3</li>
<li>B = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b</li>
</ul>
</li>
<li>p: 2^256 - 2^224 + 2^192 + 2^96 - 1</li>
<li>m: 1</li>
<li>sgn0: sgn0_le (<a href="#sgn0-le" class="xref">Section 4.1.2</a>)</li>
<li>H: SHA-256</li>
<li>L: 48</li>
<li>h_eff: 1</li>
</ul>
<p id="rfc.section.8.3.p.8">An optimized example implementation of the Simplified SWU mapping to P-256 is given in <a href="#sswu-map-to-3mod4" class="xref">Appendix D.2</a>.</p>
<h1 id="rfc.section.8.4">
<a href="#rfc.section.8.4">8.4.</a> <a href="#suites-p384" id="suites-p384">Suites for NIST P-384</a>
</h1>
<p id="rfc.section.8.4.p.1">This section defines ciphersuites for the NIST P-384 elliptic curve <a href="#FIPS186-4" class="xref">[FIPS186-4]</a>.</p>
<p id="rfc.section.8.4.p.2">The suites P384-SHA512-SSWU-RO- and P384-SHA512-SSWU-NU- share the following parameters, in addition to the common parameters below.</p>
<p></p>

<ul>
<li>f: Simplified SWU method, <a href="#simple-swu" class="xref">Section 6.6.2</a>
</li>
<li>Z: -12</li>
</ul>
<p id="rfc.section.8.4.p.4">The suites P384-SHA512-SVDW-RO- and P384-SHA512-SVDW-NU- share the following parameters, in addition to the common parameters below.</p>
<p></p>

<ul>
<li>f: Shallue-van de Woestijne method, <a href="#svdw" class="xref">Section 6.6.1</a>
</li>
<li>Z: -1</li>
</ul>
<p id="rfc.section.8.4.p.6">The common parameters for the above suites are:</p>
<p></p>

<ul>
<li>E: y^2 = x^3 + A * x + B, where <ul>
<li>A = -3</li>
<li>B = 0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef</li>
</ul>
</li>
<li>p: 2^384 - 2^128 - 2^96 + 2^32 - 1</li>
<li>m: 1</li>
<li>sgn0: sgn0_le (<a href="#sgn0-le" class="xref">Section 4.1.2</a>)</li>
<li>H: SHA-512</li>
<li>L: 72</li>
<li>h_eff: 1</li>
</ul>
<p id="rfc.section.8.4.p.8">An optimized example implementation of the Simplified SWU mapping to P-384 is given in <a href="#sswu-map-to-3mod4" class="xref">Appendix D.2</a>.</p>
<h1 id="rfc.section.8.5">
<a href="#rfc.section.8.5">8.5.</a> <a href="#suites-p521" id="suites-p521">Suites for NIST P-521</a>
</h1>
<p id="rfc.section.8.5.p.1">This section defines ciphersuites for the NIST P-521 elliptic curve <a href="#FIPS186-4" class="xref">[FIPS186-4]</a>.</p>
<p id="rfc.section.8.5.p.2">The suites P521-SHA512-SSWU-RO- and P521-SHA512-SSWU-NU- share the following parameters, in addition to the common parameters below.</p>
<p></p>

<ul>
<li>f: Simplified SWU method, <a href="#simple-swu" class="xref">Section 6.6.2</a>
</li>
<li>Z: -4</li>
</ul>
<p id="rfc.section.8.5.p.4">The suites P521-SHA512-SVDW-RO- and P521-SHA512-SVDW-NU- share the following parameters, in addition to the common parameters below.</p>
<p></p>

<ul>
<li>f: Shallue-van de Woestijne method, <a href="#svdw" class="xref">Section 6.6.1</a>
</li>
<li>Z: 1</li>
</ul>
<p id="rfc.section.8.5.p.6">The common parameters for the above suites are:</p>
<p></p>

<ul>
<li>E: y^2 = x^3 + A * x + B, where <ul>
<li>A = -3</li>
<li>B = 0x51953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00</li>
</ul>
</li>
<li>p: 2^521 - 1</li>
<li>m: 1</li>
<li>sgn0: sgn0_le (<a href="#sgn0-le" class="xref">Section 4.1.2</a>)</li>
<li>H: SHA-512</li>
<li>L: 96</li>
<li>h_eff: 1</li>
</ul>
<p id="rfc.section.8.5.p.8">An optimized example implementation of the Simplified SWU mapping to P-521 is given in <a href="#sswu-map-to-3mod4" class="xref">Appendix D.2</a>.</p>
<h1 id="rfc.section.8.6">
<a href="#rfc.section.8.6">8.6.</a> <a href="#suites-25519" id="suites-25519">Suites for curve25519 and edwards25519</a>
</h1>
<p id="rfc.section.8.6.p.1">This section defines ciphersuites for curve25519 and edwards25519 <a href="#RFC7748" class="xref">[RFC7748]</a>.</p>
<p id="rfc.section.8.6.p.2">The suites curve25519-SHA256-ELL2-RO- and curve25519-SHA256-ELL2-NU- share the following parameters, in addition to the common parameters below.</p>
<p></p>

<ul>
<li>E: B * y^2 = x^3 + A * x^2 + x, where <ul>
<li>A = 486662</li>
<li>B = 1</li>
</ul>
</li>
<li>f: Elligator 2 method, <a href="#elligator2" class="xref">Section 6.7.1</a>
</li>
</ul>
<p id="rfc.section.8.6.p.4">The suites edwards25519-SHA256-EDELL2-RO- and edwards25519-SHA256-EDELL2-NU- share the following parameters, in addition to the common parameters below.</p>
<p></p>

<ul>
<li>E: a * x^2 + y^2 = 1 + d * x^2 * y^2, where <ul>
<li>a = -1</li>
<li>d = 0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3</li>
</ul>
</li>
<li>f: Twisted Edwards Elligator 2 method, <a href="#ell2edwards" class="xref">Section 6.8.2</a>
</li>
<li>M: curve25519 defined in <a href="#RFC7748" class="xref">[RFC7748]</a>, Section 4.1</li>
<li>rational_map: the birational map defined in <a href="#RFC7748" class="xref">[RFC7748]</a>, Section 4.1</li>
</ul>
<p id="rfc.section.8.6.p.6">The common parameters for all of the above suites are:</p>
<p></p>

<ul>
<li>p: 2^255 - 19</li>
<li>m: 1</li>
<li>sgn0: sgn0_le (<a href="#sgn0-le" class="xref">Section 4.1.2</a>)</li>
<li>H: SHA-256</li>
<li>L: 48</li>
<li>Z: 2</li>
<li>h_eff: 8</li>
</ul>
<p id="rfc.section.8.6.p.8">Optimized example implementations of the above mappings are given in <a href="#map-to-curve25519" class="xref">Appendix D.3</a> and <a href="#map-to-edwards25519" class="xref">Appendix D.4</a>.</p>
<h1 id="rfc.section.8.7">
<a href="#rfc.section.8.7">8.7.</a> <a href="#suites-448" id="suites-448">Suites for curve448 and edwards448</a>
</h1>
<p id="rfc.section.8.7.p.1">This section defines ciphersuites for curve448 and edwards448 <a href="#RFC7748" class="xref">[RFC7748]</a>.</p>
<p id="rfc.section.8.7.p.2">The suites curve448-SHA512-ELL2-RO- and curve448-SHA512-ELL2-NU- share the following parameters, in addition to the common parameters below.</p>
<p></p>

<ul>
<li>E: B * y^2 = x^3 + A * x^2 + x, where <ul>
<li>A = 156326</li>
<li>B = 1</li>
</ul>
</li>
<li>f: Elligator 2 method, <a href="#elligator2" class="xref">Section 6.7.1</a>
</li>
</ul>
<p id="rfc.section.8.7.p.4">The suites edwards448-SHA512-EDELL2-RO- and edwards448-SHA512-EDELL2-NU- share the following parameters, in addition to the common parameters below.</p>
<p></p>

<ul>
<li>E: a * x^2 + y^2 = 1 + d * x^2 * y^2, where <ul>
<li>a = 1</li>
<li>d = -39081</li>
</ul>
</li>
<li>f: Twisted Edwards Elligator 2 method, <a href="#ell2edwards" class="xref">Section 6.8.2</a>
</li>
<li>M: curve448, defined in <a href="#RFC7748" class="xref">[RFC7748]</a>, Section 4.2</li>
<li>rational_map: the 4-isogeny map defined in <a href="#RFC7748" class="xref">[RFC7748]</a>, Section 4.2</li>
</ul>
<p id="rfc.section.8.7.p.6">The common parameters for all of the above suites are:</p>
<p></p>

<ul>
<li>p: 2^448 - 2^224 - 1</li>
<li>m: 1</li>
<li>sgn0: sgn0_le (<a href="#sgn0-le" class="xref">Section 4.1.2</a>)</li>
<li>H: SHA-512</li>
<li>L: 84</li>
<li>Z: -1</li>
<li>h_eff: 4</li>
</ul>
<p id="rfc.section.8.7.p.8">Optimized example implementations of the above mappings are given in <a href="#map-to-curve448" class="xref">Appendix D.5</a> and <a href="#map-to-edwards448" class="xref">Appendix D.6</a>.</p>
<h1 id="rfc.section.8.8">
<a href="#rfc.section.8.8">8.8.</a> <a href="#suites-secp256k1" id="suites-secp256k1">Suites for secp256k1</a>
</h1>
<p id="rfc.section.8.8.p.1">This section defines ciphersuites for the secp256k1 elliptic curve <a href="#SEC2" class="xref">[SEC2]</a>.</p>
<p id="rfc.section.8.8.p.2">The suites secp256k1-SHA256-SSWU-RO- and secp256k1-SHA256-SSWU-NU- share the following parameters, in addition to the common parameters below.</p>
<p></p>

<ul>
<li>f: Simplified SWU for AB == 0, <a href="#simple-swu-AB0" class="xref">Section 6.6.3</a>
</li>
<li>Z: -11</li>
<li>E&#8217;: y&#8217;^2 = x&#8217;^3 + A&#8217; * x&#8217; + B&#8217;, where <ul>
<li>A&#8217;: 0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533</li>
<li>B&#8217;: 1771</li>
</ul>
</li>
<li>iso_map: the 3-isogeny map from E&#8217; to E given in <a href="#appx-iso-secp256k1" class="xref">Appendix C.1</a>
</li>
</ul>
<p id="rfc.section.8.8.p.4">The suites secp256k1-SHA256-SVDW-RO- and secp256k1-SHA256-SVDW-NU- share the following parameters, in addition to the common parameters below.</p>
<p></p>

<ul>
<li>f: Shallue-van de Woestijne method, <a href="#svdw" class="xref">Section 6.6.1</a>
</li>
<li>Z: 1</li>
</ul>
<p id="rfc.section.8.8.p.6">The common parameters for all of the above suites are:</p>
<p></p>

<ul>
<li>E: y^2 = x^3 + 7</li>
<li>p: 2^256 - 2^32 - 2^9 - 2^8 - 2^7 - 2^6 - 2^4 - 1</li>
<li>m: 1</li>
<li>sgn0: sgn0_le (<a href="#sgn0-le" class="xref">Section 4.1.2</a>)</li>
<li>H: SHA-256</li>
<li>L: 48</li>
<li>h_eff: 1</li>
</ul>
<p id="rfc.section.8.8.p.8">An optimized example implementation of the Simplified SWU mapping to the curve E&#8217; isogenous to secp256k1 is given in <a href="#sswu-map-to-3mod4" class="xref">Appendix D.2</a>.</p>
<h1 id="rfc.section.8.9">
<a href="#rfc.section.8.9">8.9.</a> <a href="#suites-bls12381" id="suites-bls12381">Suites for BLS12-381</a>
</h1>
<p id="rfc.section.8.9.p.1">This section defines ciphersuites for groups G1 and G2 of the BLS12-381 elliptic curve <a href="#draft-yonezawa-pfc-01" class="xref">[draft-yonezawa-pfc-01]</a>.</p>
<h1 id="rfc.section.8.9.1">
<a href="#rfc.section.8.9.1">8.9.1.</a> <a href="#suites-bls12381-g1" id="suites-bls12381-g1">BLS12-381 G1</a>
</h1>
<p id="rfc.section.8.9.1.p.1">The suites BLS12381G1-SHA256-SSWU-RO- and BLS12381G1-SHA256-SSWU-NU- share the following parameters, in addition to the common parameters below.</p>
<p></p>

<ul>
<li>f: Simplified SWU for AB == 0, <a href="#simple-swu-AB0" class="xref">Section 6.6.3</a>
</li>
<li>Z: 11</li>
<li>E&#8217;: y&#8217;^2 = x&#8217;^3 + A&#8217; * x&#8217; + B&#8217;, where <ul>
<li>A&#8217; = 0x144698a3b8e9433d693a02c96d4982b0ea985383ee66a8d8e8981aefd881ac98936f8da0e0f97f5cf428082d584c1d</li>
<li>B&#8217; = 0x12e2908d11688030018b12e8753eee3b2016c1f0f24f4070a0b9c14fcef35ef55a23215a316ceaa5d1cc48e98e172be0</li>
</ul>
</li>
<li>iso_map: the 11-isogeny map from E&#8217; to E given in <a href="#appx-iso-bls12381-g1" class="xref">Appendix C.2</a>
</li>
</ul>
<p id="rfc.section.8.9.1.p.3">The suites BLS12381G1-SHA256-SVDW-RO- and BLS12381G1-SHA256-SVDW-NU- share the following parameters, in addition to the common parameters below.</p>
<p></p>

<ul>
<li>f: Shallue-van de Woestijne method, <a href="#svdw" class="xref">Section 6.6.1</a>
</li>
<li>Z: -3</li>
</ul>
<p id="rfc.section.8.9.1.p.5">The common parameters for the above suites are:</p>
<p></p>

<ul>
<li>E: y^2 = x^3 + 4</li>
<li>p: 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab</li>
<li>m: 1</li>
<li>sgn0: sgn0_be (<a href="#sgn0-be" class="xref">Section 4.1.1</a>)</li>
<li>H: SHA-256</li>
<li>L: 64</li>
<li>h_eff: 0xd201000000010001</li>
</ul>
<p id="rfc.section.8.9.1.p.7">Note that this h_eff value is chosen for compatibility with the fast cofactor clearing method described by Scott (<a href="#WB19" class="xref">[WB19]</a> Section 5).</p>
<p id="rfc.section.8.9.1.p.8">An optimized example implementation of the Simplified SWU mapping to the curve E&#8217; isogenous to BLS12-381 G1 is given in <a href="#sswu-map-to-3mod4" class="xref">Appendix D.2</a>.</p>
<h1 id="rfc.section.8.9.2">
<a href="#rfc.section.8.9.2">8.9.2.</a> <a href="#suites-bls12381-g2" id="suites-bls12381-g2">BLS12-381 G2</a>
</h1>
<p id="rfc.section.8.9.2.p.1">Group G2 of BLS12-381 is defined over a field F = GF(p^m) defined as:</p>
<p></p>

<ul>
<li>p: 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab</li>
<li>m: 2</li>
<li>(1, I) is the basis for F, where I^2 + 1 == 0 in F</li>
</ul>
<p id="rfc.section.8.9.2.p.3">The suites BLS12381G2-SHA256-SSWU-RO- and BLS12381G2-SHA256-SSWU-NU- share the following parameters, in addition to the common parameters below.</p>
<p></p>

<ul>
<li>f: Simplified SWU for AB == 0, <a href="#simple-swu-AB0" class="xref">Section 6.6.3</a>
</li>
<li>Z: -(2 + I)</li>
<li>E&#8217;: y&#8217;^2 = x&#8217;^3 + A&#8217; * x&#8217; + B&#8217;, where <ul>
<li>A&#8217; = 240 * I</li>
<li>B&#8217; = 1012 * (1 + I)</li>
</ul>
</li>
<li>iso_map: the isogeny map from E&#8217; to E given in <a href="#appx-iso-bls12381-g2" class="xref">Appendix C.3</a>
</li>
</ul>
<p id="rfc.section.8.9.2.p.5">The suites BLS12381G2-SHA256-SVDW-RO- and BLS12381G2-SHA256-SVDW-NU- share the following parameters, in addition to the common parameters below.</p>
<p></p>

<ul>
<li>f: Shallue-van de Woestijne method, <a href="#svdw" class="xref">Section 6.6.1</a>
</li>
<li>Z: I</li>
</ul>
<p id="rfc.section.8.9.2.p.7">The common parameters for the above suites are:</p>
<p></p>

<ul>
<li>E: y^2 = x^3 + 4 * (1 + I)</li>
<li>p, m, F: defined above</li>
<li>sgn0: sgn0_be (<a href="#sgn0-be" class="xref">Section 4.1.1</a>)</li>
<li>H: SHA-256</li>
<li>L: 64</li>
<li>h_eff: 0xbc69f08f2ee75b3584c6a0ea91b352888e2a8e9145ad7689986ff031508ffe1329c2f178731db956d82bf015d1212b02ec0ec69d7477c1ae954cbc06689f6a359894c0adebbf6b4e8020005aaa95551</li>
</ul>
<p id="rfc.section.8.9.2.p.9">Note that this h_eff value is chosen for compatibility with the fast cofactor clearing method described by Budroni and Pintore (<a href="#BP18" class="xref">[BP18]</a>, Section 4.1).</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a>
</h1>
<p id="rfc.section.9.p.1">This document has no IANA actions.</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a>
</h1>
<p id="rfc.section.10.p.1">When constant-time implementations are required, all basic operations and utility functions must be implemented in constant time, as discussed in <a href="#utility" class="xref">Section 4</a>.</p>
<p id="rfc.section.10.p.2">Each encoding function accepts arbitrary input and maps it to a pseudorandom point on the curve.  Directly evaluating the mappings of <a href="#mappings" class="xref">Section 6</a> produces an output that is distinguishable from random.  <a href="#roadmap" class="xref">Section 3</a> shows how to use these mappings to construct a function approximating a random oracle.</p>
<p><a href="#domain-separation" class="xref">Section 3.1</a> describes considerations related to domain separation for random oracle encodings.</p>
<p><a href="#hashtobase" class="xref">Section 5</a> describes considerations for uniformly hashing to field elements.</p>
<p id="rfc.section.10.p.5">When the hash_to_curve function (<a href="#roadmap" class="xref">Section 3</a>) is instantiated with hash_to_base (<a href="#hashtobase" class="xref">Section 5</a>), the resulting function is indifferentiable from a random oracle.  In most cases such a function can be safely used in protocols whose security analysis assumes a random oracle that outputs points on an elliptic curve.  As Ristenpart et al. discuss in <a href="#RSS11" class="xref">[RSS11]</a>, however, not all security proofs that rely on random oracles continue to hold when those oracles are replaced by indifferentiable functionalities.  This limitation should be considered when analyzing the security of protocols relying on the hash_to_curve function.</p>
<p id="rfc.section.10.p.6">When hashing passwords using any function described in this document, an adversary who learns the output of the hash function (or potentially any intermediate value, e.g., the output of hash_to_base) may be able to carry out a dictionary attack.  To mitigate such attacks, it is recommended to first execute a more costly key derivation function (e.g., PBKDF2 <a href="#RFC2898" class="xref">[RFC2898]</a> or scrypt <a href="#RFC7914" class="xref">[RFC7914]</a>) on the password, then hash the output of that function to the target elliptic curve.  For collision resistance, the hash underlying the key derivation function should be chosen according to the guidelines listed in <a href="#hashtobase-sec" class="xref">Section 5.1</a>.</p>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> <a href="#acknowledgements" id="acknowledgements">Acknowledgements</a>
</h1>
<p id="rfc.section.11.p.1">The authors would like to thank Adam Langley for his detailed writeup of Elligator 2 with Curve25519 <a href="#L13" class="xref">[L13]</a>; Christopher Patton and Benjamin Lipp for educational discussions; and Sean Devlin, Justin Drake, Dan Harkins, Thomas Icart, Leonid Reyzin, Michael Scott, and Mathy Vanhoef for helpful feedback.</p>
<h1 id="rfc.section.12">
<a href="#rfc.section.12">12.</a> <a href="#contributors" id="contributors">Contributors</a>
</h1>
<p></p>

<ul>
<li>Sharon Goldberg <br> Boston University <br> goldbe@cs.bu.edu</li>
<li>Ela Lee <br> Royal Holloway, University of London <br> Ela.Lee.2010@live.rhul.ac.uk</li>
</ul>
<h1 id="rfc.references">
<a href="#rfc.references">13.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">13.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2898">[RFC2898]</b></td>
<td class="top">
<a>Kaliski, B.</a>, "<a href="https://tools.ietf.org/html/rfc2898">PKCS #5: Password-Based Cryptography Specification Version 2.0</a>", RFC 2898, DOI 10.17487/RFC2898, September 2000.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5869">[RFC5869]</b></td>
<td class="top">
<a>Krawczyk, H.</a> and <a>P. Eronen</a>, "<a href="https://tools.ietf.org/html/rfc5869">HMAC-based Extract-and-Expand Key Derivation Function (HKDF)</a>", RFC 5869, DOI 10.17487/RFC5869, May 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7748">[RFC7748]</b></td>
<td class="top">
<a>Langley, A.</a>, <a>Hamburg, M.</a> and <a>S. Turner</a>, "<a href="https://tools.ietf.org/html/rfc7748">Elliptic Curves for Security</a>", RFC 7748, DOI 10.17487/RFC7748, January 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7914">[RFC7914]</b></td>
<td class="top">
<a>Percival, C.</a> and <a>S. Josefsson</a>, "<a href="https://tools.ietf.org/html/rfc7914">The scrypt Password-Based Key Derivation Function</a>", RFC 7914, DOI 10.17487/RFC7914, August 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8017">[RFC8017]</b></td>
<td class="top">
<a>Moriarty, K.</a>, <a>Kaliski, B.</a>, <a>Jonsson, J.</a> and <a>A. Rusch</a>, "<a href="https://tools.ietf.org/html/rfc8017">PKCS #1: RSA Cryptography Specifications Version 2.2</a>", RFC 8017, DOI 10.17487/RFC8017, November 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8032">[RFC8032]</b></td>
<td class="top">
<a>Josefsson, S.</a> and <a>I. Liusvaara</a>, "<a href="https://tools.ietf.org/html/rfc8032">Edwards-Curve Digital Signature Algorithm (EdDSA)</a>", RFC 8032, DOI 10.17487/RFC8032, January 2017.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">13.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="AFQTZ14">[AFQTZ14]</b></td>
<td class="top">
<a title="Institute of Computing, University of Campinas">Aranha, D.</a>, <a title="Universite de Rennes 1 and Institut Universitaire de France">Fouque, P.</a>, <a title="ENS Rennes">Qian, C.</a>, <a title="NTT Secure Platform Laboratories">Tibouchi, M.</a> and <a title="INRIA">J. Zapalowicz</a>, "<a href="https://doi.org/10.1007/978-3-319-13051-4_2">Binary Elligator squared</a>", In Selected Areas in Cryptography - SAC 2014, pages 20-37, DOI 10.1007/978-3-319-13051-4_2, 2014.</td>
</tr>
<tr>
<td class="reference"><b id="AR13">[AR13]</b></td>
<td class="top">
<a title="ISFA, Universite Claude Bernard Lyon 1, Villeurbanne, France">Adj, G.</a> and <a title="CINVESTAV-IPN, San Pedro Zacatenco, Mexico City, Mexico.">F. Rodriguez-Henriquez</a>, "<a href="https://doi.org/10.1109/TC.2013.145">Square Root Computation over Even Extension Fields</a>", In IEEE Transactions on Computers. vol 63 issue 11, pages 2829-2841, DOI 10.1109/TC.2013.145, November 2014.</td>
</tr>
<tr>
<td class="reference"><b id="BBJLP08">[BBJLP08]</b></td>
<td class="top">
<a title="Department of Computer Science, University of Illinois at Chicago, USA">Bernstein, D.</a>, <a title="Department of Mathematics and Computer Science, Technische Universiteit Eindhoven, The Netherlands">Birkner, P.</a>, <a title="Thomson R&amp;D France">Joye, M.</a>, <a title="Department of Mathematics and Computer Science, Technische Universiteit Eindhoven, The Netherlands">Lange, T.</a> and <a title="Department of Mathematics and Computer Science, Technische Universiteit Eindhoven, The Netherlands">C. Peters</a>, "<a href="https://doi.org/10.1007/978-3-540-68164-9_26">Twisted Edwards curves</a>", In AFRICACRYPT 2008, pages 389-405, DOI 10.1007/978-3-540-68164-9_26, 2008.</td>
</tr>
<tr>
<td class="reference"><b id="BCIMRT10">[BCIMRT10]</b></td>
<td class="top">
<a title="Ingenico">Brier, E.</a>, <a title="Universite du Luxembourg">Coron, J.</a>, <a title="Universite du Luxembourg">Icart, T.</a>, <a title="TELECOM-ParisTech">Madore, D.</a>, <a title="TELECOM-ParisTech">Randriam, H.</a> and <a title="Universite du Luxembourg, Ecole normale superieure">M. Tibouchi</a>, "<a href="https://doi.org/10.1007/978-3-642-14623-7_13">Efficient Indifferentiable Hashing into Ordinary Elliptic Curves</a>", In Advances in Cryptology - CRYPTO 2010, pages 237-254, DOI 10.1007/978-3-642-14623-7_13, 2010.</td>
</tr>
<tr>
<td class="reference"><b id="BF01">[BF01]</b></td>
<td class="top">
<a title="Stanford University">Boneh, D.</a> and <a title="UC Davis">M. Franklin</a>, "<a href="https://doi.org/10.1007/3-540-44647-8_13">Identity-based encryption from the Weil pairing</a>", In Advances in Cryptology - CRYPTO 2001, pages 213-229, DOI 10.1007/3-540-44647-8_13, August 2001.</td>
</tr>
<tr>
<td class="reference"><b id="BHKL13">[BHKL13]</b></td>
<td class="top">
<a title="Department of Computer Science, University of Illinois at Chicago, USA">Bernstein, D.</a>, <a title="Cryptography Research, a division of Rambus, USA">Hamburg, M.</a>, <a title="Privacy &amp; Identity lab, Institute for Computing and Information Sciences, Radboud University Nijmegen, The Netherlands">Krasnova, A.</a> and <a title="Department of Mathematics and Computer Science, Technische Universiteit Eindhoven, The Netherlands">T. Lange</a>, "<a href="https://doi.org/10.1145/2508859.2516734">Elligator: elliptic-curve points indistinguishable from uniform random strings</a>", In Proceedings of the 2013 ACM SIGSAC conference on computer and communications security., pages 967-980, DOI 10.1145/2508859.2516734, November 2013.</td>
</tr>
<tr>
<td class="reference"><b id="BLAKE2X">[BLAKE2X]</b></td>
<td class="top">
<a>Aumasson, J-P.</a>, <a>Neves, S.</a>, <a>Wilcox-O'Hearn, Z.</a> and <a>C. Winnerlein</a>, "<a href="https://blake2.net/blake2x.pdf">BLAKE2X</a>", December 2016.</td>
</tr>
<tr>
<td class="reference"><b id="BLMP19">[BLMP19]</b></td>
<td class="top">
<a title="Department of Computer Science, University of Illinois at Chicago, USA">Bernstein, D.</a>, <a title="Department of Mathematics and Computer Science, Technische Universiteit Eindhoven, The Netherlands">Lange, T.</a>, <a title="Department of Mathematics and Computer Science, Technische Universiteit Eindhoven, The Netherlands">Martindale, C.</a> and <a title="Department of Mathematics and Computer Science, Technische Universiteit Eindhoven, The Netherlands">L. Panny</a>, "<a href="https://doi.org/10.1007/978-3-030-17656-3">Quantum circuits for the CSIDH: optimizing quantum evaluation of isogenies</a>", In Advances in Cryptology - EUROCRYPT 2019, DOI 10.1007/978-3-030-17656-3, 2019.</td>
</tr>
<tr>
<td class="reference"><b id="BLS01">[BLS01]</b></td>
<td class="top">
<a title="Stanford University">Boneh, D.</a>, <a title="Stanford University">Lynn, B.</a> and <a title="Stanford University">H. Shacham</a>, "<a href="https://doi.org/10.1007/s00145-004-0314-9">Short signatures from the Weil pairing</a>", In Journal of Cryptology, vol 17, pages 297-319, DOI 10.1007/s00145-004-0314-9, July 2004.</td>
</tr>
<tr>
<td class="reference"><b id="BLS03">[BLS03]</b></td>
<td class="top">
<a title="Universidade de Sao Paulo, Brazil">Barreto, P.</a>, <a title="Stanford University">Lynn, B.</a> and <a title="Dublin City University, Ireland">M. Scott</a>, "<a href="https://doi.org/10.1007/3-540-36413-7_19">Constructing Elliptic Curves with Prescribed Embedding Degrees</a>", In Security in Communication Networks, pages 257-267, DOI 10.1007/3-540-36413-7_19, 2003.</td>
</tr>
<tr>
<td class="reference"><b id="BMP00">[BMP00]</b></td>
<td class="top">
<a title="MIT Laboratory for Computer Science">Boyko, V.</a>, <a title="Bell Laboratories, Lucent Technologies">MacKenzie, P.</a> and <a title="Bell Laboratories, Lucent Technologies">S. Patel</a>, "<a href="https://doi.org/10.1007/3-540-45539-6_12">Provably secure password-authenticated key exchange using Diffie-Hellman</a>", In Advances in Cryptology - EUROCRYPT 2000, pages 156-171, DOI 10.1007/3-540-45539-6_12, May 2000.</td>
</tr>
<tr>
<td class="reference"><b id="BN05">[BN05]</b></td>
<td class="top">
<a title="Escola Politecnica, Universidade de Sao Paulo, Sao Paulo, Brazil">Barreto, P.</a> and <a title="Lehrstuhl fur Theoretische Informationstechnik, Rheinisch-Westfalische Technische Hochschule Aachen, Aachen, Germany">M. Naehrig</a>, "<a href="https://doi.org/10.1007/11693383_22">Pairing-Friendly Elliptic Curves of Prime Order</a>", In Selected Areas in Cryptography 2005, pages 319-331, DOI 10.1007/11693383_22, 2006.</td>
</tr>
<tr>
<td class="reference"><b id="BP18">[BP18]</b></td>
<td class="top">
<a title="University of Bergen, Norway and MIRACL Labs, London, England">Budroni, A.</a> and <a title="University of Trento, Italy">F. Pintore</a>, "<a href="https://doi.org/10.1145/3313880.3313884">Hashing to G2 on BLS pairing-friendly curves</a>", In ACM Communications in Computer Algebra, pages 63-66, DOI 10.1145/3313880.3313884, September 2018.</td>
</tr>
<tr>
<td class="reference"><b id="C93">[C93]</b></td>
<td class="top">
<a>Cohen, H.</a>, "<a href="https://doi.org/10.1007/978-3-662-02945-9">A Course in Computational Algebraic Number Theory</a>", publisher Springer-Verlag, ISBN 9783642081422, 1993.</td>
</tr>
<tr>
<td class="reference"><b id="CFADLNV05">[CFADLNV05]</b></td>
<td class="top">
<a>Cohen, H.</a>, <a>Frey, G.</a>, <a>Avanzi, R.</a>, <a>Doche, C.</a>, <a>Lange, T.</a>, <a>Nguyen, K.</a> and <a>F. Vercauteren</a>, "<a href="https://www.crcpress.com/9781584885184">Handbook of Elliptic and Hyperelliptic Curve Cryptography</a>", publisher Chapman and Hall / CRC, ISBN 9781584885184, 2005.</td>
</tr>
<tr>
<td class="reference"><b id="CK11">[CK11]</b></td>
<td class="top">
<a title="Universite Bordeaux">Couveignes, J.</a> and <a title="Universite de Rennes">J. Kammerer</a>, "<a href="https://doi.org/10.1016/j.jsc.2011.11.003">The geometry of flex tangents to a cubic curve and its parameterizations</a>", In Journal of Symbolic Computation, vol 47 issue 3, pages 266-281, DOI 10.1016/j.jsc.2011.11.003, 2012.</td>
</tr>
<tr>
<td class="reference"><b id="draft-yonezawa-pfc-01">[draft-yonezawa-pfc-01]</b></td>
<td class="top">
<a title="Lepidum">Yonezawa, S.</a>, <a title="NTT TechnoCross">Chikara, S.</a>, <a title="NTT">Kobayashi, T.</a> and <a title="NTT">T. Saito</a>, "<a href="https://datatracker.ietf.org/doc/draft-yonezawa-pairing-friendly-curves/">Pairing-friendly Curves</a>", March 2019.</td>
</tr>
<tr>
<td class="reference"><b id="DRST12">[DRST12]</b></td>
<td class="top">
<a title="New York University">Dodis, Y.</a>, <a title="University of Wisconsin-Madison">Ristenpart, T.</a>, <a title="Tsinghua University">Steinberger, J.</a> and <a title="Massachusetts Institute of Technology">S. Tessaro</a>, "<a href="https://doi.org/10.1007/978-3-642-32009-5_21">To hash or not to hash again? (In)differentiability results for H^2 and HMAC</a>", In Advances in Cryptology - CRYPTO 2012, pages 348-366, DOI 10.1007/978-3-642-32009-5_21, August 2012.</td>
</tr>
<tr>
<td class="reference"><b id="F11">[F11]</b></td>
<td class="top">
<a title="Macquarie Universit">Farashahi, R.</a>, "<a href="https://doi.org/10.1007/978-3-642-21969-6_17">Hashing into Hessian curves</a>", In AFRICACRYPT 2011, pages 278-289, DOI 10.1007/978-3-642-21969-6_17, 2011.</td>
</tr>
<tr>
<td class="reference"><b id="FFSTV13">[FFSTV13]</b></td>
<td class="top">
<a title="Macquarie Universit">Farashahi, R.</a>, <a title="Ecole normale superieure">Fouque, P.</a>, <a title="Macquarie Universit">Shparlinski, I.</a>, <a title="Ecole normale superieure">Tibouch, M.</a> and <a title="University of Texas">J. Voloch</a>, "<a href="https://doi.org/10.1090/S0025-5718-2012-02606-8">Indifferentiable deterministic hashing to elliptic and hyperelliptic curves</a>", In Math. Comp. vol 82, pages 491-512, DOI 10.1090/S0025-5718-2012-02606-8, 2013.</td>
</tr>
<tr>
<td class="reference"><b id="FIPS180-4">[FIPS180-4]</b></td>
<td class="top">
<a>National Institute of Standards and Technology (NIST)</a>, "<a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf">Secure Hash Standard (SHS)</a>", August 2015.</td>
</tr>
<tr>
<td class="reference"><b id="FIPS186-4">[FIPS186-4]</b></td>
<td class="top">
<a>National Institute of Standards and Technology (NIST)</a>, "<a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf">FIPS Publication 186-4: Digital Signature Standard</a>", July 2013.</td>
</tr>
<tr>
<td class="reference"><b id="FIPS202">[FIPS202]</b></td>
<td class="top">
<a>National Institute of Standards and Technology (NIST)</a>, "<a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf">SHA-3 Standard: Permutation-Based Hash and Extendable-Output Functions</a>", August 2015.</td>
</tr>
<tr>
<td class="reference"><b id="FJT13">[FJT13]</b></td>
<td class="top">
<a title="Ecole Normale Superieure and INRIA Rennes">Fouque, P.</a>, <a title="Sorbonne Universite">Joux, A.</a> and <a title="NTT Secure Platform Laboratories">M. Tibouchi</a>, "<a href="https://doi.org/10.1007/978-3-642-39059-3_14">Injective encodings to elliptic curves</a>", In ACISP 2013, pages 203-218, DOI 10.1007/978-3-642-39059-3_14, 2013.</td>
</tr>
<tr>
<td class="reference"><b id="FKR11">[FKR11]</b></td>
<td class="top">
<a title="Computer Science Department, CINVESTAV-IPN. Mexico">Fuentes-Castaneda, L.</a>, <a title="Dept. Combinatorics &amp; Optimization, University of Waterloo, Canada">Knapp, E.</a> and <a title="Computer Science Department, CINVESTAV-IPN. Mexico">F. Rodriguez-Henriquez</a>, "<a href="https://doi.org/10.1007/978-3-642-28496-0_25">Fast Hashing to G2 on Pairing-Friendly Curves</a>", In Selected Areas in Cryptography, pages 412-430, DOI 10.1007/978-3-642-28496-0_25, 2011.</td>
</tr>
<tr>
<td class="reference"><b id="FSV09">[FSV09]</b></td>
<td class="top">
<a title="Macquarie Universit">Farashahi, R.</a>, <a title="Macquarie Universit">Shparlinski, I.</a> and <a title="University of Texas">J. Voloch</a>, "<a href="https://doi.org/10.1515/JMC.2009.022">On hashing into elliptic curves</a>", In Journal of Mathematical Cryptology, vol 3 no 4, pages 353-360, DOI 10.1515/JMC.2009.022, 2009.</td>
</tr>
<tr>
<td class="reference"><b id="FT10">[FT10]</b></td>
<td class="top">
<a title="Ecole Normale Superieure and INRIA Rennes">Fouque, P.</a> and <a title="NTT Secure Platform Laboratories">M. Tibouchi</a>, "<a href="https://doi.org/10.1007/978-3-642-14712-8_5">Estimating the size of the image of deterministic hash functions to elliptic curves.</a>", In Progress in Cryptology - LATINCRYPT 2010, pages 81-91, DOI 10.1007/978-3-642-14712-8_5, 2010.</td>
</tr>
<tr>
<td class="reference"><b id="FT12">[FT12]</b></td>
<td class="top">
<a title="Ecole Normale Superieure and INRIA Rennes">Fouque, P.</a> and <a title="NTT Secure Platform Laboratories">M. Tibouchi</a>, "<a href="https://doi.org/10.1007/978-3-642-33481-8_1">Indifferentiable Hashing to Barreto-Naehrig Curves</a>", In Progress in Cryptology - LATINCRYPT 2012, pages 1-7, DOI 10.1007/978-3-642-33481-8_1, 2012.</td>
</tr>
<tr>
<td class="reference"><b id="hash2curve-repo">[hash2curve-repo]</b></td>
<td class="top">"<a href="https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve">Hashing to Elliptic Curves - GitHub repository</a>", 2019.</td>
</tr>
<tr>
<td class="reference"><b id="Icart09">[Icart09]</b></td>
<td class="top">
<a title="Sagem Securite and Universite du Luxembourg">Icart, T.</a>, "<a href="https://doi.org/10.1007/978-3-642-03356-8_18">How to Hash into Elliptic Curves</a>", In Advances in Cryptology - CRYPTO 2009, pages 303-316, DOI 10.1007/978-3-642-03356-8_18, 2009.</td>
</tr>
<tr>
<td class="reference"><b id="J96">[J96]</b></td>
<td class="top">
<a title="Integrity Sciences, Inc. Westboro, MA.">Jablon, D.</a>, "<a href="https://doi.org/10.1145/242896.242897">Strong password-only authenticated key exchange</a>", In SIGCOMM Computer Communication Review, vol 26 issue 5, pages 5-26, DOI 10.1145/242896.242897, 1996.</td>
</tr>
<tr>
<td class="reference"><b id="jubjub-fq">[jubjub-fq]</b></td>
<td class="top">"<a href="https://github.com/zkcrypto/jubjub/blob/master/src/fq.rs">zkcrypto/jubjub - fq.rs</a>", 2019.</td>
</tr>
<tr>
<td class="reference"><b id="KLR10">[KLR10]</b></td>
<td class="top">
<a title="Universite de Rennes">Kammerer, J.</a>, <a title="Universite de Rennes">Lercier, R.</a> and <a title="Universite Pierre et Marie Curie">G. Renault</a>, "<a href="https://doi.org/10.1007/978-3-642-17455-1_18">Encoding points on hyperelliptic curves over finite fields in deterministic polynomial time</a>", In PAIRING 2010, pages 278-297, DOI 10.1007/978-3-642-17455-1_18, 2010.</td>
</tr>
<tr>
<td class="reference"><b id="L13">[L13]</b></td>
<td class="top">
<a>Langley, A.</a>, "<a href="https://www.imperialviolet.org/2013/12/25/elligator.html">Implementing Elligator for Curve25519</a>", 2013.</td>
</tr>
<tr>
<td class="reference"><b id="LBB19">[LBB19]</b></td>
<td class="top">
<a title="INRIA Paris">Lipp, B.</a>, <a title="INRIA Paris">Blanchet, B.</a> and <a title="INRIA Paris">K. Bhargavan</a>, "<a href="https://hal.inria.fr/hal-02100345/">A Mechanised Proof of the WireGuard Virtual Private Network Protocol</a>", In INRIA Research Report No. 9269, April 2019.</td>
</tr>
<tr>
<td class="reference"><b id="p1363a">[p1363a]</b></td>
<td class="top">
<a>IEEE Computer Society</a>, "<a href="https://standards.ieee.org/standard/1363a-2004.html">IEEE Standard Specifications for Public-Key Cryptography---Amendment 1: Additional Techniques</a>", March 2004.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7693">[RFC7693]</b></td>
<td class="top">
<a>Saarinen, M-J.</a> and <a>J-P. Aumasson</a>, "<a href="https://tools.ietf.org/html/rfc7693">The BLAKE2 Cryptographic Hash and Message Authentication Code (MAC)</a>", RFC 7693, DOI 10.17487/RFC7693, November 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RSS11">[RSS11]</b></td>
<td class="top">
<a title="University of Wisconsin-Madison">Ristenpart, T.</a>, <a title="UC San Diego">Shacham, H.</a> and <a title="Portland State University">T. Shrimpton</a>, "<a href="https://doi.org/10.1007/978-3-642-20465-4_27">Careful with Composition: Limitations of the Indifferentiability Framework</a>", In Advances in Cryptology - EUROCRYPT 2011, pages 487-506, DOI 10.1007/978-3-642-20465-4_27, May 2011.</td>
</tr>
<tr>
<td class="reference"><b id="S05">[S05]</b></td>
<td class="top">
<a title="Department of Mathematics, University of Warsaw">Skalba, M.</a>, "<a href="https://doi.org/10.4064/aa117-3-7">Points on elliptic curves over finite fields</a>", In Acta Arithmetica, vol 117 no 3, pages 293-301, DOI 10.4064/aa117-3-7, 2005.</td>
</tr>
<tr>
<td class="reference"><b id="S85">[S85]</b></td>
<td class="top">
<a>Schoof, R.</a>, "<a href="https://doi.org/10.1090/S0025-5718-1985-0777280-6">Elliptic Curves Over Finite Fields and the Computation of Square Roots mod p</a>", In Mathematics of Computation vol 44 issue 170, pages 483-494, DOI 10.1090/S0025-5718-1985-0777280-6, April 1985.</td>
</tr>
<tr>
<td class="reference"><b id="SAGE">[SAGE]</b></td>
<td class="top">
<a>The Sage Developers</a>, "<a href="https://www.sagemath.org">SageMath, the Sage Mathematics Software System</a>", 2019.</td>
</tr>
<tr>
<td class="reference"><b id="SBCDK09">[SBCDK09]</b></td>
<td class="top">
<a title="School of Computing Dublin City University, Ballymun. Dublin, Ireland.">Scott, M.</a>, <a title="School of Computing Dublin City University, Ballymun. Dublin, Ireland.">Benger, N.</a>, <a title="School of Computing Dublin City University, Ballymun. Dublin, Ireland.">Charlemagne, M.</a>, <a title="School of Computing Dublin City University, Ballymun. Dublin, Ireland.">Dominguez Perez, L.</a> and <a title="School of Computing Dublin City University, Ballymun. Dublin, Ireland.">E. Kachisa</a>, "<a href="https://doi.org/10.1007/978-3-642-03298-1_8">Fast Hashing to G2 on Pairing-Friendly Curves</a>", In Pairing-Based Cryptography - Pairing 2009, pages 102-113, DOI 10.1007/978-3-642-03298-1_8, 2009.</td>
</tr>
<tr>
<td class="reference"><b id="SEC1">[SEC1]</b></td>
<td class="top">
<a>Standards for Efficient Cryptography Group (SECG)</a>, "<a href="http://www.secg.org/sec1-v2.pdf">SEC 1: Elliptic Curve Cryptography</a>", May 2009.</td>
</tr>
<tr>
<td class="reference"><b id="SEC2">[SEC2]</b></td>
<td class="top">
<a>Standards for Efficient Cryptography Group (SECG)</a>, "<a href="http://www.secg.org/sec2-v2.pdf">SEC 2: Recommended Elliptic Curve Domain Parameters</a>", January 2010.</td>
</tr>
<tr>
<td class="reference"><b id="SP.800-185">[SP.800-185]</b></td>
<td class="top">
<a title="NIST Computer Security Division">Kelsey, J.</a>, <a title="NIST Computer Security Division">Chang, S.</a> and <a title="NIST Computer Security Division">R. Perlner</a>, "<a href="https://doi.org/10.6028/NIST.SP.800-185">SHA-3 Derived Functions: cSHAKE, KMAC, TupleHash and ParallelHash</a>", December 2016.</td>
</tr>
<tr>
<td class="reference"><b id="SS04">[SS04]</b></td>
<td class="top">
<a title="Department of Mathemetics, University of Warsaw">Schinzel, A.</a> and <a title="Department of Mathematics, University of Warsaw">M. Skalba</a>, "<a href="https://doi.org/10.4064/ba52-3-1">On equations y^2 = x^n + k in a finite field.</a>", In Bulletin Polish Acad. Sci. Math. vol 52, no 3, pages 223-226, DOI 10.4064/ba52-3-1, 2004.</td>
</tr>
<tr>
<td class="reference"><b id="SW06">[SW06]</b></td>
<td class="top">
<a title="Mathematics Department, University of Wisconsin-Madison. Madison, USA.">Shallue, A.</a> and <a title="Mathematisch Instituut, Universiteit Leiden. Leiden, The Netherlands.">C. van de Woestijne</a>, "<a href="https://doi.org/10.1007/11792086_36">Construction of rational points on elliptic curves over finite fields</a>", In Algorithmic Number Theory. ANTS 2006., pages 510-524, DOI 10.1007/11792086_36, 2006.</td>
</tr>
<tr>
<td class="reference"><b id="T14">[T14]</b></td>
<td class="top">
<a title="NTT Secure Platform Laboratories">Tibouchi, M.</a>, "<a href="https://doi.org/10.1007/978-3-662-45472-5_10">Elligator squared: Uniform points on elliptic curves of prime order as uniform random strings</a>", In Financial Cryptography and Data Security - FC 2014, pages 139-156, DOI 10.1007/978-3-662-45472-5_10, 2014.</td>
</tr>
<tr>
<td class="reference"><b id="TK17">[TK17]</b></td>
<td class="top">
<a title="NTT Secure Platform Laboratories">Tibouchi, M.</a> and <a title="NTT Secure Platform Laboratories">T. Kim</a>, "<a href="https://doi.org/10.1007/s10623-016-0288-2">Improved elliptic curve hashing and point representation</a>", In Designs, Codes, and Cryptography, vol 82, pages 161-177, DOI 10.1007/s10623-016-0288-2, 2017.</td>
</tr>
<tr>
<td class="reference"><b id="U07">[U07]</b></td>
<td class="top">
<a title="Institute of Mathematics, Jagiellonian University. Poland">Ulas, M.</a>, "<a href="https://doi.org/10.4064/ba55-2-1">Rational points on certain hyperelliptic curves over finite fields</a>", In Bulletin Polish Acad. Sci. Math. vol 55, no 2, pages 97-104, DOI 10.4064/ba55-2-1, 2007.</td>
</tr>
<tr>
<td class="reference"><b id="W08">[W08]</b></td>
<td class="top">
<a>Washington, L.</a>, "<a href="https://www.crcpress.com/9781420071467">Elliptic curves: Number theory and cryptography</a>", edition 2nd, publisher Chapman and Hall / CRC, ISBN 9781420071467, 2008.</td>
</tr>
<tr>
<td class="reference"><b id="W19">[W19]</b></td>
<td class="top">
<a title="Stanford University">Wahby, R.</a>, "<a href="https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/doc/svdw_params.pdf">An explicit, generic parameterization for the Shallue--van de Woestijne map</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="WB19">[WB19]</b></td>
<td class="top">
<a title="Stanford University">Wahby, R.</a> and <a title="Stanford University">D. Boneh</a>, "<a href="https://eprint.iacr.org/2019/403">Fast and simple constant-time hashing to the BLS12-381 elliptic curve</a>", In IACR Trans. CHES, volume 2019, issue 4, DOI 10.13154/tches.v2019.i4.154-179, ePrint 2019/403, August 2019.</td>
</tr>
<tr>
<td class="reference"><b id="x9.62">[x9.62]</b></td>
<td class="top">
<a>ANSI</a>, "<a>Public Key Cryptography for the Financial Services Industry: the Elliptic Curve Digital Signature Algorithm (ECDSA)</a>", ANSI X9.62-1998, September 1998.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> <a href="#related" id="related">Related Work</a>
</h1>
<p id="rfc.section.A.p.1">The problem of mapping arbitrary bit strings to elliptic curve points has been the subject of both practical and theoretical research.  This section briefly describes the background and research results that underly the recommendations in this document.  This section is provided for informational purposes only.</p>
<p id="rfc.section.A.p.2">A naive but generally insecure method of mapping a string alpha to a point on an elliptic curve E having n points is to first fix a point P that generates the elliptic curve group, and a hash function Hn from bit strings to integers less than n; then compute Hn(alpha) * P, where the * operator represents scalar multiplication. The reason this approach is insecure is that the resulting point has a known discrete log relationship to P.  Thus, except in cases where this method is specified by the protocol, it must not be used; doing so risks catastrophic security failures.</p>
<p id="rfc.section.A.p.3">Boneh et al. <a href="#BLS01" class="xref">[BLS01]</a> describe an encoding method they call MapToGroup, which works roughly as follows: first, use the input string to initialize a pseudorandom number generator, then use the generator to produce a pseudorandom value x in F.  If x is the x-coordinate of a point on the elliptic curve, output that point. Otherwise, generate a new pseudorandom value x in F and try again.  Since a random value x in F has probability about 1/2 of corresponding to a point on the curve, the expected number of tries is just two.  However, the running time of this method depends on the input string, which means that it is not safe to use in protocols sensitive to timing side channels.</p>
<p id="rfc.section.A.p.4">Schinzel and Skalba <a href="#SS04" class="xref">[SS04]</a> introduce a method of constructing elliptic curve points deterministically, for a restricted class of curves and a very small number of points.  Skalba <a href="#S05" class="xref">[S05]</a> generalizes this construction to more curves and more points on those curves.  Shallue and van de Woestijne <a href="#SW06" class="xref">[SW06]</a> further generalize and simplify Skalba&#8217;s construction, yielding concretely efficient maps to a constant fraction of the points on almost any curve.  Fouque and Tibouchi <a href="#FT12" class="xref">[FT12]</a> give a parameterization of this mapping for Barreto-Naehrig pairing-friendly curves <a href="#BN05" class="xref">[BN05]</a>.</p>
<p id="rfc.section.A.p.5">Ulas <a href="#U07" class="xref">[U07]</a> describes a simpler version of the Shallue-van de Woestijne map, and Brier et al. <a href="#BCIMRT10" class="xref">[BCIMRT10]</a> give a further simplification, which the authors call the &#8220;simplified SWU&#8221; map.  That simplified map applies only to fields of characteristic p = 3 (mod 4); Wahby and Boneh <a href="#WB19" class="xref">[WB19]</a> generalize to fields of any characteristic, and give further optimizations.</p>
<p id="rfc.section.A.p.6">Boneh and Franklin give a deterministic algorithm mapping to certain supersingular curves over fields of characteristic p = 2 (mod 3) <a href="#BF01" class="xref">[BF01]</a>.  Icart gives another deterministic algorithm which maps to any curve over a field of characteristic p = 2 (mod 3) <a href="#Icart09" class="xref">[Icart09]</a>.  Several extensions and generalizations follow this work, including <a href="#FSV09" class="xref">[FSV09]</a>, <a href="#FT10" class="xref">[FT10]</a>, <a href="#KLR10" class="xref">[KLR10]</a>, <a href="#F11" class="xref">[F11]</a>, and <a href="#CK11" class="xref">[CK11]</a>.</p>
<p id="rfc.section.A.p.7">Following the work of Farashahi <a href="#F11" class="xref">[F11]</a>, Fouque et al. <a href="#FJT13" class="xref">[FJT13]</a> describe a mapping to curves of characteristic p = 3 (mod 4) having a number of points divisible by 4.  Bernstein et al. <a href="#BHKL13" class="xref">[BHKL13]</a> optimize this mapping and describe a related mapping that they call &#8220;Elligator 2,&#8221; which applies to any curve over a field of odd characteristic having a point of order 2.  This includes Curve25519 and Curve448, both of which are CFRG-recommended curves <a href="#RFC7748" class="xref">[RFC7748]</a>.</p>
<p id="rfc.section.A.p.8">An important caveat regarding all of the above deterministic mapping functions is that none of them map to the entire curve, but rather to some fraction of the points. This means that they cannot be used directly to construct a random oracle that outputs points on the curve.</p>
<p id="rfc.section.A.p.9">Brier et al. <a href="#BCIMRT10" class="xref">[BCIMRT10]</a> give two solutions to this problem.  The first, which Brier et al. prove applies to Icart&#8217;s method, computes f(H0(msg)) + f(H1(msg)) for two distinct hash functions H0 and H1 from bit strings to F and a mapping f from F to the elliptic curve E.  The second, which applies to essentially all deterministic mappings but is more costly, computes f(H0(msg)) + H2(msg) * P, for P a generator of the elliptic curve group and H2 a hash from bit strings to integers modulo r, the order of the elliptic curve group.  Farashahi et al. <a href="#FFSTV13" class="xref">[FFSTV13]</a> improve the analysis of the first method, showing that it applies to essentially all deterministic mappings.  Tibouchi and Kim <a href="#TK17" class="xref">[TK17]</a> further refine the analysis and describe additional optimizations.</p>
<p id="rfc.section.A.p.10">Complementary to the problem of mapping from bit strings to elliptic curve points, Bernstein et al. <a href="#BHKL13" class="xref">[BHKL13]</a> study the problem of mapping from elliptic curve points to uniformly random bit strings, giving solutions for a class of curves including Montgomery and twisted Edwards curves.  Tibouchi <a href="#T14" class="xref">[T14]</a> and Aranha et al. <a href="#AFQTZ14" class="xref">[AFQTZ14]</a> generalize these results.  This document does not deal with this complementary problem.</p>
<h1 id="rfc.appendix.B">
<a href="#rfc.appendix.B">Appendix B.</a> <a href="#appx-rational-map" id="appx-rational-map">Rational maps</a>
</h1>
<p id="rfc.section.B.p.1">This section gives several useful rational maps.</p>
<h1 id="rfc.appendix.B.1">
<a href="#rfc.appendix.B.1">B.1.</a> <a href="#appx-rational-map-edw" id="appx-rational-map-edw">Twisted Edwards to Weierstrass and Montgomery curves</a>
</h1>
<p id="rfc.section.B.1.p.1">The inverse of the rational map specified in <a href="#rational-map" class="xref">Section 6.8.1</a>, i.e., the map from the point (v, w) on the twisted Edwards curve a * v^2 + w^2 = 1 + d * v^2 * w^2 to the point (x, y) on the Weierstrass curve y^2 = x^3 + A * x^2 + B * x is given by:</p>
<p></p>

<ul>
<li>A = (a + d) / 2</li>
<li>B = (a - d)^2 / 16</li>
<li>B&#8217; = 1 / sqrt(B) = 4 / (a - d)</li>
<li>x = (1 + w) / (B&#8217; * (1 - w))</li>
<li>y = (1 + w) / (B&#8217; * v * (1 - w))</li>
</ul>
<p id="rfc.section.B.1.p.3">This map is undefined when w == 1 or v == 0.  In this case, return the point (x, y) = (0, 0).</p>
<p id="rfc.section.B.1.p.4">It may also be useful to map to a Montgomery curve of the form B&#8217; * t^2 = s^3 + A&#8217; * s^2 + s.  This curve is equivalent to the twisted Edwards curve above via the following rational map (<a href="#BBJLP08" class="xref">[BBJLP08]</a>, Theorem 3.2):</p>
<p></p>

<ul>
<li>A&#8217; = 2 * (a + d) / (a - d)</li>
<li>B&#8217; = 4 / (a - d)</li>
<li>s = (1 + w) / (1 - w)</li>
<li>t = (1 + w) / (v * (1 - w))</li>
</ul>
<p id="rfc.section.B.1.p.6">whose inverse is given by:</p>
<p></p>

<ul>
<li>v = s / t</li>
<li>w = (s - 1) / (s + 1)</li>
</ul>
<p id="rfc.section.B.1.p.8">Composing the mapping immediately above with the mapping from Montgomery to Weierstrass curves in <a href="#appx-rational-map-mont" class="xref">Appendix B.2</a> yields a mapping from twisted Edwards curves to Weierstrass curves of the form required by the mappings in <a href="#weierstrass" class="xref">Section 6.6</a>.  This mapping can be used to apply the Shallue-van de Woestijne method (<a href="#svdw" class="xref">Section 6.6.1</a>) to twisted Edwards curves.</p>
<h1 id="rfc.appendix.B.2">
<a href="#rfc.appendix.B.2">B.2.</a> <a href="#appx-rational-map-mont" id="appx-rational-map-mont">Montgomery to Weierstrass curves</a>
</h1>
<p id="rfc.section.B.2.p.1">The rational map from the point (s, t) on the Montgomery curve B&#8217; * t^2 = s^3 + A&#8217; * s^2 + s to the point (x, y) on the equivalent Weierstrass curve y^2 = x^3 + C * x + D is given by:</p>
<p></p>

<ul>
<li>C = (3 - A&#8217;^2) / (3 * B&#8217;^2)</li>
<li>D = (2 * A&#8217;^3 - 9 * A&#8217;) / (27 * B&#8217;^3)</li>
<li>x = (3 * s + A&#8217;) / (3 * B&#8217;)</li>
<li>y = t / B&#8217;</li>
</ul>
<p id="rfc.section.B.2.p.3">The inverse map, from the point (x, y) to the point (s, t), is given by</p>
<p></p>

<ul>
<li>s = (3 * B&#8217; * x - A&#8217;) / 3</li>
<li>t = y * B&#8217;</li>
</ul>
<p id="rfc.section.B.2.p.5">This mapping can be used to apply the Shallue-van de Woestijne method (<a href="#svdw" class="xref">Section 6.6.1</a>) to Montgomery curves.</p>
<h1 id="rfc.appendix.C">
<a href="#rfc.appendix.C">Appendix C.</a> <a href="#appx-iso" id="appx-iso">Isogeny maps for Suites</a>
</h1>
<p id="rfc.section.C.p.1">This section specifies the isogeny maps for the secp256k1 and BLS12-381 suites listed in <a href="#suites" class="xref">Section 8</a>.</p>
<p id="rfc.section.C.p.2">These maps are given in terms of affine coordinates.  Wahby and Boneh (<a href="#WB19" class="xref">[WB19]</a>, Section 4.3) show how to evaluate these maps in a projective coordinate system (<a href="#projective-coords" class="xref">Appendix D.1</a>), which avoids modular inversions.</p>
<p id="rfc.section.C.p.3">Refer to the draft repository <a href="#hash2curve-repo" class="xref">[hash2curve-repo]</a> for a Sage <a href="#SAGE" class="xref">[SAGE]</a> script that constructs these isogenies.</p>
<h1 id="rfc.appendix.C.1">
<a href="#rfc.appendix.C.1">C.1.</a> <a href="#appx-iso-secp256k1" id="appx-iso-secp256k1">3-isogeny map for secp256k1</a>
</h1>
<p id="rfc.section.C.1.p.1">This section specifies the isogeny map for the secp256k1 suite listed in <a href="#suites-secp256k1" class="xref">Section 8.8</a>.</p>
<p id="rfc.section.C.1.p.2">The 3-isogeny map from (x&#8217;, y&#8217;) on E&#8217; to (x, y) on E is given by the following rational functions:</p>
<p></p>

<ul>
<li>x = x_num / x_den, where <ul>
<li>x_num = k_(1,3) * x&#8217;^3 + k_(1,2) * x&#8217;^2 + k_(1,1) * x&#8217; + k_(1,0)</li>
<li>x_den = x&#8217;^2 + k_(2,1) * x&#8217; + k_(2,0)</li>
</ul>
</li>
<li>y = y&#8217; * y_num / y_den, where <ul>
<li>y_num = k_(3,3) * x&#8217;^3 + k_(3,2) * x&#8217;^2 + k_(3,1) * x&#8217; + k_(3,0)</li>
<li>y_den = x&#8217;^3 + k_(4,2) * x&#8217;^2 + k_(4,1) * x&#8217; + k_(4,0)</li>
</ul>
</li>
</ul>
<p id="rfc.section.C.1.p.4">The constants used to compute x_num are as follows:</p>
<p></p>

<ul>
<li>k_(1,0) = 0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7</li>
<li>k_(1,1) = 0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581</li>
<li>k_(1,2) = 0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262</li>
<li>k_(1,3) = 0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c</li>
</ul>
<p id="rfc.section.C.1.p.6">The constants used to compute x_den are as follows:</p>
<p></p>

<ul>
<li>k_(2,0) = 0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b</li>
<li>k_(2,1) = 0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14</li>
</ul>
<p id="rfc.section.C.1.p.8">The constants used to compute y_num are as follows:</p>
<p></p>

<ul>
<li>k_(3,0) = 0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c</li>
<li>k_(3,1) = 0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3</li>
<li>k_(3,2) = 0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931</li>
<li>k_(3,3) = 0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84</li>
</ul>
<p id="rfc.section.C.1.p.10">The constants used to compute y_den are as follows:</p>
<p></p>

<ul>
<li>k_(4,0) = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b</li>
<li>k_(4,1) = 0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573</li>
<li>k_(4,2) = 0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f</li>
</ul>
<h1 id="rfc.appendix.C.2">
<a href="#rfc.appendix.C.2">C.2.</a> <a href="#appx-iso-bls12381-g1" id="appx-iso-bls12381-g1">11-isogeny map for BLS12-381 G1</a>
</h1>
<p id="rfc.section.C.2.p.1">The 11-isogeny map from (x&#8217;, y&#8217;) on E&#8217; to (x, y) on E is given by the following rational functions:</p>
<p></p>

<ul>
<li>x = x_num / x_den, where <ul>
<li>x_num = k_(1,11) * x&#8217;^11 + k_(1,10) * x&#8217;^10 + k_(1,9) * x&#8217;^9 + &#8230; + k_(1,0)</li>
<li>x_den = x&#8217;^10 + k_(2,9) * x&#8217;^9 + k_(2,8) * x&#8217;^8 + &#8230; + k_(2,0)</li>
</ul>
</li>
<li>y = y&#8217; * y_num / y_den, where <ul>
<li>y_num = k_(3,15) * x&#8217;^15 + k_(3,14) * x&#8217;^14 + k_(3,13) * x&#8217;^13 + &#8230; + k_(3,0)</li>
<li>y_den = x&#8217;^15 + k_(4,14) * x&#8217;^14 + k_(4,13) * x&#8217;^13 + &#8230; + k_(4,0)</li>
</ul>
</li>
</ul>
<p id="rfc.section.C.2.p.3">The constants used to compute x_num are as follows:</p>
<p></p>

<ul>
<li>k_(1,0) = 0x11a05f2b1e833340b809101dd99815856b303e88a2d7005ff2627b56cdb4e2c85610c2d5f2e62d6eaeac1662734649b7</li>
<li>k_(1,1) = 0x17294ed3e943ab2f0588bab22147a81c7c17e75b2f6a8417f565e33c70d1e86b4838f2a6f318c356e834eef1b3cb83bb</li>
<li>k_(1,2) = 0xd54005db97678ec1d1048c5d10a9a1bce032473295983e56878e501ec68e25c958c3e3d2a09729fe0179f9dac9edcb0</li>
<li>k_(1,3) = 0x1778e7166fcc6db74e0609d307e55412d7f5e4656a8dbf25f1b33289f1b330835336e25ce3107193c5b388641d9b6861</li>
<li>k_(1,4) = 0xe99726a3199f4436642b4b3e4118e5499db995a1257fb3f086eeb65982fac18985a286f301e77c451154ce9ac8895d9</li>
<li>k_(1,5) = 0x1630c3250d7313ff01d1201bf7a74ab5db3cb17dd952799b9ed3ab9097e68f90a0870d2dcae73d19cd13c1c66f652983</li>
<li>k_(1,6) = 0xd6ed6553fe44d296a3726c38ae652bfb11586264f0f8ce19008e218f9c86b2a8da25128c1052ecaddd7f225a139ed84</li>
<li>k_(1,7) = 0x17b81e7701abdbe2e8743884d1117e53356de5ab275b4db1a682c62ef0f2753339b7c8f8c8f475af9ccb5618e3f0c88e</li>
<li>k_(1,8) = 0x80d3cf1f9a78fc47b90b33563be990dc43b756ce79f5574a2c596c928c5d1de4fa295f296b74e956d71986a8497e317</li>
<li>k_(1,9) = 0x169b1f8e1bcfa7c42e0c37515d138f22dd2ecb803a0c5c99676314baf4bb1b7fa3190b2edc0327797f241067be390c9e</li>
<li>k_(1,10) = 0x10321da079ce07e272d8ec09d2565b0dfa7dccdde6787f96d50af36003b14866f69b771f8c285decca67df3f1605fb7b</li>
<li>k_(1,11) = 0x6e08c248e260e70bd1e962381edee3d31d79d7e22c837bc23c0bf1bc24c6b68c24b1b80b64d391fa9c8ba2e8ba2d229</li>
</ul>
<p id="rfc.section.C.2.p.5">The constants used to compute x_den are as follows:</p>
<p></p>

<ul>
<li>k_(2,0) = 0x8ca8d548cff19ae18b2e62f4bd3fa6f01d5ef4ba35b48ba9c9588617fc8ac62b558d681be343df8993cf9fa40d21b1c</li>
<li>k_(2,1) = 0x12561a5deb559c4348b4711298e536367041e8ca0cf0800c0126c2588c48bf5713daa8846cb026e9e5c8276ec82b3bff</li>
<li>k_(2,2) = 0xb2962fe57a3225e8137e629bff2991f6f89416f5a718cd1fca64e00b11aceacd6a3d0967c94fedcfcc239ba5cb83e19</li>
<li>k_(2,3) = 0x3425581a58ae2fec83aafef7c40eb545b08243f16b1655154cca8abc28d6fd04976d5243eecf5c4130de8938dc62cd8</li>
<li>k_(2,4) = 0x13a8e162022914a80a6f1d5f43e7a07dffdfc759a12062bb8d6b44e833b306da9bd29ba81f35781d539d395b3532a21e</li>
<li>k_(2,5) = 0xe7355f8e4e667b955390f7f0506c6e9395735e9ce9cad4d0a43bcef24b8982f7400d24bc4228f11c02df9a29f6304a5</li>
<li>k_(2,6) = 0x772caacf16936190f3e0c63e0596721570f5799af53a1894e2e073062aede9cea73b3538f0de06cec2574496ee84a3a</li>
<li>k_(2,7) = 0x14a7ac2a9d64a8b230b3f5b074cf01996e7f63c21bca68a81996e1cdf9822c580fa5b9489d11e2d311f7d99bbdcc5a5e</li>
<li>k_(2,8) = 0xa10ecf6ada54f825e920b3dafc7a3cce07f8d1d7161366b74100da67f39883503826692abba43704776ec3a79a1d641</li>
<li>k_(2,9) = 0x95fc13ab9e92ad4476d6e3eb3a56680f682b4ee96f7d03776df533978f31c1593174e4b4b7865002d6384d168ecdd0a</li>
</ul>
<p id="rfc.section.C.2.p.7">The constants used to compute y_num are as follows:</p>
<p></p>

<ul>
<li>k_(3,0) = 0x90d97c81ba24ee0259d1f094980dcfa11ad138e48a869522b52af6c956543d3cd0c7aee9b3ba3c2be9845719707bb33</li>
<li>k_(3,1) = 0x134996a104ee5811d51036d776fb46831223e96c254f383d0f906343eb67ad34d6c56711962fa8bfe097e75a2e41c696</li>
<li>k_(3,2) = 0xcc786baa966e66f4a384c86a3b49942552e2d658a31ce2c344be4b91400da7d26d521628b00523b8dfe240c72de1f6</li>
<li>k_(3,3) = 0x1f86376e8981c217898751ad8746757d42aa7b90eeb791c09e4a3ec03251cf9de405aba9ec61deca6355c77b0e5f4cb</li>
<li>k_(3,4) = 0x8cc03fdefe0ff135caf4fe2a21529c4195536fbe3ce50b879833fd221351adc2ee7f8dc099040a841b6daecf2e8fedb</li>
<li>k_(3,5) = 0x16603fca40634b6a2211e11db8f0a6a074a7d0d4afadb7bd76505c3d3ad5544e203f6326c95a807299b23ab13633a5f0</li>
<li>k_(3,6) = 0x4ab0b9bcfac1bbcb2c977d027796b3ce75bb8ca2be184cb5231413c4d634f3747a87ac2460f415ec961f8855fe9d6f2</li>
<li>k_(3,7) = 0x987c8d5333ab86fde9926bd2ca6c674170a05bfe3bdd81ffd038da6c26c842642f64550fedfe935a15e4ca31870fb29</li>
<li>k_(3,8) = 0x9fc4018bd96684be88c9e221e4da1bb8f3abd16679dc26c1e8b6e6a1f20cabe69d65201c78607a360370e577bdba587</li>
<li>k_(3,9) = 0xe1bba7a1186bdb5223abde7ada14a23c42a0ca7915af6fe06985e7ed1e4d43b9b3f7055dd4eba6f2bafaaebca731c30</li>
<li>k_(3,10) = 0x19713e47937cd1be0dfd0b8f1d43fb93cd2fcbcb6caf493fd1183e416389e61031bf3a5cce3fbafce813711ad011c132</li>
<li>k_(3,11) = 0x18b46a908f36f6deb918c143fed2edcc523559b8aaf0c2462e6bfe7f911f643249d9cdf41b44d606ce07c8a4d0074d8e</li>
<li>k_(3,12) = 0xb182cac101b9399d155096004f53f447aa7b12a3426b08ec02710e807b4633f06c851c1919211f20d4c04f00b971ef8</li>
<li>k_(3,13) = 0x245a394ad1eca9b72fc00ae7be315dc757b3b080d4c158013e6632d3c40659cc6cf90ad1c232a6442d9d3f5db980133</li>
<li>k_(3,14) = 0x5c129645e44cf1102a159f748c4a3fc5e673d81d7e86568d9ab0f5d396a7ce46ba1049b6579afb7866b1e715475224b</li>
<li>k_(3,15) = 0x15e6be4e990f03ce4ea50b3b42df2eb5cb181d8f84965a3957add4fa95af01b2b665027efec01c7704b456be69c8b604</li>
</ul>
<p id="rfc.section.C.2.p.9">The constants used to compute y_den are as follows:</p>
<p></p>

<ul>
<li>k_(4,0) = 0x16112c4c3a9c98b252181140fad0eae9601a6de578980be6eec3232b5be72e7a07f3688ef60c206d01479253b03663c1</li>
<li>k_(4,1) = 0x1962d75c2381201e1a0cbd6c43c348b885c84ff731c4d59ca4a10356f453e01f78a4260763529e3532f6102c2e49a03d</li>
<li>k_(4,2) = 0x58df3306640da276faaae7d6e8eb15778c4855551ae7f310c35a5dd279cd2eca6757cd636f96f891e2538b53dbf67f2</li>
<li>k_(4,3) = 0x16b7d288798e5395f20d23bf89edb4d1d115c5dbddbcd30e123da489e726af41727364f2c28297ada8d26d98445f5416</li>
<li>k_(4,4) = 0xbe0e079545f43e4b00cc912f8228ddcc6d19c9f0f69bbb0542eda0fc9dec916a20b15dc0fd2ededda39142311a5001d</li>
<li>k_(4,5) = 0x8d9e5297186db2d9fb266eaac783182b70152c65550d881c5ecd87b6f0f5a6449f38db9dfa9cce202c6477faaf9b7ac</li>
<li>k_(4,6) = 0x166007c08a99db2fc3ba8734ace9824b5eecfdfa8d0cf8ef5dd365bc400a0051d5fa9c01a58b1fb93d1a1399126a775c</li>
<li>k_(4,7) = 0x16a3ef08be3ea7ea03bcddfabba6ff6ee5a4375efa1f4fd7feb34fd206357132b920f5b00801dee460ee415a15812ed9</li>
<li>k_(4,8) = 0x1866c8ed336c61231a1be54fd1d74cc4f9fb0ce4c6af5920abc5750c4bf39b4852cfe2f7bb9248836b233d9d55535d4a</li>
<li>k_(4,9) = 0x167a55cda70a6e1cea820597d94a84903216f763e13d87bb5308592e7ea7d4fbc7385ea3d529b35e346ef48bb8913f55</li>
<li>k_(4,10) = 0x4d2f259eea405bd48f010a01ad2911d9c6dd039bb61a6290e591b36e636a5c871a5c29f4f83060400f8b49cba8f6aa8</li>
<li>k_(4,11) = 0xaccbb67481d033ff5852c1e48c50c477f94ff8aefce42d28c0f9a88cea7913516f968986f7ebbea9684b529e2561092</li>
<li>k_(4,12) = 0xad6b9514c767fe3c3613144b45f1496543346d98adf02267d5ceef9a00d9b8693000763e3b90ac11e99b138573345cc</li>
<li>k_(4,13) = 0x2660400eb2e4f3b628bdd0d53cd76f2bf565b94e72927c1cb748df27942480e420517bd8714cc80d1fadc1326ed06f7</li>
<li>k_(4,14) = 0xe0fa1d816ddc03e6b24255e0d7819c171c40f65e273b853324efcd6356caa205ca2f570f13497804415473a1d634b8f</li>
</ul>
<h1 id="rfc.appendix.C.3">
<a href="#rfc.appendix.C.3">C.3.</a> <a href="#appx-iso-bls12381-g2" id="appx-iso-bls12381-g2">3-isogeny map for BLS12-381 G2</a>
</h1>
<p id="rfc.section.C.3.p.1">The 3-isogeny map from (x&#8217;, y&#8217;) on E&#8217; to (x, y) on E is given by the following rational functions:</p>
<p></p>

<ul>
<li>x = x_num / x_den, where <ul>
<li>x_num = k_(1,3) * x&#8217;^3 + k_(1,2) * x&#8217;^2 + k_(1,1) * x&#8217; + k_(1,0)</li>
<li>x_den = x&#8217;^2 + k_(2,1) * x&#8217; + k_(2,0)</li>
</ul>
</li>
<li>y = y&#8217; * y_num / y_den, where <ul>
<li>y_num = k_(3,3) * x&#8217;^3 + k_(3,2) * x&#8217;^2 + k_(3,1) * x&#8217; + k_(3,0)</li>
<li>y_den = x&#8217;^3 + k_(4,2) * x&#8217;^2 + k_(4,1) * x&#8217; + k_(4,0)</li>
</ul>
</li>
</ul>
<p id="rfc.section.C.3.p.3">The constants used to compute x_num are as follows:</p>
<p></p>

<ul>
<li>k_(1,0) = 0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6 + 0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6 * I</li>
<li>k_(1,1) = 0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71a * I</li>
<li>k_(1,2) = 0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71e + 0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38d * I</li>
<li>k_(1,3) = 0x171d6541fa38ccfaed6dea691f5fb614cb14b4e7f4e810aa22d6108f142b85757098e38d0f671c7188e2aaaaaaaa5ed1</li>
</ul>
<p id="rfc.section.C.3.p.5">The constants used to compute x_den are as follows:</p>
<p></p>

<ul>
<li>k_(2,0) = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa63 * I</li>
<li>k_(2,1) = 0xc + 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa9f * I</li>
</ul>
<p id="rfc.section.C.3.p.7">The constants used to compute y_num are as follows:</p>
<p></p>

<ul>
<li>k_(3,0) = 0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706 + 0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706 * I</li>
<li>k_(3,1) = 0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97be * I</li>
<li>k_(3,2) = 0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71c + 0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38f * I</li>
<li>k_(3,3) = 0x124c9ad43b6cf79bfbf7043de3811ad0761b0f37a1e26286b0e977c69aa274524e79097a56dc4bd9e1b371c71c718b10</li>
</ul>
<p id="rfc.section.C.3.p.9">The constants used to compute y_den are as follows:</p>
<p></p>

<ul>
<li>k_(4,0) = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb + 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb * I</li>
<li>k_(4,1) = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa9d3 * I</li>
<li>k_(4,2) = 0x12 + 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa99 * I</li>
</ul>
<h1 id="rfc.appendix.D">
<a href="#rfc.appendix.D">Appendix D.</a> <a href="#samplecode" id="samplecode">Sample Code</a>
</h1>
<p id="rfc.section.D.p.1">This section gives sample implementations optimized for some of the elliptic curves listed in <a href="#suites" class="xref">Section 8</a>.  A future version of this document will include all listed curves, plus accompanying test vectors.  Sample Sage <a href="#SAGE" class="xref">[SAGE]</a> code for each algorithm can also be found in the draft repository <a href="#hash2curve-repo" class="xref">[hash2curve-repo]</a>.</p>
<h1 id="rfc.appendix.D.1">
<a href="#rfc.appendix.D.1">D.1.</a> <a href="#projective-coords" id="projective-coords">Interface and projective coordinate systems</a>
</h1>
<p id="rfc.section.D.1.p.1">The sample code in this section uses a different interface than the mappings of <a href="#mappings" class="xref">Section 6</a>.  Specifically, each mapping function in this section has the following signature:</p>
<pre>
(xn, xd, yn, nd) = map_to_curve(u)
</pre>
<p id="rfc.section.D.1.p.2">The resulting point (x, y) is given by (xn / xd, yn / yd).</p>
<p id="rfc.section.D.1.p.3">The reason for this modified interface is that it enables further optimizations when working with points in a projective coordinate system.  This is desirable, for example, when the resulting point will be immediately multiplied by a scalar, since most scalar multiplication algorithms operate on projective points.</p>
<p id="rfc.section.D.1.p.4">The following are two commonly used projective coordinate systems and the corresponding conversions:</p>
<p></p>

<ul>
<li>A point (X, Y, Z) in homogeneous projective coordinates corresponds to the affine point (x, y) = (X / Z, Y / Z); the inverse conversion is given by (X, Y, Z) = (x, y, 1).  To convert (xn, xd, yn, yd) to homogeneous projective coordinates, compute (X, Y, Z) = (xn * yd, yn * xd, xd * yd).</li>
<li>A point (X&#8217;, Y&#8217;, Z&#8217;) in Jacobian projective coordinates corresponds to the affine point (x, y) = (X&#8217; / Z&#8217;^2, Y&#8217; / Z&#8217;^3); the inverse conversion is given by (X&#8217;, Y&#8217;, Z&#8217;) = (x, y, 1).  To convert (xn, xd, yn, yd) to Jacobian projective coordinates, compute (X&#8217;, Y&#8217;, Z&#8217;) = (xn * xd * yd^2, yn * yd^2 * xd^3, xd * yd).</li>
</ul>
<h1 id="rfc.appendix.D.2">
<a href="#rfc.appendix.D.2">D.2.</a> <a href="#sswu-map-to-3mod4" id="sswu-map-to-3mod4">Simplified SWU for p = 3 (mod 4)</a>
</h1>
<p id="rfc.section.D.2.p.1">The following is a straight-line implementation of the Simplified SWU mapping that applies to any curve over GF(p) for p = 3 (mod 4).  This includes the ciphersuites for NIST curves P-256, P-384, and P-521 <a href="#FIPS186-4" class="xref">[FIPS186-4]</a> given in <a href="#suites" class="xref">Section 8</a>.  It also includes the curves isogenous to secp256k1 (<a href="#suites-secp256k1" class="xref">Section 8.8</a>) and BLS12-381 G1 (<a href="#suites-bls12381-g1" class="xref">Section 8.9.1</a>).</p>
<p id="rfc.section.D.2.p.2">The implementations for these curves differ only in the constants and the base field.  The constant definitions below are given in terms of the parameters for the Simplified SWU mapping; for parameter values for the curves listed above, see <a href="#suites-p256" class="xref">Section 8.3</a> (P-256), <a href="#suites-p384" class="xref">Section 8.4</a> (P-384), <a href="#suites-p521" class="xref">Section 8.5</a> (P-521), <a href="#suites-secp256k1" class="xref">Section 8.8</a> (E&#8217; isogenous to secp256k1), and <a href="#suites-bls12381-g1" class="xref">Section 8.9.1</a> (E&#8217; isogenous to BLS12-381 G1).</p>
<pre>
map_to_curve_simple_swu_3mod4(u)

Input: u, an element of F.
Output: (xn, xd, yn, yd) such that (xn / xd, yn / yd) is a
        point on the target curve.

Constants: defined per curve; see above.
1.  c1 = B / 3
2.  c2 = (p - 3) / 4           // Integer arithmetic
3.  c3 = sqrt(-Z^3)

Steps:
1.   t1 = u^2
2.   t3 = Z * t1
3.   t2 = t3^2
4.   xd = t2 + t3
5.  x1n = xd + 1
6.  x1n = x1n * B
7.   xd = -A * xd
8.   e1 = xd == 0
9.   xd = CMOV(xd, Z * A, e1)  // If xd == 0, set xd = Z * A
10.  t2 = xd^2
11. gxd = t2 * xd              // gxd == xd^3
12.  t2 = A * t2
13. gx1 = x1n^2
14. gx1 = gx1 + t2             // x1n^2 + A * xd^2
15. gx1 = gx1 * x1n            // x1n^3 + A * x1n * xd^2
16.  t2 = B * gxd
17. gx1 = gx1 + t2             // x1n^3 + A * x1n * xd^2 + B * xd^3
18.  t4 = gxd^2
19.  t2 = gx1 * gxd
20.  t4 = t4 * t2              // gx1 * gxd^3
21.  y1 = t4^c2                // (gx1 * gxd^3)^((p - 3) / 4)
22.  y1 = y1 * t2              // gx1 * gxd * (gx1 * gxd^3)^((p - 3) / 4)
23. x2n = t3 * x1n             // x2 = x2n / xd = -10 * u^2 * x1n / xd
24.  y2 = y1 * c3              // y2 = y1 * sqrt(-Z^3)
25.  y2 = y2 * t1
26.  y2 = y2 * u
27.  t2 = y1^2
28.  t2 = t2 * gxd
29.  e2 = t2 == gx1
30.  xn = CMOV(x2n, x1n, e2)   // If e2, x = x1, else x = x2
31.   y = CMOV(y2, y1, e2)     // If e2, y = y1, else y = y2
32.  e3 = sgn0(u) == sgn0(y)   // Fix sign of y
33.   y = CMOV(-y, y, e3)
34. return (xn, xd, y, 1)
</pre>
<h1 id="rfc.appendix.D.3">
<a href="#rfc.appendix.D.3">D.3.</a> <a href="#map-to-curve25519" id="map-to-curve25519">curve25519 (Elligator 2)</a>
</h1>
<p id="rfc.section.D.3.p.1">The following is a straight-line implementation of Elligator 2 for curve25519 <a href="#RFC7748" class="xref">[RFC7748]</a> as specified in <a href="#suites-25519" class="xref">Section 8.6</a>.</p>
<pre>
map_to_curve_elligator2_curve25519(u)

Input: u, an element of F.
Output: (xn, xd, yn, yd) such that (xn / xd, yn / yd) is a
        point on curve25519.

Constants:
1. c1 = (p + 3) / 8           // Integer arithmetic
2. c2 = 2^c1
3. c3 = sqrt(-1)
4. c4 = (p - 5) / 8           // Integer arithmetic

Steps:
1.   t1 = u^2
2.   t1 = 2 * t1
3.   xd = t1 + 1              // Nonzero: -1 is square (mod p), t1 is not
4.  x1n = -486662             // x1 = x1n / xd = -486662 / (1 + 2 * u^2)
5.   t2 = xd^2
6.  gxd = t2 * xd             // gxd = xd^3
7.  gx1 = 486662 * xd         // 486662 * xd
8.  gx1 = gx1 + x1n           // x1n + 486662 * xd
9.  gx1 = gx1 * x1n           // x1n^2 + 486662 * x1n * xd
10. gx1 = gx1 + t2            // x1n^2 + 486662 * x1n * xd + xd^2
11. gx1 = gx1 * x1n           // x1n^3 + 486662 * x1n^2 * xd + x1n * xd^2
12.  t3 = gxd^2
13.  t2 = t3^2                // gxd^4
14.  t3 = t3 * gxd            // gxd^3
15.  t3 = t3 * gx1            // gx1 * gxd^3
16.  t2 = t2 * t3             // gx1 * gxd^7
17. y11 = t2^c4               // (gx1 * gxd^7)^((p - 5) / 8)
18. y11 = y11 * t3            // gx1 * gxd^3 * (gx1 * gxd^7)^((p - 5) / 8)
19. y12 = y11 * c3
20.  t2 = y11^2
21.  t2 = t2 * gxd
22.  e1 = t2 == gx1
23.  y1 = CMOV(y12, y11, e1)  // If g(x1) is square, this is its sqrt
24. x2n = x1n * t1            // x2 = x2n / xd = 2 * u^2 * x1n / xd
25. y21 = y11 * u
26. y21 = y21 * c2
27. y22 = y21 * c3
28. gx2 = gx1 * t1            // g(x2) = gx2 / gxd = 2 * u^2 * g(x1)
29.  t2 = y21^2
30.  t2 = t2 * gxd
31.  e2 = t2 == gx2
32.  y2 = CMOV(y22, y21, e2)  // If g(x2) is square, this is its sqrt
33.  t2 = y1^2
34.  t2 = t2 * gxd
35.  e3 = t2 == gx1
36.  xn = CMOV(x2n, x1n, e3)  // If e3, x = x1, else x = x2
37.   y = CMOV(y2, y1, e3)    // If e3, y = y1, else y = y2
38.  e4 = sgn0(u) == sgn0(y)  // Fix sign of y
39.   y = CMOV(-y, y, e4)
40. return (xn, xd, y, 1)
</pre>
<h1 id="rfc.appendix.D.4">
<a href="#rfc.appendix.D.4">D.4.</a> <a href="#map-to-edwards25519" id="map-to-edwards25519">edwards25519 (Elligator 2)</a>
</h1>
<p id="rfc.section.D.4.p.1">The following is a straight-line implementation of Elligator 2 for edwards25519 <a href="#RFC7748" class="xref">[RFC7748]</a> as specified in <a href="#suites-25519" class="xref">Section 8.6</a>.  The subroutine map_to_curve_elligator2_curve25519 is defined in <a href="#map-to-curve25519" class="xref">Appendix D.3</a>.</p>
<pre>
map_to_curve_elligator2_edwards25519(u)

Input: u, an element of F.
Output: (xn, xd, yn, yd) such that (xn / xd, yn / yd) is a
        point on edwards25519.

Constants:
1. c1 = sqrt(-486664)   // sgn0(c1) MUST equal 1

Steps:
1.  (xMn, xMd, yMn, yMd) = map_to_curve_elligator2_curve25519(u)
2.  xn = xMn * yMd
3.  xn = xn * c1
4.  xd = xMd * yMn       // xn / xd = c1 * xM / yM
5.  yn = xMn - xMd
6.  yd = xMn + xMd       // (n / d - 1) / (n / d + 1) = (n - d) / (n + d)
7.  t1 = xd * yd
8.   e = t1 == 0
9.  xn = CMOV(xn, 0, e)
10. xd = CMOV(xd, 1, e)
11. yn = CMOV(yn, 1, e)
12. yd = CMOV(yd, 1, e)
13. return (xn, xd, yn, yd)
</pre>
<h1 id="rfc.appendix.D.5">
<a href="#rfc.appendix.D.5">D.5.</a> <a href="#map-to-curve448" id="map-to-curve448">curve448 (Elligator 2)</a>
</h1>
<p id="rfc.section.D.5.p.1">The following is a straight-line implementation of Elligator 2 for curve448 <a href="#RFC7748" class="xref">[RFC7748]</a> as specified in <a href="#suites-448" class="xref">Section 8.7</a>.</p>
<pre>
map_to_curve_elligator2_curve448(u)

Input: u, an element of F.
Output: (xn, xd, yn, yd) such that (xn / xd, yn / yd) is a
        point on curve448.

Constants:
1. c1 = (p - 3) / 4           // Integer arithmetic

Steps:
1.   t1 = u^2
2.   e1 = t1 == 1
3.   t1 = CMOV(t1, 0, e1)     // If Z * u^2 == -1, set t1 = 0
4.   xd = 1 - t1
5.  x1n = -156326
6.   t2 = xd^2
7.  gxd = t2 * xd             // gxd = xd^3
8.  gx1 = 156326 * xd         // 156326 * xd
9.  gx1 = gx1 + x1n           // x1n + 156326 * xd
10. gx1 = gx1 * x1n           // x1n^2 + 156326 * x1n * xd
11. gx1 = gx1 + t2            // x1n^2 + 156326 * x1n * xd + xd^2
12. gx1 = gx1 * x1n           // x1n^3 + 156326 * x1n^2 * xd + x1n * xd^2
13.  t3 = gxd^2
14.  t2 = gx1 * gxd           // gx1 * gxd
15.  t3 = t3 * t2             // gx1 * gxd^3
16.  y1 = t3^c1               // (gx1 * gxd^3)^((p - 3) / 4)
17.  y1 = y1 * t2             // gx1 * gxd * (gx1 * gxd^3)^((p - 3) / 4)
18. x2n = -t1 * x1n           // x2 = x2n / xd = -1 * u^2 * x1n / xd
19.  y2 = y1 * u
20.  y2 = CMOV(y2, 0, e1)
21.  t2 = y1^2
22.  t2 = t2 * gxd
23.  e2 = t2 == gx1
24.  xn = CMOV(x2n, x1n, e2)  // If e2, x = x1, else x = x2
25.   y = CMOV(y2, y1, e2)    // If e2, y = y1, else y = y2
26.  e3 = sgn0(u) == sgn0(y)  // Fix sign of y
27.   y = CMOV(-y, y, e3)
28. return (xn, xd, y, 1)
</pre>
<h1 id="rfc.appendix.D.6">
<a href="#rfc.appendix.D.6">D.6.</a> <a href="#map-to-edwards448" id="map-to-edwards448">edwards448 (Elligator 2)</a>
</h1>
<p id="rfc.section.D.6.p.1">The following is a straight-line implementation of Elligator 2 for edwards448 <a href="#RFC7748" class="xref">[RFC7748]</a> as specified in <a href="#suites-448" class="xref">Section 8.7</a>.  The subroutine map_to_curve_elligator2_curve448 is defined in <a href="#map-to-curve448" class="xref">Appendix D.5</a>.</p>
<pre>
map_to_curve_elligator2_edwards448(u)

Input: u, an element of F.
Output: (xn, xd, yn, yd) such that (xn / xd, yn / yd) is a
        point on edwards448.

Steps:
1. (xn, xd, yn, yd) = map_to_curve_elligator2_curve448(u)
2.  xn2 = xn^2
3.  xd2 = xd^2
4.  xd4 = xd2^2
5.  yn2 = yn^2
6.  yd2 = yd^2
7.  xEn = xn2 - xd2
8.   t2 = xEn - xd2
9.  xEn = xEn * xd2
10. xEn = xEn * yd
11. xEn = xEn * yn
12. xEn = xEn * 4
13.  t2 = t2 * xn2
14.  t2 = t2 * yd2
15.  t3 = 4 * yn2
16.  t1 = t3 + yd2
17.  t1 = t1 * xd4
18. xEd = t1 + t2
19.  t2 = t2 * xn
20.  t4 = xn * xd4
21. yEn = t3 - yd2
22. yEn = yEn * t4
23. yEn = yEn - t2
24.  t1 = xn2 + xd2
25.  t1 = t1 * xd2
26.  t1 = t1 * xd
27.  t1 = t1 * yn2
28.  t1 = -2 * t1
29. yEd = t2 + t1
30.  t4 = t4 * yd2
31. yEd = yEd + t4
32.  t1 = xEd * yEd
33.   e = t1 == 0
34. xEn = CMOV(xEn, 0, e)
35. xEd = CMOV(xEd, 1, e)
36. yEn = CMOV(yEn, 1, e)
37. yEd = CMOV(yEd, 1, e)
38. return (xEn, xEd, yEn, yEd)
</pre>
<h1 id="rfc.appendix.E">
<a href="#rfc.appendix.E">Appendix E.</a> <a href="#paramgen" id="paramgen">Scripts for parameter generation</a>
</h1>
<p id="rfc.section.E.p.1">This section gives Sage <a href="#SAGE" class="xref">[SAGE]</a> scripts used to generate parameters for the mappings of <a href="#mappings" class="xref">Section 6</a>.</p>
<h1 id="rfc.appendix.E.1">
<a href="#rfc.appendix.E.1">E.1.</a> <a href="#svdw-z-code" id="svdw-z-code">Finding Z for the Shallue and van de Woestijne map</a>
</h1>
<p id="rfc.section.E.1.p.1">The below function outputs an appropriate Z for the Shallue and van de Woestijne map (<a href="#svdw" class="xref">Section 6.6.1</a>).</p>
<pre>
def find_z_svdw(F, A, B):
    g = lambda x: F(x)^3 + F(A) * F(x) + F(B)
    h = lambda Z: -(F(3) * Z^2 + F(4) * A) / (F(4) * g(Z))
    ctr = F.gen()
    while True:
        for Z_cand in (F(ctr), F(-ctr)):
            if g(Z_cand) == F(0):
                # Criterion 1: g(Z) != 0 in F.
                continue
            if h(Z_cand) == F(0):
                # Criterion 2: -(3 * Z^2 + 4 * A) / (4 * g(Z)) != 0 in F.
                continue
            if not h(Z_cand).is_square():
                # Criterion 3: -(3 * Z^2 + 4 * A) / (4 * g(Z)) is square in F.
                continue
            if g(Z_cand).is_square() or g(-Z_cand / F(2)).is_square():
                # Criterion 4: At least one of g(Z) and g(-Z / 2) is square in F.
                return Z_cand
        ctr += 1
</pre>
<h1 id="rfc.appendix.E.2">
<a href="#rfc.appendix.E.2">E.2.</a> <a href="#sswu-z-code" id="sswu-z-code">Finding Z for Simplified SWU</a>
</h1>
<p id="rfc.section.E.2.p.1">The below function outputs an appropriate Z for the Simplified SWU map (<a href="#simple-swu" class="xref">Section 6.6.2</a>).</p>
<pre>
# Arguments:
# - F, a field object, e.g., F = GF(2^521 - 1)
# - A and B, the coefficients of the curve equation y^2 = x^3 + A * x + B
def find_z_sswu(F, A, B):
    R.&lt;xx&gt; = F[]                        # Polynomial ring over F
    g = xx^3 + F(A) * xx + F(B)         # y^2 = g(x) = x^3 + A * x + B
    ctr = F.gen()
    while True:
        for Z_cand in (F(ctr), F(-ctr)):
            if Z_cand.is_square():
                # Criterion 1: Z is non-square in F.
                continue
            if Z_cand == F(-1):
                # Criterion 2: Z != -1 in F.
                continue
            if not (g - Z_cand).is_irreducible():
                # Criterion 3: g(x) - Z is irreducible over F.
                continue
            if g(B / (Z_cand * A)).is_square():
                # Criterion 4: g(B / (Z * A)) is square in F.
                return Z_cand
        ctr += 1
</pre>
<h1 id="rfc.appendix.E.3">
<a href="#rfc.appendix.E.3">E.3.</a> <a href="#elligator-z-code" id="elligator-z-code">Finding Z for Elligator 2</a>
</h1>
<p id="rfc.section.E.3.p.1">The below function outputs an appropriate Z for the Elligator 2 map (<a href="#elligator2" class="xref">Section 6.7.1</a>).</p>
<pre>
# Argument:
# - F, a field object, e.g., F = GF(2^255 - 19)
def find_z_ell2(F):
    ctr = F.gen()
    while True:
        for Z_cand in (F(ctr), F(-ctr)):
            if Z_cand.is_square():
                # Z must be a non-square in F.
                continue
            return Z_cand
        ctr += 1
</pre>
<h1 id="rfc.appendix.F">
<a href="#rfc.appendix.F">Appendix F.</a> <a href="#appx-sqrt" id="appx-sqrt">sqrt functions</a>
</h1>
<p id="rfc.section.F.p.1">This section defines special-purpose sqrt functions for the three most common cases, p = 3 (mod 4), p = 5 (mod 8), and p = 9 (mod 16).  In addition, it gives a generic constant-time algorithm that works for any prime modulus.</p>
<h1 id="rfc.appendix.F.1">
<a href="#rfc.appendix.F.1">F.1.</a> <a href="#sqrt-3mod4" id="sqrt-3mod4">p = 3 (mod 4)</a>
</h1>
<pre>
sqrt_3mod4(x)

Parameters:
- F, a finite field of characteristic p and order q = p^m.
- p, the characteristic of F (see immediately above).

Input: x, an element of F.
Output: s, an element of F such that (s^2) == x.

Constants:
1. c1 = (q + 1) / 4     // Integer arithmetic

Procedure:
1. return x^c1
</pre>
<h1 id="rfc.appendix.F.2">
<a href="#rfc.appendix.F.2">F.2.</a> <a href="#sqrt-5mod8" id="sqrt-5mod8">p = 5 (mod 8)</a>
</h1>
<pre>
sqrt_5mod8(x)

Parameters:
- F, a finite field of characteristic p and order q = p^m.
- p, the characteristic of F (see immediately above).

Input: x, an element of F.
Output: s, an element of F such that (s^2) == x.

Constants:
1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F
2. c2 = (q + 3) / 8     // Integer arithmetic

Procedure:
1. t1 = x^c2
2.  e = (t1^2) == x
3.  s = CMOV(t1 * c1, t1, e)
3. return s
</pre>
<h1 id="rfc.appendix.F.3">
<a href="#rfc.appendix.F.3">F.3.</a> <a href="#sqrt-9mod16" id="sqrt-9mod16">p = 9 (mod 16)</a>
</h1>
<p id="rfc.section.F.3.p.1">Note that this case also applies to GF(p^2) when p = 3 (mod 8).  <a href="#AR13" class="xref">[AR13]</a> and <a href="#S85" class="xref">[S85]</a> describe methods that work for other finite fields.</p>
<pre>
sqrt_9mod16(x)

Parameters:
- F, a finite field of characteristic p and order q = p^m.
- p, the characteristic of F (see immediately above).

Input: x, an element of F.
Output: s, an element of F such that (s^2) == x.

Constants:
1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F
2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F
3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F
4. c4 = (q + 7) / 16    // Integer arithmetic

Procedure:
1.  t1 = x^c4
2.  t2 = c1 * t1
3.  t3 = c2 * t1
4.  t4 = c3 * t1
5.  e1 = (t2^2) == x
6.  e2 = (t3^2) == x
7.  t1 = CMOV(t1, t2, e1)  // Select t2 if (t2^2) == x
8.  t2 = CMOV(t4, t3, e2)  // Select t3 if (t3^2) == x
9.  e3 = (t2^2) == x
10.  s = CMOV(t1, t2, e3)  // Select the sqrt from t1 and t2
11. return s
</pre>
<h1 id="rfc.appendix.F.4">
<a href="#rfc.appendix.F.4">F.4.</a> <a href="#sqrt-ts" id="sqrt-ts">Constant-time Tonelli-Shanks algorithm</a>
</h1>
<p id="rfc.section.F.4.p.1">This algorithm is a constant-time version of the classic Tonelli-Shanks algorithm (<a href="#C93" class="xref">[C93]</a>, Algorithm 1.5.1) due to Sean Bowe, Jack Grigg, and Eirik Ogilvie-Wigley <a href="#jubjub-fq" class="xref">[jubjub-fq]</a>, adapted and optimized by Michael Scott.</p>
<p id="rfc.section.F.4.p.2">This algorithm applies to GF(p) for any p.  Note, however, that the special-purpose algorithms given in the prior sections are faster, when they apply.</p>
<pre>
sqrt_ts_ct(x)

Parameters:
- F, a finite field of order p
- p, the characteristic of F (see immediately above)

Input x, an element of F.
Output: s, an element of F such that s^2 == x, if x is a square in F.

Constants (see discussion below):
1. c1, the largest integer such that 2^c1 divides p - 1.
2. c2 = (p - 1) / (2^c1)        // Integer arithmetic
3. c3 = (c2 - 1) / 2            // Integer arithmetic
4. c4, a non-square value in F
5. c5 = c4^c2 in F

Procedure:
1.  s = x^c3
2.  t = s * s * x
3.  s = s * x
4.  b = t
5.  c = c5
6.  for k in (c1, c1 - 1, ..., 2):
7.      for j in (1, 2, ..., k - 2):
8.           b = b * b
9.      s = CMOV(s, s * c, b != 1)
10.     c = c * c
11.     t = CMOV(t, t * c, b != 1)
12.     b = t
13. return s
</pre>
<p id="rfc.section.F.4.p.3">The constants used in this procedure can be computed as follows:</p>
<pre>
precompute_ts(p)

Input: p, a prime
Output: the required constants c1, ..., c5

Procedure:
1.  c1 = 0
2.  c2 = p - 1
3.  while c2 is even:
4.      c2 = c2 / 2             // Integer arithmetic
5.      c1 = c1 + 1
6.  c3 = (c2 - 1) / 2           // Integer arithmetic
7.  c4 = 1
8.  while c4 is square mod p:
9.      c4 = c4 + 1
10. c5 = c4^c2 mod p
11. return (c1, c2, c3, c4, c5)
</pre>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Armando Faz-Hernandez</span> 
	  <span class="n hidden">
		<span class="family-name">Faz-Hernandez</span>
	  </span>
	</span>
	<span class="org vcardline">Cloudflare</span>
	<span class="adr">
	  <span class="vcardline">101 Townsend St</span>

	  <span class="vcardline">
		<span class="locality">San Francisco</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United States of America</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:armfazh@cloudflare.com">armfazh@cloudflare.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Sam Scott</span> 
	  <span class="n hidden">
		<span class="family-name">Scott</span>
	  </span>
	</span>
	<span class="org vcardline">Cornell Tech</span>
	<span class="adr">
	  <span class="vcardline">2 West Loop Rd</span>

	  <span class="vcardline">
		<span class="locality">New York, New York 10044</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United States of America</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:sam.scott@cornell.edu">sam.scott@cornell.edu</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Nick Sullivan</span> 
	  <span class="n hidden">
		<span class="family-name">Sullivan</span>
	  </span>
	</span>
	<span class="org vcardline">Cloudflare</span>
	<span class="adr">
	  <span class="vcardline">101 Townsend St</span>

	  <span class="vcardline">
		<span class="locality">San Francisco</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United States of America</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:nick@cloudflare.com">nick@cloudflare.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Riad S. Wahby</span> 
	  <span class="n hidden">
		<span class="family-name">Wahby</span>
	  </span>
	</span>
	<span class="org vcardline">Stanford University</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:rsw@cs.stanford.edu">rsw@cs.stanford.edu</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Christopher A. Wood</span> 
	  <span class="n hidden">
		<span class="family-name">Wood</span>
	  </span>
	</span>
	<span class="org vcardline">Apple Inc.</span>
	<span class="adr">
	  <span class="vcardline">One Apple Park Way</span>

	  <span class="vcardline">
		<span class="locality">Cupertino, California 95014</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United States of America</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:cawood@apple.com">cawood@apple.com</a></span>

  </address>
</div>

</body>
</html>

