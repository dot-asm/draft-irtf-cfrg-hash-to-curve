<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Hashing to Elliptic Curves</title>

  
<style type="text/css">/*<![CDATA[*/

body {
  font: 16px "Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 24px;
  margin: 75px auto;
  max-width: 624px;
  padding: 0 5px;
}

.title, .filename, h1, h2, h3, h4, h5 {
  font: 16px "Roboto Condensed","Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  font-size-adjust: 0.5;
  font-weight: bold;
  color: #333;
  line-height: 100%;
  margin: 1.2em 0 0.3em;
}
.title, #rfc\.title h1 { font-size: 32px; }
h1, section h1, h2, section h2, section h3, nav h2 { font-size: 20px; }
h3, section h4, h4, section h5 { font-size: 16px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header, table#rfc\.headerblock {
  width: 100%;
}
table.header td, table#rfc\.headerblock td {
  border: none;
  background-color: transparent;
  color: black;
  padding: 0;
}
.filename {
  display: block;
  color: rgb(119, 119, 119);
  font-size: 20px;
  font-weight: normal;
  line-height: 100%;
  margin: 10px 0 32px;
}
#rfc\.abstract+p, #rfc\.abstract+p code, #rfc\.abstract+p samp, #rfc\.abstract+p tt {
  font-size: 20px;
  line-height: 28px;
}

samp, tt, code, pre, span.tt {
  font-size: 13.5px;
  font-family: Consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure, caption {
  font-style: italic;
  margin: 0 1.5em;
  text-align: left;
}

address {
  margin: 16px 2px;
  line-height: 20px;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn, address b {
  font-weight: normal;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}
hr.noprint {
  display: none;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

p, ol, ul, li {
  padding: 0;
}
p {
  margin: 0.5em 0;
}
ol, ul {
  margin: 0.2em 0 0.2em 2em;
}
li {
  margin: 0.2em 0;
}
address {
  font-style: normal;
}

ul.toc ul {
  margin: 0 0 0 2em;
}
ul.toc li {
  list-style: none;
  margin: 0;
}

@media screen and (min-width: 924px) {
  body {
    padding-right: 350px;
  }
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    z-index: 1;
    overflow: auto;
    overscroll-behavior: contain;
  }
  body>#rfc\.toc {
    top: 55px;
  }
  body>ul.toc {
    top: 100px;
  }

  ul.toc {
    margin: 0 0 0 4px;
    font-size: 12px;
    line-height: 20px;
  }
  ul.toc ul {
    margin-left: 1.2em;
  }
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>
  <meta name="viewport" content="initial-scale=1.0">


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Requirements">
<link href="#rfc.section.2" rel="Chapter" title="2 Background">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Elliptic curves">
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Terminology">
<link href="#rfc.section.2.2.1" rel="Chapter" title="2.2.1 Mappings">
<link href="#rfc.section.2.2.2" rel="Chapter" title="2.2.2 Encodings">
<link href="#rfc.section.2.2.3" rel="Chapter" title="2.2.3 Random oracle encodings">
<link href="#rfc.section.2.2.4" rel="Chapter" title="2.2.4 Serialization">
<link href="#rfc.section.2.2.5" rel="Chapter" title="2.2.5 Domain separation">
<link href="#rfc.section.3" rel="Chapter" title="3 Roadmap">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Domain separation requirements">
<link href="#rfc.section.4" rel="Chapter" title="4 Utility Functions">
<link href="#rfc.section.5" rel="Chapter" title="5 Hashing to a Finite Field">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Security considerations">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Performance considerations">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Implementation">
<link href="#rfc.section.6" rel="Chapter" title="6 Deterministic Mappings">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Interface">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Notation">
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Sign of the resulting point">
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 Exceptional cases">
<link href="#rfc.section.6.5" rel="Chapter" title="6.5 Mappings for Weierstrass curves">
<link href="#rfc.section.6.5.1" rel="Chapter" title="6.5.1 Icart Method">
<link href="#rfc.section.6.5.2" rel="Chapter" title="6.5.2 Simplified Shallue-van de Woestijne-Ulas Method">
<link href="#rfc.section.6.6" rel="Chapter" title="6.6 Mappings for Montgomery curves">
<link href="#rfc.section.6.6.1" rel="Chapter" title="6.6.1 Elligator 2 Method">
<link href="#rfc.section.6.7" rel="Chapter" title="6.7 Mappings for Twisted Edwards curves">
<link href="#rfc.section.6.7.1" rel="Chapter" title="6.7.1 Rational maps from Montgomery to twisted Edwards curves">
<link href="#rfc.section.6.7.2" rel="Chapter" title="6.7.2 Elligator 2 Method">
<link href="#rfc.section.6.8" rel="Chapter" title="6.8 Mappings for Supersingular curves">
<link href="#rfc.section.6.8.1" rel="Chapter" title="6.8.1 Boneh-Franklin Method">
<link href="#rfc.section.6.8.2" rel="Chapter" title="6.8.2 Elligator 2, A == 0 Method">
<link href="#rfc.section.6.9" rel="Chapter" title="6.9 Mappings for Pairing-Friendly curves">
<link href="#rfc.section.6.9.1" rel="Chapter" title="6.9.1 Shallue-van de Woestijne Method">
<link href="#rfc.section.6.9.2" rel="Chapter" title="6.9.2 Simplified SWU for Pairing-Friendly Curves">
<link href="#rfc.section.7" rel="Chapter" title="7 Clearing the cofactor">
<link href="#rfc.section.8" rel="Chapter" title="8 Suites for Hashing">
<link href="#rfc.section.9" rel="Chapter" title="9 IANA Considerations">
<link href="#rfc.section.10" rel="Chapter" title="10 Security Considerations">
<link href="#rfc.section.11" rel="Chapter" title="11 Acknowledgements">
<link href="#rfc.section.12" rel="Chapter" title="12 Contributors">
<link href="#rfc.references" rel="Chapter" title="13 References">
<link href="#rfc.references.1" rel="Chapter" title="13.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="13.2 Informative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A Related Work">
<link href="#rfc.appendix.B" rel="Chapter" title="B Rational maps from twisted Edwards to Weierstrass and Montgomery curves">
<link href="#rfc.appendix.C" rel="Chapter" title="C Sample Code">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.22.2 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Faz-Hernandez, A., Scott, S., Sullivan, N., Wahby, R., and C. Wood" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-irtf-cfrg-hash-to-curve-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2019-07-05" />
  <meta name="dct.abstract" content="This document specifies a number of algorithms that may be used to encode or hash an arbitrary string to a point on an elliptic curve." />
  <meta name="description" content="This document specifies a number of algorithms that may be used to encode or hash an arbitrary string to a point on an elliptic curve." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Network Working Group</td>
<td class="right">A. Faz-Hernandez</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Cloudflare</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">S. Scott</td>
</tr>
<tr>
<td class="left">Expires: January 6, 2020</td>
<td class="right">Cornell Tech</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">N. Sullivan</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Cloudflare</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">R. Wahby</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Stanford University</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">C. Wood</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Apple Inc.</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">July 05, 2019</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Hashing to Elliptic Curves<br />
  <span class="filename">draft-irtf-cfrg-hash-to-curve-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document specifies a number of algorithms that may be used to encode or hash an arbitrary string to a point on an elliptic curve.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on January 6, 2020.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2019 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Requirements</a>
</li>
</ul><li>2.   <a href="#rfc.section.2">Background</a>
</li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Elliptic curves</a>
</li>
<li>2.2.   <a href="#rfc.section.2.2">Terminology</a>
</li>
<ul><li>2.2.1.   <a href="#rfc.section.2.2.1">Mappings</a>
</li>
<li>2.2.2.   <a href="#rfc.section.2.2.2">Encodings</a>
</li>
<li>2.2.3.   <a href="#rfc.section.2.2.3">Random oracle encodings</a>
</li>
<li>2.2.4.   <a href="#rfc.section.2.2.4">Serialization</a>
</li>
<li>2.2.5.   <a href="#rfc.section.2.2.5">Domain separation</a>
</li>
</ul></ul><li>3.   <a href="#rfc.section.3">Roadmap</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Domain separation requirements</a>
</li>
</ul><li>4.   <a href="#rfc.section.4">Utility Functions</a>
</li>
<li>5.   <a href="#rfc.section.5">Hashing to a Finite Field</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Security considerations</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Performance considerations</a>
</li>
<li>5.3.   <a href="#rfc.section.5.3">Implementation</a>
</li>
</ul><li>6.   <a href="#rfc.section.6">Deterministic Mappings</a>
</li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Interface</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">Notation</a>
</li>
<li>6.3.   <a href="#rfc.section.6.3">Sign of the resulting point</a>
</li>
<li>6.4.   <a href="#rfc.section.6.4">Exceptional cases</a>
</li>
<li>6.5.   <a href="#rfc.section.6.5">Mappings for Weierstrass curves</a>
</li>
<ul><li>6.5.1.   <a href="#rfc.section.6.5.1">Icart Method</a>
</li>
<li>6.5.2.   <a href="#rfc.section.6.5.2">Simplified Shallue-van de Woestijne-Ulas Method</a>
</li>
</ul><li>6.6.   <a href="#rfc.section.6.6">Mappings for Montgomery curves</a>
</li>
<ul><li>6.6.1.   <a href="#rfc.section.6.6.1">Elligator 2 Method</a>
</li>
</ul><li>6.7.   <a href="#rfc.section.6.7">Mappings for Twisted Edwards curves</a>
</li>
<ul><li>6.7.1.   <a href="#rfc.section.6.7.1">Rational maps from Montgomery to twisted Edwards curves</a>
</li>
<li>6.7.2.   <a href="#rfc.section.6.7.2">Elligator 2 Method</a>
</li>
</ul><li>6.8.   <a href="#rfc.section.6.8">Mappings for Supersingular curves</a>
</li>
<ul><li>6.8.1.   <a href="#rfc.section.6.8.1">Boneh-Franklin Method</a>
</li>
<li>6.8.2.   <a href="#rfc.section.6.8.2">Elligator 2, A == 0 Method</a>
</li>
</ul><li>6.9.   <a href="#rfc.section.6.9">Mappings for Pairing-Friendly curves</a>
</li>
<ul><li>6.9.1.   <a href="#rfc.section.6.9.1">Shallue-van de Woestijne Method</a>
</li>
<li>6.9.2.   <a href="#rfc.section.6.9.2">Simplified SWU for Pairing-Friendly Curves</a>
</li>
</ul></ul><li>7.   <a href="#rfc.section.7">Clearing the cofactor</a>
</li>
<li>8.   <a href="#rfc.section.8">Suites for Hashing</a>
</li>
<li>9.   <a href="#rfc.section.9">IANA Considerations</a>
</li>
<li>10.   <a href="#rfc.section.10">Security Considerations</a>
</li>
<li>11.   <a href="#rfc.section.11">Acknowledgements</a>
</li>
<li>12.   <a href="#rfc.section.12">Contributors</a>
</li>
<li>13.   <a href="#rfc.references">References</a>
</li>
<ul><li>13.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>13.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Related Work</a>
</li>
<li>Appendix B.   <a href="#rfc.appendix.B">Rational maps from twisted Edwards to Weierstrass and Montgomery curves</a>
</li>
<li>Appendix C.   <a href="#rfc.appendix.C">Sample Code</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">Many cryptographic protocols require a procedure that encodes an arbitrary input, e.g., a password, to a point on an elliptic curve. This procedure is known as hashing to an elliptic curve. Prominent examples of cryptosystems that hash to elliptic curves include Simple Password Exponential Key Exchange <a href="#J96" class="xref">[J96]</a>, Password Authenticated Key Exchange <a href="#BMP00" class="xref">[BMP00]</a>, Identity-Based Encryption <a href="#BF01" class="xref">[BF01]</a> and Boneh-Lynn-Shacham signatures <a href="#BLS01" class="xref">[BLS01]</a>.</p>
<p id="rfc.section.1.p.2">Unfortunately for implementors, the precise hash function that is suitable for a given scheme is not necessarily included in the description of the protocol.  Compounding this problem is the need to pick a suitable curve for the specific protocol.</p>
<p id="rfc.section.1.p.3">This document aims to bridge this gap by providing a thorough set of recommended algorithms for a range of curve types.  Each algorithm conforms to a common interface: it takes as input an arbitrary-length bit string and produces as output a point on an elliptic curve.  We provide implementation details for each algorithm, describe the security rationale behind each recommendation, and give guidance for elliptic curves that are not explicitly covered.</p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> <a href="#requirements" id="requirements">Requirements</a>
</h1>
<p id="rfc.section.1.1.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in <a href="#RFC2119" class="xref">[RFC2119]</a>.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#background" id="background">Background</a>
</h1>
<h1 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> <a href="#bg-curves" id="bg-curves">Elliptic curves</a>
</h1>
<p id="rfc.section.2.1.p.1">The following is a brief definition of elliptic curves, with an emphasis on important parameters and their relation to hashing to curves.  For further reference on elliptic curves, consult <a href="#CFADLNV05" class="xref">[CFADLNV05]</a> or <a href="#W08" class="xref">[W08]</a>.</p>
<p id="rfc.section.2.1.p.2">Let F be the finite field GF(q) of prime characteristic p. In most cases F is a prime field, so q = p. Otherwise, F is a field extension, so q = p^m for an integer m &gt; 1. This document assumes that elements of field extensions are written in a primitive element or polynomial basis, i.e., as of m elements of GF(p) written in ascending order by degree. For example, if q = p^2 and the primitive element basis is {1, i}, then the vector (a, b) corresponds to the element a + b * i.</p>
<p id="rfc.section.2.1.p.3">An elliptic curve E is specified by an equation in two variables and a finite field F. An elliptic curve equation takes one of several standard forms, including (but not limited to) Weierstrass, Montgomery, and Edwards.</p>
<p id="rfc.section.2.1.p.4">The curve E induces an algebraic group whose elements are those points with coordinates (x, y) satisfying the curve equation, and where x and y are elements of F.  This group has order n, meaning that there are n distinct points.  This document uses additive notation for the elliptic curve group operation.</p>
<p id="rfc.section.2.1.p.5">For security reasons, groups of prime order MUST be used. Elliptic curves induce subgroups of prime order. Let G be a subgroup of the curve of prime order r, where n = h * r.  In this equation, h is an integer called the cofactor.  An algorithm that takes as input an arbitrary point on the curve E and produces as output a point in the subgroup G of E is said to &#8220;clear the cofactor.&#8221; Such algorithms are discussed in <a href="#cofactor-clearing" class="xref">Section 7</a>.</p>
<p id="rfc.section.2.1.p.6">Certain hash-to-curve algorithms restrict the form of the curve equation, the characteristic of the field, and/or the parameters of the curve. For each algorithm presented, this document lists the relevant restrictions.</p>
<p id="rfc.section.2.1.p.7">Summary of quantities:</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="center">Symbol</th>
<th class="left">Meaning</th>
<th class="left">Relevance</th>
</tr></thead>
<tbody>
<tr>
<td class="center">F,q,p</td>
<td class="left">Finite field F of characteristic p and #F = q = p^m.</td>
<td class="left">For prime fields, q = p; otherwise, q = p^m and m&gt;1.</td>
</tr>
<tr>
<td class="center">E</td>
<td class="left">Elliptic curve.</td>
<td class="left">E is specified by an equation and a field F.</td>
</tr>
<tr>
<td class="center">n</td>
<td class="left">Number of points on the elliptic curve E.</td>
<td class="left">n = h * r, for h and r defined below.</td>
</tr>
<tr>
<td class="center">G</td>
<td class="left">A subgroup of the elliptic curve.</td>
<td class="left">Destination group to which bit strings are encoded.</td>
</tr>
<tr>
<td class="center">r</td>
<td class="left">Order of G.</td>
<td class="left">This number MUST be prime.</td>
</tr>
<tr>
<td class="center">h</td>
<td class="left">Cofactor, h &gt;= 1.</td>
<td class="left">An integer satisfying n = h * r.</td>
</tr>
</tbody>
</table>
<h1 id="rfc.section.2.2">
<a href="#rfc.section.2.2">2.2.</a> <a href="#terminology" id="terminology">Terminology</a>
</h1>
<p id="rfc.section.2.2.p.1">In this section, we define important terms used in the rest of this document.</p>
<h1 id="rfc.section.2.2.1">
<a href="#rfc.section.2.2.1">2.2.1.</a> <a href="#term-mapping" id="term-mapping">Mappings</a>
</h1>
<p id="rfc.section.2.2.1.p.1">A mapping is a deterministic function from an element of the field F to a point on an elliptic curve E defined over F.</p>
<p id="rfc.section.2.2.1.p.2">In general, the set of all points that a mapping can produce over all possible inputs may be only a subset of the points on an elliptic curve (i.e., the mapping may not be surjective).  In addition, a mapping may output the same point for two or more distinct inputs (i.e., the mapping may not be injective).  For example, consider a mapping from F to an elliptic curve having n points: if the number of elements of F is not equal to n, then this mapping cannot be bijective (i.e., both injective and surjective) since it is defined to be deterministic.</p>
<p id="rfc.section.2.2.1.p.3">Mappings may also be invertible, meaning that there is an efficient algorithm that, for any point P output by the mapping, outputs an x in F such that applying the mapping to x outputs P.  Some of the mappings given in <a href="#mappings" class="xref">Section 6</a> are invertible, but this document does not discuss inversion algorithms.</p>
<h1 id="rfc.section.2.2.2">
<a href="#rfc.section.2.2.2">2.2.2.</a> <a href="#term-encoding" id="term-encoding">Encodings</a>
</h1>
<p id="rfc.section.2.2.2.p.1">Encodings are closely related to mappings.  Like a mapping, an encoding is a function that outputs a point on an elliptic curve.  In contrast to a mapping, however, the input to an encoding is an arbitrary bit string.  Encodings can be deterministic or probabilistic.  Deterministic encodings are preferred for security, because probabilistic ones can leak information through side channels.</p>
<p id="rfc.section.2.2.2.p.2">This document constructs deterministic encodings by composing a hash function H with a deterministic mapping.  In particular, H takes as input an arbitrary bit string and outputs an element of F.  The deterministic mapping takes that element as input and outputs a point on an elliptic curve E defined over F.  Since the hash function H takes arbitrary bit strings as inputs, it cannot be injective: the set of inputs is larger than the set of outputs, so there must be distinct inputs that give the same output (i.e., there must be collisions).  Thus, any encoding built from H is also not injective.</p>
<p id="rfc.section.2.2.2.p.3">Like mappings, encodings may be invertible, meaning that there is an efficient algorithm that, for any point P output by the encoding, outputs a bit string s such that applying the encoding to s outputs P.  The hash function used by all encodings specified in this document (<a href="#hashtobase" class="xref">Section 5</a>) is not invertible; thus, the encodings are also not invertible.</p>
<h1 id="rfc.section.2.2.3">
<a href="#rfc.section.2.2.3">2.2.3.</a> <a href="#term-rom" id="term-rom">Random oracle encodings</a>
</h1>
<p id="rfc.section.2.2.3.p.1">Two different types of encodings are possible: nonuniform encodings, whose output distribution is not uniformly random, and random oracle encodings, whose output distribution is indistinguishable from uniformly random.  Some protocols require a random oracle for security, while others can be securely instantiated with a nonuniform encoding.  When the required encoding is not clear, applications SHOULD use a random oracle.</p>
<p id="rfc.section.2.2.3.p.2">Care is required when constructing a random oracle from a mapping function.  A simple but insecure approach is to use the output of a cryptographically secure hash function H as the input to the mapping.  Because in general the mapping is not surjective, the output of this construction is distinguishable from uniformly random, i.e., it does not behave like a random oracle.</p>
<p id="rfc.section.2.2.3.p.3">Brier et al. <a href="#BCIMRT10" class="xref">[BCIMRT10]</a> describe two generic constructions whose outputs are indistinguishable from a random oracle. Farashahi et al. <a href="#FFSTV13" class="xref">[FFSTV13]</a> and Tibouchi and Kim <a href="#TK17" class="xref">[TK17]</a> refine the analysis of one of these constructions.  That construction is described in <a href="#roadmap" class="xref">Section 3</a>.</p>
<h1 id="rfc.section.2.2.4">
<a href="#rfc.section.2.2.4">2.2.4.</a> <a href="#term-serialization" id="term-serialization">Serialization</a>
</h1>
<p id="rfc.section.2.2.4.p.1">A procedure related to encoding is the conversion of an elliptic curve point to a bit string.  This is called serialization, and is typically used for compactly storing or transmitting points.  For example, <a href="#SECG1" class="xref">[SECG1]</a> gives a standard method for serializing points.  The reverse operation, deserialization, converts a bit string to an elliptic curve point.</p>
<p id="rfc.section.2.2.4.p.2">Deserialization is different from encoding in that only certain strings (namely, those output by the serialization procedure) can be deserialized.  In contrast, this document is concerned with encodings from arbitrary bit strings to elliptic curve points.  This document does not cover serialization or deserialization.</p>
<h1 id="rfc.section.2.2.5">
<a href="#rfc.section.2.2.5">2.2.5.</a> <a href="#term-domain-separation" id="term-domain-separation">Domain separation</a>
</h1>
<p id="rfc.section.2.2.5.p.1">Cryptographic protocols that use random oracles are often analyzed under the assumption that random oracles answer only queries generated by that protocol.  In practice, this assumption does not hold if two protocols query the same random oracle.  Concretely, consider protocols P1 and P2 that query random oracle R: if P1 and P2 both query R on the same value x, the security analysis of one or both protocols may be invalidated.</p>
<p id="rfc.section.2.2.5.p.2">A common approach to addressing this issue is called domain separation, which allows a single random oracle to simulate multiple, independent oracles.  This is effected by ensuring that each simulated oracle sees queries that are distinct from those seen by all other simulated oracles.  For example, to simulate two oracles R1 and R2 given a single oracle R, one might define</p>
<pre>
R1(x) := R("R1" || x)
R2(x) := R("R2" || x)
</pre>
<p id="rfc.section.2.2.5.p.3">In this example, &#8220;R1&#8221; and &#8220;R2&#8221; are called domain separation tags; they ensure that queries to R1 and R2 cannot result in identical queries to R.  Thus, it is safe to treat R1 and R2 as independent oracles.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#roadmap" id="roadmap">Roadmap</a>
</h1>
<p id="rfc.section.3.p.1">This section presents a general framework for encoding bit strings to points on an elliptic curve. To construct these encodings, we rely on three basic functions:</p>
<p></p>

<ul>
<li>The function hash_to_base, {0, 1}^* -&gt; F, hashes arbitrary-length bit strings to elements of a finite field; its implementation is defined in <a href="#hashtobase" class="xref">Section 5</a>.</li>
<li>The function map_to_curve, F -&gt; E, calculates a point on the elliptic curve E from an element of the finite field F over which E is defined.  <a href="#mappings" class="xref">Section 6</a> describes mappings for a range of curve families.</li>
<li>The function clear_cofactor, E -&gt; G, sends any point on the curve E to the subgroup G of E. <a href="#cofactor-clearing" class="xref">Section 7</a> describes methods to perform this operation.</li>
</ul>
<p id="rfc.section.3.p.3">We describe two high-level encoding functions (<a href="#term-encoding" class="xref">Section 2.2.2</a>).  Although these functions have the same interface, the distributions of their outputs are different.</p>
<p></p>

<ul><li>Nonuniform encoding (encode_to_curve). This function encodes bit strings to points in G.  The distribution of the output is not uniformly random in G.</li></ul>
<pre>
encode_to_curve(alpha)

Input: alpha, an arbitrary-length bit string.
Output: P, a point in G.

Steps:
1. u = hash_to_base(alpha, 2)
2. Q = map_to_curve(u)
3. P = clear_cofactor(Q)
4. return P
</pre>
<p></p>

<ul><li>Random oracle encoding (hash_to_curve). This function encodes bit strings to points in G.  The distribution of the output is indistinguishable from uniformly random in G provided that map_to_curve is &#8220;well distributed&#8221; (<a href="#FFSTV13" class="xref">[FFSTV13]</a>, Def. 1).  All of the map_to_curve functions defined in <a href="#mappings" class="xref">Section 6</a> meet this requirement.</li></ul>
<pre>
hash_to_curve(alpha)

Input: alpha, an arbitrary-length bit string.
Output: P, a point in G.

Steps:
1. u0 = hash_to_base(alpha, 0)
2. u1 = hash_to_base(alpha, 1)
3. Q0 = map_to_curve(u0)
4. Q1 = map_to_curve(u1)
5. R = Q0 + Q1
6. P = clear_cofactor(R)
7. return P
</pre>
<p id="rfc.section.3.p.6">Instances of these functions are given in <a href="#suites" class="xref">Section 8</a>, which defines a list of suites that specify a full set of parameters matching elliptic curves and algorithms.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#domain-separation" id="domain-separation">Domain separation requirements</a>
</h1>
<p id="rfc.section.3.1.p.1">When invoking hash_to_curve from a higher-level protocol, implementors MUST use domain separation (<a href="#term-domain-separation" class="xref">Section 2.2.5</a>) to avoid interfering with other protocols that also use the hash_to_curve functionality.  Protocols that use encode_to_curve SHOULD use domain separation if possible, though it is not required in this case.</p>
<p id="rfc.section.3.1.p.2">Protocols that instantiate multiple, independent random oracles based on hash_to_curve MUST enforce domain separation between those oracles.  This requirement applies both in the case of multiple oracles to the same curve and in the case of multiple oracles to different curves.  This is because the hash_to_base primitive (<a href="#hashtobase" class="xref">Section 5</a>) requires domain separation to guarantee independent outputs.</p>
<p id="rfc.section.3.1.p.3">Care is required when choosing a domain separation tag.  Implementors SHOULD observe the following guidelines:</p>
<p></p>

<ol>
<li>Tags should be prepended to the value being hashed, as in the example in <a href="#term-domain-separation" class="xref">Section 2.2.5</a>.</li>
<li>Tags should have fixed length, or should be encoded in a way that makes the length of a given tag unambiguous.  If a variable-length tag is used, it should be prefixed with a fixed-length field that encodes the length of the tag.</li>
<li>Tags should begin with a fixed protocol identification string.  Ideally, this identification string should be unique to the protocol.</li>
<li>Tags should include a protocol version number.</li>
<li>For protocols that support multiple ciphersuites, tags should include a ciphersuite identifier.</li>
</ol>
<p id="rfc.section.3.1.p.5">As an example, consider a fictional key exchange protocol named Quux.  A reasonable choice of tag is &#8220;QUUX-V&lt;xx&gt;-CS&lt;yy&gt;&#8221;, where &lt;xx&gt; and &lt;yy&gt; are two-digit numbers indicating the version and ciphersuite, respectively.  Alternatively, if a variable-length ciphersuite string must be used, a reasonable choice of tag is &#8220;QUUX-V&lt;xx&gt;-L&lt;zz&gt;-&lt;csid&gt;&#8221;, where where &lt;csid&gt; is a the ciphersuite string, and &lt;xx&gt; and &lt;zz&gt; are two-digit numbers indicating the version and the length of the ciphersuite string, respectively.</p>
<p id="rfc.section.3.1.p.6">As another example, consider a fictional protocol named Baz that requires two independent random oracles, where one oracle outputs points on the curve E1 and the other outputs points on the curve E2.  To ensure that these two random oracles are independent, each one must be called with a distinct domain separation tag.  Reasonable choices of tags for the E1 and E2 oracles are &#8220;BAZ-V&lt;xx&gt;-CS&lt;yy&gt;-E1&#8221; and &#8220;BAZ-V&lt;xx&gt;-CS&lt;yy&gt;-E2&#8221;, respectively, where &lt;xx&gt; and &lt;yy&gt; are as defined above.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#utility" id="utility">Utility Functions</a>
</h1>
<p id="rfc.section.4.p.1">Algorithms in this document make use of utility functions described below.</p>
<p></p>

<ul>
<li>CMOV(a, b, c): If c == 0, CMOV returns a, otherwise returns b. To prevent against timing attacks, this operation must run in constant time without revealing the value of c. Commonly, implementations assume that the selector is c == 1 or c == 0. In this case, given a bit string C, the desired selector c can be computed by OR-ing all bits of C together. The resulting selector will be either 0 if all bits of C are zero, or 1 if at least one bit of C is 1.</li>
<li>is_square(x, q): This function returns True whenever the value x is a square in GF(q). Due to Euler&#8217;s criterion, this function can be calculated in constant time as</li>
</ul>
<pre>
is_square(x, q) := { True,  if x^((q - 1) / 2) is 0 or 1;
                   { False, otherwise.
</pre>
<p></p>

<ul><li>sqrt(x, q): The sqrt operation is a multi-valued function, i.e. there exist two roots of x whenever x is square.  To maintain compatibility across implementations while allowing implementors leeway for optimizations, this document does not require sqrt() to return a particular value. Instead, as explained in <a href="#point-sign" class="xref">Section 6.3</a>, any higher-level function that computes square roots also specifies how to determine the sign of the result.  <br><br> The preferred way of computing square roots is to fix a deterministic algorithm particular to q. We give algorithms for the three most common cases immediately below; other cases are analogous.  <br><br> Note that Case 3 below applies to GF(p^2) when p = 3 mod 8.  <a href="#AR13" class="xref">[AR13]</a> and <a href="#S85" class="xref">[S85]</a> describe methods that work for other field extensions.  Regardless of the method chosen, the sqrt function MUST be performed in constant time.</li></ul>
<pre>
s = sqrt(x, q)

Input: x, an element of F.
Output: s, an element of F such that s * s = x.

======

Case 1: q = 3 (mod 4)

Procedure:
1. return x^((q + 1) / 4)

======

Case 2: q = 5 (mod 8)

Constants:
1. c1 = sqrt(-1) in F, i.e., c1 * c1 = -1 mod q.

Procedure:
1. t1 = x^((q + 3) / 8)
2. e  = t1 * t1 == x
3. s  = CMOV(t1 * c1, t1, e)
3. return s

======

Case 3: q = 9 (mod 16)

Constants:
1. c1 = sqrt(-1) in F, i.e., c1 * c1 = -1 mod q.
2. c2 = sqrt(sqrt(-1)) in F, i.e., c2 * c2 = c1 mod q.
3. c3 = sqrt(-sqrt(-1)) in F, i.e., c3 * c3 = -c1 mod q.

Procedure:
1.  t1 = x^((q + 7) / 16)
2.  t2 = c1 * t1
3.  t3 = c2 * t1
4.  t4 = c3 * t1
5.  e1 = t2 * t2 == x
6.  e2 = t3 * t3 == x
7.  t1 = CMOV(t1, t2, e1)  // select t2 if t2 * t2 == x
8.  t2 = CMOV(t4, t3, e2)  // select t3 if t3 * t3 == x
9.  e3 = t2 * t2 == x
10. s  = CMOV(t1, t2, e3)  // select the sqrt from t1 and t2
11. return s
</pre>
<p></p>

<ul><li>sgn0(x): This function returns either +1 or -1, indicating the sign of x.  This function considers 0 to be positive.  The following procedure implements sgn0(x) in constant time.  See <a href="#bg-curves" class="xref">Section 2.1</a> for a discussion of representing x as a vector.</li></ul>
<pre>
sgn0(x)

Parameters:
  1. F, a finite field of characteristic p and order q = p^m, m &gt;= 1.
Input: x, an element of F.
Output: -1 or 1.

Notation: x_i is the i^th element of the vector representation of x.

Steps:
1. sign = 0
2. for i in (m, m - 1, ..., 1):
3.   sign_i = CMOV(1, -1, x_i &gt; (p - 1) / 2)
4.   sign_i = CMOV(sign_i, 0, x_i == 0)
5.   sign = CMOV(sign, sign_i, sign == 0)
6. return CMOV(sign, 1, sign == 0)    # regard x = 0 as positive
</pre>
<p></p>

<ul>
<li>inv0(x, q): This function returns the multiplicative inverse of x mod q, extended to all of F by fixing inv0(0) == 0.  To implement inv0 in constant time, compute alpha = x^(q - 2) mod q.  Notice on input 0, the output is 0 as required.</li>
<li>I2OSP and OS2IP: These functions are used to convert an octet string to and from a non-negative integer as described in <a href="#RFC8017" class="xref">[RFC8017]</a>.</li>
<li>a || b: denotes the concatenation of bit strings a and b.</li>
</ul>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#hashtobase" id="hashtobase">Hashing to a Finite Field</a>
</h1>
<p id="rfc.section.5.p.1">The hash_to_base(msg) function hashes a string msg of any length into an element of a field F. This function is parametrized by the field F (<a href="#bg-curves" class="xref">Section 2.1</a>) and by H, a cryptographic hash function that outputs b bits.</p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#hashtobase-sec" id="hashtobase-sec">Security considerations</a>
</h1>
<p id="rfc.section.5.1.p.1">For security, hash_to_base should be collision resistant and its output distribution should be uniform over F. To this end, hash_to_base requires a cryptographic hash function H which satisfies the following properties:</p>
<p></p>

<ol>
<li>The number of bits output by H should be b &gt;= 2 * k for sufficient collision resistance, where k is the target security level in bits. (This is needed for a birthday bound of approximately 2^(-k).)</li>
<li>H is modeled as a random oracle, so its output must be indistinguishable from a uniformly random bit string.</li>
</ol>
<p id="rfc.section.5.1.p.3">For example, for 128-bit security, b &gt;= 256 bits; in this case, SHA256 would be an appropriate choice for H.</p>
<p id="rfc.section.5.1.p.4">Ensuring that the hash_to_base output is a uniform random element of F requires care, even when H outputs a uniformly random string. For example, if H is SHA256 and F is a field of characteristic p = 2^255 - 19, then the result of reducing H(msg) (a 256-bit integer) modulo p is slightly more likely to be in [0, 38] than if the value were selected uniformly at random.  In this example the bias is negligible, but in general it can be significant.</p>
<p id="rfc.section.5.1.p.5">To control bias, the input msg should be hashed to an integer comprising at least ceil(log2(p)) + k bits; reducing this integer modulo p gives bias at most 2^-k, which is a safe choice for a cryptosystem with k-bit security.  To obtain such an integer, hash H with b-bit output should be evaluated W = ceil((ceil(log2(p)) + k) / b) times and the results concatenated to produce a (W * b)-bit integer. For example, for H = SHA256, k = 128-bit security, and p a 256-bit prime, W = ceil((256 + 128) / 256) = 2.</p>
<p><a href="#hashtobase-impl" class="xref">Section 5.3</a> details the hash_to_base procedure.</p>
<p id="rfc.section.5.1.p.7">Note that implementors SHOULD NOT use rejection sampling to generate a uniformly random element of F.  The reason is that these procedures are difficult to implement in constant time, and later well-meaning &#8220;optimizations&#8221; may silently render an implementation non-constant-time.</p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#hashtobase-perf" id="hashtobase-perf">Performance considerations</a>
</h1>
<p id="rfc.section.5.2.p.1">Since hash_to_base may invoke H multiple times (<a href="#hashtobase-sec" class="xref">Section 5.1</a>), its performance may be limited by the length of the input msg.  To address this, hash_to_base first computes H(msg) and then derives the required bits from this value via further invocations of H.  For short messages this entails one extra invocation of H, which is a negligible overhead in the context of hashing to elliptic curves.</p>
<p id="rfc.section.5.2.p.2">A related issue is that the random oracle construction of <a href="#term-rom" class="xref">Section 2.2.3</a> requires evaluating two independent hash functions H0 and H1 on msg.  A standard way to instantiate independent hashes is to append a counter to the value being hashed, e.g., H(msg || 0) and H(msg || 1).  If msg is long, however, this is either inefficient (because it entails hashing msg twice) or requires non-black-box use of H (e.g., partial evaluation).</p>
<p id="rfc.section.5.2.p.3">To sidestep both of these issues, hash_to_base takes a second argument, ctr, which it appends to H(msg) rather than to msg.  This means that two invocations of hash_to_base on the same msg with different ctr values both start by computing the value H(msg).  This is an improvement because it allows sharing one evaluation of H(msg) among multiple invocations of hash_to_base, by factoring out the common computation.</p>
<h1 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> <a href="#hashtobase-impl" id="hashtobase-impl">Implementation</a>
</h1>
<p id="rfc.section.5.3.p.1">The following procedure implements hash_to_base.</p>
<pre>
hash_to_base(msg, ctr)

Parameters:
- H, a cryptographic hash function producing b bits.
- F, a finite field of characteristic p and order q = p^m.
- W = ceil((ceil(log2(p)) + k) / b), where k is the security
  parameter of the cryptosystem (e.g., k = 128).

Inputs:
- msg is the message to hash.
- ctr is either 0, 1, or 2.
  This is used to efficiently create independent
  instances of hash_to_base (see discussion above).

Output: u, an element in F.

Steps:
1. m' = "HASH-TO-CURVE" || H(msg) || I2OSP(ctr, 1)
2. for i in (1, ..., m):
3.   t = ""     // initialize t to the empty string
4.   for j in (1, ..., W):
5.     t = t || H( m' || I2OSP(i, 1) || I2OSP(j, 1) )
6.   e_i = OS2IP(t) mod p
7. return u = ( e_1, ..., e_m )
</pre>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#mappings" id="mappings">Deterministic Mappings</a>
</h1>
<p id="rfc.section.6.p.1">The mappings in this section are suitable for constructing either nonuniform or random oracle encodings using the constructions of <a href="#roadmap" class="xref">Section 3</a>.</p>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> <a href="#interface" id="interface">Interface</a>
</h1>
<p id="rfc.section.6.1.p.1">The generic interface shared by all mappings in this section is as follows:</p>
<pre>
(x, y) = map_to_curve(u)
</pre>
<p id="rfc.section.6.1.p.2">The input u and outputs x and y are elements of the field F.  The coordinates (x, y) specify a point on an elliptic curve defined over F.  Note that the point (x, y) is not a uniformly random point. If uniformity is required for security, the random oracle construction of <a href="#roadmap" class="xref">Section 3</a> MUST be used instead.</p>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> <a href="#notation" id="notation">Notation</a>
</h1>
<p id="rfc.section.6.2.p.1">As a rough style guide the following convention is used:</p>
<p></p>

<ul>
<li>All arithmetic operations are performed over a field F, unless explicitly stated otherwise.</li>
<li>u: the input to the mapping function.  This is an element of F produced by the hash_to_base function.</li>
<li>(x, y): are the affine coordinates of the point output by the mapping.  Indexed values are used when the algorithm calculates some candidate values.</li>
<li>t1, t2, &#8230;: are reusable temporary variables. For notable variables, distinct names are used easing the debugging process when correlating with test vectors.</li>
<li>c1, c2, &#8230;: are constant values, which can be computed in advance.</li>
</ul>
<h1 id="rfc.section.6.3">
<a href="#rfc.section.6.3">6.3.</a> <a href="#point-sign" id="point-sign">Sign of the resulting point</a>
</h1>
<p id="rfc.section.6.3.p.1">In general, elliptic curves have equations of the form y^2 = g(x).  Most of the mappings in this section first identify an x such that g(x) is square, then take a square root to find y. Since there are two square roots when g(x) != 0, this results in an ambiguity regarding the sign of y.</p>
<p id="rfc.section.6.3.p.2">To resolve this ambiguity, the mappings in this section specify the sign of the y-coordinate in terms of the input to the mapping function.  Two main reasons support this approach. First, this covers elliptic curves over any field in a uniform way, and second, it gives implementors leeway to optimize their square-root implementations.</p>
<h1 id="rfc.section.6.4">
<a href="#rfc.section.6.4">6.4.</a> <a href="#map-exceptions" id="map-exceptions">Exceptional cases</a>
</h1>
<p id="rfc.section.6.4.p.1">Mappings may have have exceptional cases, i.e., inputs u on which the mapping is undefined. These cases must be handled carefully, especially for constant-time implementations.</p>
<p id="rfc.section.6.4.p.2">For each mapping in this section, we discuss the exceptional cases and show how to handle them in constant time. Note that all implementations SHOULD use inv0 (<a href="#utility" class="xref">Section 4</a>) to compute multiplicative inverses, to avoid exceptional cases that result from attempting to compute the inverse of 0.</p>
<h1 id="rfc.section.6.5">
<a href="#rfc.section.6.5">6.5.</a> <a href="#mappings-for-weierstrass-curves" id="mappings-for-weierstrass-curves">Mappings for Weierstrass curves</a>
</h1>
<p id="rfc.section.6.5.p.1">The following mappings apply to elliptic curves defined by the equation E: y^2 = g(x) = x^3 + A * x + B, where 4 * A^3 + 27 * B^2 != 0.</p>
<h1 id="rfc.section.6.5.1">
<a href="#rfc.section.6.5.1">6.5.1.</a> <a href="#icart" id="icart">Icart Method</a>
</h1>
<p id="rfc.section.6.5.1.p.1">The function map_to_curve_icart(u) implements the Icart method from <a href="#Icart09" class="xref">[Icart09]</a>.</p>
<p id="rfc.section.6.5.1.p.2">Preconditions: An elliptic curve over F, such that p&gt;3 and q = p^m = 2 (mod 3), or p = 2 (mod 3) and odd m.</p>
<p id="rfc.section.6.5.1.p.3">Constants: A and B, the parameters of the Weierstrass curve.</p>
<p id="rfc.section.6.5.1.p.4">Sign of y: this mapping does not compute a square root, so there is no ambiguity regarding the sign of y.</p>
<p id="rfc.section.6.5.1.p.5">Exceptions: The only exceptional case is u == 0.  Implementations must detect this case by testing whether u == 0 and setting u = 1 if so.</p>
<p id="rfc.section.6.5.1.p.6">Operations:</p>
<pre>
1. If u == 0, set u = 1
2. v = (3 * A - u^4) / (6 * u)
3. x = (v^2 - B - (u^6 / 27))^((2 * p - 1) / 3) + (u^2 / 3)
4. y = u * x + v
5. return (x, y)
</pre>
<h1 id="rfc.section.6.5.1.1">
<a href="#rfc.section.6.5.1.1">6.5.1.1.</a> <a href="#implementation" id="implementation">Implementation</a>
</h1>
<p id="rfc.section.6.5.1.1.p.1">The following procedure implements Icart&#8217;s algorithm in a straight-line fashion.</p>
<pre>
map_to_curve_icart(u)
Input: u, an element of F.
Output: (x, y), a point on E.

Constants:
1. c1 = (2 * p - 1) / 3   // Integer arithmetic
2. c2 = 1 / 3
3. c3 = c2^3
4. c4 = 3 * A

Steps:
1.   e = u == 0
2.   u = CMOV(u, 1, e)  // handle exceptional case u == 0
3.  u2 = u^2            // u^2
4.  u4 = u2^2           // u^4
5.   v = c4 - u4        // 3 * A - u^4
6.  t1 = 6 * u          // 6 * u
7.  t1 = inv0(t1)       // 1 / (6 * u)
8.   v = v * t1         // v = (3 * A - u^4) / (6 * u)
9.  x1 = v^2            // v^2
10. x1 = x1 - B         // v^2 - B
11. u6 = u4 * c3        // u^4 / 27
12. u6 = u6 * u2        // u^6 / 27
13. x1 = x1 - u6        // v^2 - B - u^6 / 27
14. x1 = x^c1           // (v^2 - B - u^6 / 27)^(1 / 3)
15. t1 = u2 * c2        // u^2 / 3
16.  x = x + t1         // x = (v^2 - B - u^6 / 27)^(1 / 3) + (u^2 / 3)
17.  y = u * x          // u * x
18.  y = y + v          // y = u * x + v
19. return (x, y)
</pre>
<h1 id="rfc.section.6.5.2">
<a href="#rfc.section.6.5.2">6.5.2.</a> <a href="#simple-swu" id="simple-swu">Simplified Shallue-van de Woestijne-Ulas Method</a>
</h1>
<p id="rfc.section.6.5.2.p.1">The function map_to_curve_simple_swu(u) implements a simplification of the Shallue-van de Woestijne-Ulas mapping <a href="#U07" class="xref">[U07]</a> described by Brier et al. <a href="#BCIMRT10" class="xref">[BCIMRT10]</a>, which they call the &#8220;simplified SWU&#8221; map. Wahby and Boneh <a href="#WB19" class="xref">[WB19]</a> generalize this mapping to curves over fields of odd characteristic p &gt; 3.</p>
<p id="rfc.section.6.5.2.p.2">Preconditions: A Weierstrass curve over F such that A != 0 and B != 0.</p>
<p id="rfc.section.6.5.2.p.3">Constants:</p>
<p></p>

<ul>
<li>A and B, the parameters of the Weierstrass curve.</li>
<li>Z, the smallest (in absolute value) non-square in F such that g(B / (Z * A)) is square in F, breaking ties by choosing the positive value.</li>
</ul>
<p id="rfc.section.6.5.2.p.5">Sign of y: Inputs u and -u give the same x-coordinate.  Thus, we set sgn0(y) == sgn0(u).</p>
<p id="rfc.section.6.5.2.p.6">Exceptions: The exceptional cases are values of u such that Z^2 * u^4 + Z * u^2 == 0. This includes u == 0, and may include other values depending on Z. Implementations must detect this case and set x1 = B / (Z * A), which guarantees that g(x1) is square by the condition on Z given above.</p>
<p id="rfc.section.6.5.2.p.7">Operations:</p>
<pre>
1. den = inv0(Z^2 * u^4 + Z * u^2)
2.  x1 = (-B / A) * (1 + den)
3.  If den == 0, set x1 = B / (Z * A)
4. gx1 = x1^3 + A * x1 + B
5.  x2 = Z * u^2 * x1
6. gx2 = x2^3 + A * x2 + B
7.  If gx1 is square, set x = x1 and y = sqrt(gx1)
8.  If gx2 is square, set x = x2 and y = sqrt(gx2)
9.  If sgn0(u) != sgn0(y), set y = -y
10. return (x, y)
</pre>
<h1 id="rfc.section.6.5.2.1">
<a href="#rfc.section.6.5.2.1">6.5.2.1.</a> <a href="#implementation-1" id="implementation-1">Implementation</a>
</h1>
<p id="rfc.section.6.5.2.1.p.1">The following procedure implements the simplified SWU algorithm in a straight-line fashion. This implementation is optimized for the case that q = 3 (mod 4), which applies to P-256.  For discussion of how to generalize to q = 1 (mod 4), see <a href="#WB19" class="xref">[WB19]</a> (Section 4) or the example code found at <a href="#hash2curve-repo" class="xref">[hash2curve-repo]</a>.</p>
<pre>
map_to_curve_simple_swu(u)
Input: u, an element of F.
Output: (x, y), a point on E.

Precondition: q = 3 (mod 4)

Constants:
1.  c1 = -B / A
2.  c2 = -1 / Z
3.  c3 = sqrt(-Z^3)

Steps:
1.   t1 = Z * u^2
2.   t2 = t1^2
3.   x1 = t1 + t2
4.   x1 = inv0(x1)
5.   e1 = x1 == 0
6.   x1 = x1 + 1
7.   x1 = CMOV(x1, c2, e1)   // if (t1 + t2) == 0, set x1 = -1 / Z
8.   x1 = x1 * c1      // x1 = (-B / A) * (1 + (1 / (Z^2 * u^4 + Z * u^2)))
9.  gx1 = x1^2
10. gx1 = gx1 + A
11. gx1 = gx1 * x1
12. gx1 = gx1 + B            // gx1 = g(x1) = x1^3 + A * x1 + B
13.  x2 = t1 * x1            // x2 = Z * u^2 * x1
14.  t3 = gx1^((p + 1) / 4)  // if gx1 is square, this is sqrt(g(x1))
15.  t4 = t3 * c3
16.  t4 = t4 * u^3           // if gx1 is not square, this is sqrt(g(x2))
17.  e3 = t3^2 == gx1
18.   x = CMOV(x2, x1, e3)   // if e2 == True, x = x1, else x = x2
19.   y = CMOV(t4, t3, e3)   // if e2 == True, y = t3, else y = t4
20.  e4 = sgn0(u) == sgn0(y)
21.   y = CMOV(-y, y, e4)
22. return (x, y)
</pre>
<h1 id="rfc.section.6.6">
<a href="#rfc.section.6.6">6.6.</a> <a href="#montgomery" id="montgomery">Mappings for Montgomery curves</a>
</h1>
<p id="rfc.section.6.6.p.1">The mapping defined in <a href="#elligator2" class="xref">Section 6.6.1</a> implements Elligator 2 <a href="#BHKL13" class="xref">[BHKL13]</a> for curves defined by the Weierstrass equation y^2 = x^3 + A * x^2 + B * x, where A * B * (A^2 - 4 * B) != 0 and A^2 - 4 * B is non-square in F.</p>
<p id="rfc.section.6.6.p.2">Such a Weierstrass curve is related to the Montgomery curve B&#8217; * y&#8217;^2 = x&#8217;^3 + A&#8217; * x&#8217;^2 + x&#8217; by the following change of variables:</p>
<p></p>

<ul>
<li>A = A&#8217; / B&#8217;</li>
<li>B = 1 / B&#8217;^2</li>
<li>x = x&#8217; / B&#8217;</li>
<li>y = y&#8217; / B&#8217;</li>
</ul>
<p id="rfc.section.6.6.p.4">The Elligator 2 mapping given below returns a point (x, y) on the Weierstrass curve defined above.  This point can be converted to a point (x&#8217;, y&#8217;) on the original Montgomery curve by computing</p>
<p></p>

<ul>
<li>x&#8217; = B&#8217; * x</li>
<li>y&#8217; = B&#8217; * y</li>
</ul>
<p id="rfc.section.6.6.p.6">Note that when B and B&#8217; are equal to 1, the above two curve equations are identical and no conversion is necessary.  This is the case, for example, for Curve25519 and Curve448 <a href="#RFC7748" class="xref">[RFC7748]</a>.</p>
<h1 id="rfc.section.6.6.1">
<a href="#rfc.section.6.6.1">6.6.1.</a> <a href="#elligator2" id="elligator2">Elligator 2 Method</a>
</h1>
<p id="rfc.section.6.6.1.p.1">Preconditions: A Weierstrass curve y^2 = x^3 + A * x^2 + B * x where A != 0, B != 0, and A^2 - 4 * B is non-zero and non-square in F.</p>
<p id="rfc.section.6.6.1.p.2">Constants:</p>
<p></p>

<ul>
<li>A and B, the parameters of the curve</li>
<li>Z, the smallest (in absolute value) non-square in F, breaking ties by choosing the positive value.</li>
</ul>
<p id="rfc.section.6.6.1.p.4">Sign of y: Inputs u and -u give the same x-coordinate.  Thus, we set sgn0(y) == sgn0(u).</p>
<p id="rfc.section.6.6.1.p.5">Exceptions: The exceptional case is Z * u^2 == -1, i.e., 1 + Z * u^2 == 0.  Implementations must detect this case and set x1 = -A.  Note that this can only happen when q = 3 (mod 4).</p>
<p id="rfc.section.6.6.1.p.6">Operations:</p>
<pre>
1.  x1 = -A * inv0(1 + Z * u^2)
2.  If x1 == 0, set x1 = -A.
3. gx1 = x1^3 + A * x1^2 + B * x1
4.  x2 = -x1 - A
5. gx2 = x2^3 + A * x2^2 + B * x2
6.  If is_square(gx1), set x = x1 and y = sqrt(gx1)
7.  If is_square(gx2), set x = x2 and y = sqrt(gx2)
8.  If sgn0(u) != sgn0(y), set y = -y
9.  return (x, y)
</pre>
<h1 id="rfc.section.6.6.1.1">
<a href="#rfc.section.6.6.1.1">6.6.1.1.</a> <a href="#implementation-q-3-mod-4" id="implementation-q-3-mod-4">Implementation, q = 3 (mod 4)</a>
</h1>
<p id="rfc.section.6.6.1.1.p.1">The following procedure implements Elligator 2 in a straight-line fashion for curves where q = 3 (mod 4), including Curve448.</p>
<pre>
map_to_curve_elligator2_3mod4(u)
Input: u, an element of F.
Output: (x, y), a point on E.

Constants:
1. c1 is Z^((q + 1) / 4) in F.

Steps:
1.   x1 = u^2
2.   x1 = Z * x1
3.   x1 = x1 + 1
4.   x1 = inv0(x1)
5.   e1 = x1 == 0
6.   x1 = CMOV(x1, 1, e1)     // if x1 == 0, set x1 == 1
7.   x1 = -A * x1             // x1 = -A / (1 + Z * u^2)
8.  gx1 = x1 + A
9.  gx1 = gx1 * x1
10. gx1 = gx1 + B
11. gx1 = gx1 * x1            // gx1 = x1^3 + A * x1^2 + B * x1
12.  y1 = gx1^((q + 1) / 4)
13.  x2 = -x1 - A
14.  y2 = y1 * u
15.  y2 = y2 * c1
16.  e2 = y1^2 == gx1
17.   x = CMOV(x2, x1, e2)    // If e == True, x = x1, else x = x2
18.   y = CMOV(y2, y1, e2)    // If e == True, y = y1, else y = y2
19.  e3 = sgn0(u) == sgn0(y)  // fix sign of y
20.   y = CMOV(-y, y, e3)
21. return (x, y)
</pre>
<h1 id="rfc.section.6.6.1.2">
<a href="#rfc.section.6.6.1.2">6.6.1.2.</a> <a href="#implementation-q-5-mod-8" id="implementation-q-5-mod-8">Implementation, q = 5 (mod 8)</a>
</h1>
<p id="rfc.section.6.6.1.2.p.1">The following is a straight-line implementation of Elligator 2 for curves where q = 5 (mod 8), including Curve25519.</p>
<pre>
map_to_curve_elligator2_5mod8(u)
Input: u, an element of F.
Output: (x, y), a point on E.

Constants:
1. c1 is Z^((q + 3) / 8) in F.
2. c2 is sqrt(-1) in F.

Steps:
1.   t1 = u^2
2.   t1 = Z * t1
3.   x1 = t1 + 1
4.   x1 = inv0(x1)            // cannot be 0 because q = 5 mod 8
5.   x1 = -A * x1             // x1 = -A / (1 + Z * u^2)
6.  gx1 = x1 + A
7.  gx1 = gx1 * x1
8.  gx1 = gx1 + B
9.  gx1 = gx1 * x1            // gx1 = x1^3 + A * x1^2 + B * x1
10. y11 = gx1^((q + 3) / 8)
11. y12 = c2 * y11
12.  e1 = y12^2 == gx1
13.  y1 = CMOV(y11, y12, e1)  // if gx1 is square, this is its sqrt
14.  x2 = -x1 - A
15. y21 = y11 * u
16. y21 = y21 * c1
17. y22 = c2 * y21
18. gx2 = t1 * gx1
19.  e2 = y22^2 == gx2
20.  y2 = CMOV(y21, y22, e2)  // if gx2 is square, this is its sqrt
21.  e3 = y1^2 == gx1
22.   x = CMOV(x2, x1, e3)    // if e == True, x = x1, else x = x2
23.   y = CMOV(y2, y1, e3)    // if e == True, y = y1, else y = y2
24.  e4 = sgn0(u) == sgn0(y)  // fix sign of y
25.   y = CMOV(-y, y, e4)
26. return (x, y)
</pre>
<h1 id="rfc.section.6.7">
<a href="#rfc.section.6.7">6.7.</a> <a href="#mappings-for-twisted-edwards-curves" id="mappings-for-twisted-edwards-curves">Mappings for Twisted Edwards curves</a>
</h1>
<p id="rfc.section.6.7.p.1">Twisted Edwards curves (a class of curves that includes Edwards curves) are closely related to Montgomery curves (<a href="#montgomery" class="xref">Section 6.6</a>): every twisted Edwards curve is birationally equivalent to a Montgomery curve (<a href="#BBJLP08" class="xref">[BBJLP08]</a>, Theorem 3.2).  This equivalence yields an efficient way of hashing to a twisted Edwards curve: first, hash to the equivalent Montgomery curve, then transform the result into a point on the twisted Edwards curve via a rational map.  This method of hashing to a twisted Edwards curve thus requires identifying a corresponding Montgomery curve and rational map.  We describe how to identify such a curve and map immediately below.</p>
<h1 id="rfc.section.6.7.1">
<a href="#rfc.section.6.7.1">6.7.1.</a> <a href="#rational-map" id="rational-map">Rational maps from Montgomery to twisted Edwards curves</a>
</h1>
<p id="rfc.section.6.7.1.p.1">There are two ways to identify the correct Montgomery curve and rational map for use when hashing to a given twisted Edwards curve.</p>
<p id="rfc.section.6.7.1.p.2">When hashing to a standardized twisted Edwards curve for which a corresponding Montgomery form and rational map are also standardized, the standard Montgomery form and rational map MUST be used to ensure compatibility with existing software.  Two such standardized curves are the edwards25519 and edwards448 curves, which correspond to the Montgomery curves curve25519 and curve448, respectively.  For both of these curves, <a href="#RFC7748" class="xref">[RFC7748]</a> lists both the Montgomery and twisted Edwards forms and gives the corresponding rational maps.</p>
<p id="rfc.section.6.7.1.p.3">The rational map for edwards25519 (<a href="#RFC7748" class="xref">[RFC7748]</a>, Section 4.1) uses the constant sqrt_neg_486664 = sqrt(-486664) mod 2^255 - 19.  To ensure compatibility, this constant MUST be chosen such that sgn0(sqrt_neg_486664) == 1.  Analogous ambiguities in other standardized rational maps MUST be resolved in the same way: for any constant k whose sign is ambiguous, k MUST be chosen such that sgn0(k) == 1.</p>
<p id="rfc.section.6.7.1.p.4">The 4-isogeny map from curve448 to edwards448 (<a href="#RFC7748" class="xref">[RFC7748]</a>, Section 4.2) is unambiguous with respect to sign.</p>
<p id="rfc.section.6.7.1.p.5">When defining new twisted Edwards curves, a Montgomery equivalent and rational map SHOULD be specified, and the sign of the rational map SHOULD be stated unambiguously.</p>
<p id="rfc.section.6.7.1.p.6">When hashing to a twisted Edwards curve that does not have a standardized Montgomery form or rational map, the following procedure MUST be used to derive them.  For a twisted Edwards curve given by a * x^2 + y^2 = 1 + d * x^2 * y^2, first compute A and B, the parameters of the equivalent curve given by y&#8217;^2 = x&#8217;^3 + A * x&#8217;^2 + B * x&#8217;, as follows:</p>
<p></p>

<ul>
<li>A = (a + d) / 2</li>
<li>B = (a - d)^2 / 16</li>
</ul>
<p id="rfc.section.6.7.1.p.8">Note that the above curve is given in the Weierstrass form required by the Elligator 2 mapping.  The rational map from the point (x&#8217;, y&#8217;) on this Weierstrass curve to the point (x, y) on the twisted Edwards curve is given by</p>
<p></p>

<ul>
<li>x = x&#8217; / y&#8217;</li>
<li>y = (B&#8217; * x&#8217; - 1) / (B&#8217; * x&#8217; + 1), where B&#8217; = 1 / sqrt(B) = 4 / (a - d)</li>
</ul>
<p id="rfc.section.6.7.1.p.10">For completeness, we give the inverse map in <a href="#rational-map-inverse" class="xref">Appendix B</a>.  Note that the inverse map is not used when hashing to a twisted Edwards curve.</p>
<p id="rfc.section.6.7.1.p.11">Rational maps may be undefined, for example, when the denominator of one of the rational functions is zero.  For example, in the map described above, the exceptional cases are y&#8217; == 0 or B&#8217; * x&#8217; == -1.  Implementations MUST detect exceptional cases and return the value (x, y) = (0, 1), which is a valid point on all twisted Edwards curves given by the equation above.</p>
<p id="rfc.section.6.7.1.p.12">The following straight-line implementation of the above rational map handles the exceptional cases.  Implementations of other rational maps (e.g., the ones give in <a href="#RFC7748" class="xref">[RFC7748]</a>) are analogous.</p>
<pre>
rational_map(x', y')
Input: (x', y'), a point on the curve y'^2 = x'^3 + A * x'^2 + B * x'.
Output: (x, y), a point on the equivalent twisted Edwards curve.

1. t1 = y' * B'
2. t2 = x' + 1
3. t3 = t1 * t2
4. t3 = inv0(t3)
5.  x = t2 * t3
6.  x = x * x'
7.  y = x' - 1
8.  y = y * t3
9.  y = y * t1
10. e = y == 0
11. y = CMOV(y, 1, e)
12. return (x, y)
</pre>
<h1 id="rfc.section.6.7.2">
<a href="#rfc.section.6.7.2">6.7.2.</a> <a href="#ell2edwards" id="ell2edwards">Elligator 2 Method</a>
</h1>
<p id="rfc.section.6.7.2.p.1">Preconditions: A twisted Edwards curve E and an equivalent curve M meeting the requirements in <a href="#rational-map" class="xref">Section 6.7.1</a>.</p>
<p id="rfc.section.6.7.2.p.2">Helper functions:</p>
<p></p>

<ul>
<li>map_to_curve_elligator2 is the mapping of <a href="#elligator2" class="xref">Section 6.6.1</a> to the curve M.</li>
<li>rational_map is a function that takes a point (x&#8217;, y&#8217;) on M and returns a point (x, y) on E, as defined in <a href="#rational-map" class="xref">Section 6.7.1</a>.</li>
</ul>
<p id="rfc.section.6.7.2.p.4">Sign of y: for this map, the sign is determined by map_to_curve_elligator2.  No further sign adjustments are required.</p>
<p id="rfc.section.6.7.2.p.5">Exceptions: The exceptions for the Elligator 2 mapping are as given in <a href="#elligator2" class="xref">Section 6.6.1</a>.  The exceptions for the rational map are as given in <a href="#rational-map" class="xref">Section 6.7.1</a>.  No other exceptions are possible.</p>
<p id="rfc.section.6.7.2.p.6">The following procedure implements the Elligator 2 mapping for a twisted Edwards curve.</p>
<pre>
map_to_curve_elligator2_edwards(u)
Input: u, an element of F.
Output: (x, y), a point on E.

1. (x', y') = map_to_curve_elligator2(u)    // (x', y') is on M
2.   (x, y) = rational_map(x', y')          // (x, y) is on E
3. return (x, y)
</pre>
<h1 id="rfc.section.6.8">
<a href="#rfc.section.6.8">6.8.</a> <a href="#mappings-for-supersingular-curves" id="mappings-for-supersingular-curves">Mappings for Supersingular curves</a>
</h1>
<h1 id="rfc.section.6.8.1">
<a href="#rfc.section.6.8.1">6.8.1.</a> <a href="#supersingular" id="supersingular">Boneh-Franklin Method</a>
</h1>
<p id="rfc.section.6.8.1.p.1">The function map_to_curve_bf(u) implements the Boneh-Franklin method <a href="#BF01" class="xref">[BF01]</a> which covers the supersingular curves defined by y^2 = x^3 + B over a field F such that q = 2 (mod 3).</p>
<p id="rfc.section.6.8.1.p.2">Preconditions: A supersingular curve over F such that q = 2 (mod 3).</p>
<p id="rfc.section.6.8.1.p.3">Constants: B, the parameter of the supersingular curve.</p>
<p id="rfc.section.6.8.1.p.4">Sign of y: determined by sign of u. No adjustments are necessary.</p>
<p id="rfc.section.6.8.1.p.5">Exceptions: none.</p>
<p id="rfc.section.6.8.1.p.6">Operations:</p>
<pre>
1. x = (u^2 - B)^((2 * q - 1) / 3)
2. y = u
3. return (x, y)
</pre>
<h1 id="rfc.section.6.8.1.1">
<a href="#rfc.section.6.8.1.1">6.8.1.1.</a> <a href="#implementation-2" id="implementation-2">Implementation</a>
</h1>
<p id="rfc.section.6.8.1.1.p.1">The following procedure implements the Boneh-Franklin&#8217;s algorithm in a straight-line fashion.</p>
<pre>
map_to_curve_bf(u)
Input: u, an element of F.
Output: (x, y), a point on E.

Constants:
1. c1 = (2 * q - 1) / 3   // Integer arithmetic

Steps:
1. t1 = u^2
2. t1 = t1 - B
3.  x = t1^c1             // x = (u^2 - B)^((2 * q - 1) / 3)
4.  y = u
5. return (x, y)
</pre>
<h1 id="rfc.section.6.8.2">
<a href="#rfc.section.6.8.2">6.8.2.</a> <a href="#elligator-2-a-0-method" id="elligator-2-a-0-method">Elligator 2, A == 0 Method</a>
</h1>
<p id="rfc.section.6.8.2.p.1">The function map_to_curve_ell2A0(u) implements an adaptation of Elligator 2 <a href="#BLMP19" class="xref">[BLMP19]</a> targeting curves given by y^2 = x^3 + B * x over F such that q = 3 (mod 4).</p>
<p id="rfc.section.6.8.2.p.2">Preconditions: A supersingular curve over F such that q = 3 (mod 4).</p>
<p id="rfc.section.6.8.2.p.3">Constants: B, the parameter of the supersingular curve.</p>
<p id="rfc.section.6.8.2.p.4">Sign of y: Inputs u and -u give the same x-coordinate.  Thus, we set sgn0(y) == sgn0(u).</p>
<p id="rfc.section.6.8.2.p.5">Exceptions: none.</p>
<p id="rfc.section.6.8.2.p.6">Operations:</p>
<pre>
1.  x1 = u
2. gx1 = x1^3 + B * x1
3.  x2 = -x1
4. gx2 = x2^3 + B * x2
5. If gx1 is square, x = x1 and y = sqrt(gx1)
6. If gx2 is square, x = x2 and y = sqrt(gx2)
7. If sgn0(u) != sgn0(y), set y = -y.
8. return (x, y)
</pre>
<h1 id="rfc.section.6.8.2.1">
<a href="#rfc.section.6.8.2.1">6.8.2.1.</a> <a href="#implementation-3" id="implementation-3">Implementation</a>
</h1>
<p id="rfc.section.6.8.2.1.p.1">The following procedure implements the Elligator 2 algorithm for supersingular curves in a straight-line fashion.</p>
<pre>
map_to_curve_ell2A0(u)
Input: u, an element of F.
Output: (x, y), a point on E.

Steps:
1.  x1 = u
2.  x2 = -x1
3. gx1 = x1^2
4. gx1 = gx1 + B
5. gx1 = gx1 * x1           // gx1 = x1^3 + B * x1
6.   y = gx1^((p + 1) / 4)  // this is either sqrt(gx1) or sqrt(gx2)
7.  e1 = y^2 == gx1
8.   x = CMOV(x2, x1, e1)
9.  e2 = sgn0(u) == sgn0(y)
10.  y = CMOV(-y, y, e2)
11. return (x, y)
</pre>
<h1 id="rfc.section.6.9">
<a href="#rfc.section.6.9">6.9.</a> <a href="#mappings-for-pairing-friendly-curves" id="mappings-for-pairing-friendly-curves">Mappings for Pairing-Friendly curves</a>
</h1>
<h1 id="rfc.section.6.9.1">
<a href="#rfc.section.6.9.1">6.9.1.</a> <a href="#swpairing" id="swpairing">Shallue-van de Woestijne Method</a>
</h1>
<p id="rfc.section.6.9.1.p.1">Shallue and van de Woestijne <a href="#SW06" class="xref">[SW06]</a> describe a mapping that applies to essentially any elliptic curve. Fouque and Tibouchi <a href="#FT12" class="xref">[FT12]</a> give a concrete set of parameters for this mapping geared toward Barreto-Naehrig pairing-friendly curves <a href="#BN05" class="xref">[BN05]</a>, i.e., curves y^2 = x^3 + B over fields of characteristic q = 1 (mod 3).  Wahby and Boneh <a href="#WB19" class="xref">[WB19]</a> suggest a small generalization of the Fouque-Tibouchi parameters that results in a uniform method for handling exceptional cases.</p>
<p id="rfc.section.6.9.1.p.2">The Shallue-van de Woestijne mapping method covers curves not handled by other methods, e.g., SECP256K1 <a href="#SEC2" class="xref">[SEC2]</a>. It also covers pairing-friendly curves in the BN <a href="#BN05" class="xref">[BN05]</a>, KSS <a href="#KSS08" class="xref">[KSS08]</a>, and BLS <a href="#BLS03" class="xref">[BLS03]</a> families. (Note, however, that the mapping described in <a href="#simple-swu-pairing-friendly" class="xref">Section 6.9.2</a> is faster, when it applies.)</p>
<p id="rfc.section.6.9.1.p.3">Preconditions: An elliptic curve y^2 = g(x) = x^3 + B over F such that q = 1 (mod 3) and B != 0.</p>
<p id="rfc.section.6.9.1.p.4">Constants:</p>
<p></p>

<ul>
<li>B, the parameter of the Weierstrass curve</li>
<li>Z, the smallest (in absolute value) element of F such that g((sqrt(-3 * Z^2) - Z) / 2) is square, breaking ties by choosing the positive value.</li>
</ul>
<p id="rfc.section.6.9.1.p.6">Sign of y: Inputs u and -u give the same x-coordinate.  Thus, we set sgn0(y) == sgn0(u).</p>
<p id="rfc.section.6.9.1.p.7">Exceptions: The exceptional cases for u occur when u^2 * (u^2 + g(Z)) == 0. The restriction on Z given above ensures that implementations that use inv0 to invert this product are exception free.</p>
<p id="rfc.section.6.9.1.p.8">Operations:</p>
<pre>
1. t1 = u^2 + g(Z)
2. t2 = inv0(u^2 * t1)
3. t3 = u^4 * t2 * sqrt(-3 * Z^2)
4. x1 = ((sqrt(-3 * Z^2) - Z) / 2) - t3
5. x2 = t3 - ((sqrt(-3 * Z^2) + Z) / 2)
6. x3 = Z - (t1^3 * t2 / (3 * Z^2))
7.  If g(x1) is square, set x = x1 and y = sqrt(g(x1))
8.  If g(x2) is square, set x = x2 and y = sqrt(g(x2))
9.  If g(x3) is square, set x = x3 and y = sqrt(g(x3))
10. If sgn0(u) != sgn0(y), set y = -y
11. return (x, y)
</pre>
<h1 id="rfc.section.6.9.1.1">
<a href="#rfc.section.6.9.1.1">6.9.1.1.</a> <a href="#implementation-4" id="implementation-4">Implementation</a>
</h1>
<p id="rfc.section.6.9.1.1.p.1">The following procedure implements the Shallue and van de Woestijne method in a straight-line fashion.</p>
<pre>
map_to_curve_svdw(u)
Input: u, an element of F.
Output: (x, y), a point on E.

Constants:
1. c1 = g(Z)
2. c2 = sqrt(-3 * Z^2)
3. c3 = (sqrt(-3 * Z^2) - Z) / 2
4. c4 = (sqrt(-3 * Z^2) + Z) / 2
5. c5 = 1 / (3 * Z^2)

Steps:
1.   t1 = u^2
2.   t2 = t1 + c1           // t2 = u^2 + g(Z)
3.   t3 = t1 * t2
4.   t4 = inv0(t3)          // t4 = 1 / (u^2 * (u^2 + g(Z)))
5.   t3 = t1^2
6.   t3 = t3 * t4
7.   t3 = t3 * c2           // t3 = u^2 * sqrt(-3 * Z^2) / (u^2 + g(Z))
8.   x1 = c3 - t3
9.  gx1 = x1^2
10. gx1 = gx1 * x1
11. gx1 = gx1 + B           // gx1 = x1^3 + B
12.  e1 = is_square(gx1)
13.  x2 = t3 - c4
14. gx2 = x2^2
15. gx2 = gx2 * x2
16. gx2 = gx2 + B           // gx2 = x2^3 + B
17.  e2 = is_square(gx2)
18.  e3 = e1 OR e2          // logical OR
19.  x3 = t2^2
20.  x3 = x3 * t2
21.  x3 = x3 * t4
22.  x3 = x3 * c5
23.  x3 = Z - x3            // Z - (u^2 + g(Z))^2 / (3 Z^2 u^2)
24. gx3 = x3^2
25. gx3 = gx3 * x3
26. gx3 = gx3 + B           // gx3 = x3^3 + B
27.   x = CMOV(x2, x1, e1)  // select x1 if gx1 is square
28.  gx = CMOV(gx2, gx1, e1)
29.   x = CMOV(x3, x, e3)   // select x3 if gx1 and gx2 are not square
30.  gx = CMOV(gx3, gx, e3)
31.   y = sqrt(gx, q)
32.  e4 = sgn0(u) == sgn0(y)
33.   y = CMOV(-y, y, e4)   // select correct sign of y
34. return (x, y)
</pre>
<h1 id="rfc.section.6.9.2">
<a href="#rfc.section.6.9.2">6.9.2.</a> <a href="#simple-swu-pairing-friendly" id="simple-swu-pairing-friendly">Simplified SWU for Pairing-Friendly Curves</a>
</h1>
<p id="rfc.section.6.9.2.p.1">Wahby and Boneh <a href="#WB19" class="xref">[WB19]</a> show how to adapt the simplified SWU mapping to certain Weierstrass curves having either A = 0 or B = 0, one of which is almost always true for pairing-friendly curves. Note that neither case is supported by the mapping of <a href="#simple-swu" class="xref">Section 6.5.2</a>.</p>
<p id="rfc.section.6.9.2.p.2">This method requires finding another elliptic curve</p>
<pre>
E': y^2 = g'(x) = x^3 + A' * x + B'
</pre>
<p id="rfc.section.6.9.2.p.3">that is isogenous to E and has A&#8217; != 0 and B&#8217; != 0.  (One might do this, for example, using <a href="#SAGE" class="xref">[SAGE]</a>; details are beyond the scope of this document.) This isogeny defines a map iso_map(x&#8217;, y&#8217;) that takes as input a point on E&#8217; and produces as output a point on E.</p>
<p id="rfc.section.6.9.2.p.4">Once E&#8217; and iso_map are identified, this mapping is straightforward: on input alpha, first apply the simplified SWU mapping to get a point on E&#8217;, then apply the isogeny map to that point to get a point on E.</p>
<p id="rfc.section.6.9.2.p.5">Preconditions: An elliptic curve E&#8217; with A&#8217; != 0 and B&#8217; != 0 that is isogenous to the target curve E with isogeny map iso_map(x, y) from E&#8217; to E.</p>
<p id="rfc.section.6.9.2.p.6">Helper functions:</p>
<p></p>

<ul>
<li>map_to_curve_simple_swu is the mapping of <a href="#simple-swu" class="xref">Section 6.5.2</a> to E&#8217;</li>
<li>iso_map is the isogeny map from E&#8217; to E</li>
</ul>
<p id="rfc.section.6.9.2.p.8">Sign of y: for this map, the sign is determined by map_to_curve_elligator2.  No further sign adjustments are necessary.</p>
<p id="rfc.section.6.9.2.p.9">Exceptions: map_to_curve_simple_swu handles its exceptional cases.  Exceptional cases of iso_map should return the identity point on E.</p>
<p id="rfc.section.6.9.2.p.10">Operations:</p>
<pre>
1. (x', y') = map_to_curve_simple_swu(u)    // (x', y') is on E'
2.   (x, y) = iso_map(x', y')               // (x, y) is on E
3. return (x, y)
</pre>
<p id="rfc.section.6.9.2.p.11">We do not repeat the sample implementation of <a href="#simple-swu" class="xref">Section 6.5.2</a> here.  See <a href="#hash2curve-repo" class="xref">[hash2curve-repo]</a> or <a href="#WB19" class="xref">[WB19]</a> for details on implementing the isogeny map.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#cofactor-clearing" id="cofactor-clearing">Clearing the cofactor</a>
</h1>
<p id="rfc.section.7.p.1">The mappings of <a href="#mappings" class="xref">Section 6</a> always output a point on the elliptic curve, i.e., a point in a group of order h * r (<a href="#bg-curves" class="xref">Section 2.1</a>). Obtaining a point in G may require a final operation commonly called &#8220;clearing the cofactor,&#8221; which takes as input any point on the curve.</p>
<p id="rfc.section.7.p.2">This operation can always be implemented as a scalar multiplication by h.  For elliptic curves where h = 1, i.e., the curves with a prime number of points, no operation is required. This applies, for example, to the NIST curves P-256, P-384, and P-521 <a href="#FIPS186-4" class="xref">[FIPS186-4]</a>.</p>
<p id="rfc.section.7.p.3">In some cases, it is possible to clear the cofactor via a faster method than scalar multiplication.  For pairing-friendly curves having subgroup G2 over an extension field, Scott et al. <a href="#SBCDBK09" class="xref">[SBCDBK09]</a> describe a method for faster cofactor clearing that exploits an efficiently-computable endomorphism. Fuentes-Castaneda et al. <a href="#FKR11" class="xref">[FKR11]</a> propose an alternative method that is sometimes more efficient.  Budroni and Pintore <a href="#BP18" class="xref">[BP18]</a> give concrete instantiations of these methods for Barreto-Lynn-Scott pairing-friendly curves <a href="#BLS03" class="xref">[BLS03]</a>.</p>
<p id="rfc.section.7.p.4">Wahby and Boneh (<a href="#WB19" class="xref">[WB19]</a>, Section 5) describe a trick due to Scott for faster cofactor clearing on any elliptic curve for which the prime factorization of h and the number of points on the curve meet certain conditions.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#suites" id="suites">Suites for Hashing</a>
</h1>
<p id="rfc.section.8.p.1">The following table lists recommended algorithms for different curves and encodings. To select a suitable algorithm, choose the encoding associated with the target curve. For example, Elligator 2 is the recommended encoding for Curve25519, whereas simplified SWU is the recommended encoding for P-256.  When the hash function is to be used in a protocol whose security is proven in the random oracle model, applications SHOULD use the Random Oracle construction given in <a href="#roadmap" class="xref">Section 3</a>.</p>
<p id="rfc.section.8.p.2">A suite is a bundle of algorithms that provides concrete recommendations for hashing bit strings into points of specific elliptic curve groups. Each suite is a tuple (E, H, f, ROM) such that</p>
<p></p>

<ul>
<li>E, is the elliptic curve group.</li>
<li>H, is the cryptographic hash function used by hash_to_base.</li>
<li>f, is an encoding function compatible with E.</li>
<li>ROM, is a boolean flag indicating whether or not to use the random oracle construction.</li>
</ul>
<p id="rfc.section.8.p.4">This document describes the following set of ciphersuites</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">Suite ID</th>
<th class="left">E</th>
<th class="left">H</th>
<th class="left">f</th>
<th class="left">ROM</th>
</tr></thead>
<tbody>
<tr>
<td class="left">H2C-0001</td>
<td class="left">P256</td>
<td class="left">SHA256</td>
<td class="left">Simplified SWU</td>
<td class="left">True</td>
</tr>
<tr>
<td class="left">H2C-0002</td>
<td class="left">P384</td>
<td class="left">SHA512</td>
<td class="left">Icart</td>
<td class="left">True</td>
</tr>
<tr>
<td class="left">H2C-0003</td>
<td class="left">curve25519</td>
<td class="left">SHA512</td>
<td class="left">Elligator 2</td>
<td class="left">True</td>
</tr>
<tr>
<td class="left">H2C-0004</td>
<td class="left">curve448</td>
<td class="left">SHA512</td>
<td class="left">Elligator 2</td>
<td class="left">True</td>
</tr>
<tr>
<td class="left">H2C-0005</td>
<td class="left">edwards25519</td>
<td class="left">SHA512</td>
<td class="left">Elligator 2</td>
<td class="left">True</td>
</tr>
<tr>
<td class="left">H2C-0006</td>
<td class="left">edwards448</td>
<td class="left">SHA512</td>
<td class="left">Elligator 2</td>
<td class="left">True</td>
</tr>
<tr>
<td class="left">H2C-0007</td>
<td class="left">SECP256K1</td>
<td class="left">SHA512</td>
<td class="left">Shallue-van de Woestijne</td>
<td class="left">True</td>
</tr>
<tr>
<td class="left">H2C-0008</td>
<td class="left">BLS12381</td>
<td class="left">SHA512</td>
<td class="left">Simplified SWU</td>
<td class="left">True</td>
</tr>
</tbody>
</table>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a>
</h1>
<p id="rfc.section.9.p.1">This document has no IANA actions.</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a>
</h1>
<p id="rfc.section.10.p.1">Each encoding function accepts arbitrary input and maps it to a pseudorandom point on the curve.  Directly evaluating the mappings of <a href="#mappings" class="xref">Section 6</a> produces an output that is distinguishable from random.  <a href="#roadmap" class="xref">Section 3</a> shows how to use these mappings to construct a function approximating a random oracle.</p>
<p><a href="#domain-separation" class="xref">Section 3.1</a> describes considerations related to domain separation for random oracle encodings.</p>
<p><a href="#hashtobase" class="xref">Section 5</a> describes considerations for uniformly hashing to field elements.</p>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> <a href="#acknowledgements" id="acknowledgements">Acknowledgements</a>
</h1>
<p id="rfc.section.11.p.1">The authors would like to thank Adam Langley for his detailed writeup up Elligator 2 with Curve25519 <a href="#L13" class="xref">[L13]</a>. We also thank Sean Devlin and Thomas Icart for feedback on earlier versions of this document.</p>
<h1 id="rfc.section.12">
<a href="#rfc.section.12">12.</a> <a href="#contributors" id="contributors">Contributors</a>
</h1>
<p></p>

<ul>
<li>Sharon Goldberg <br> Boston University <br> goldbe@cs.bu.edu</li>
<li>Ela Lee <br> Royal Holloway, University of London <br> Ela.Lee.2010@live.rhul.ac.uk</li>
</ul>
<h1 id="rfc.references">
<a href="#rfc.references">13.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">13.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7748">[RFC7748]</b></td>
<td class="top">
<a>Langley, A.</a>, <a>Hamburg, M.</a> and <a>S. Turner</a>, "<a href="https://tools.ietf.org/html/rfc7748">Elliptic Curves for Security</a>", RFC 7748, DOI 10.17487/RFC7748, January 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8017">[RFC8017]</b></td>
<td class="top">
<a>Moriarty, K.</a>, <a>Kaliski, B.</a>, <a>Jonsson, J.</a> and <a>A. Rusch</a>, "<a href="https://tools.ietf.org/html/rfc8017">PKCS #1: RSA Cryptography Specifications Version 2.2</a>", RFC 8017, DOI 10.17487/RFC8017, November 2016.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">13.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="AFQTZ14">[AFQTZ14]</b></td>
<td class="top">
<a title="Institute of Computing, University of Campinas">Aranha, D.</a>, <a title="Universite de Rennes 1 and Institut Universitaire de France">Fouque, P.</a>, <a title="ENS Rennes">Qian, C.</a>, <a title="NTT Secure Platform Laboratories">Tibouchi, M.</a> and <a title="INRIA">J. Zapalowicz</a>, "<a href="https://doi.org/10.1007/978-3-319-13051-4_2">Binary Elligator squared</a>", In Selected Areas in Cryptography - SAC 2014, pages 20-37, DOI 10.1007/978-3-319-13051-4_2, 2014.</td>
</tr>
<tr>
<td class="reference"><b id="AR13">[AR13]</b></td>
<td class="top">
<a title="ISFA, Universite Claude Bernard Lyon 1, Villeurbanne, France">Adj, G.</a> and <a title="CINVESTAV-IPN, San Pedro Zacatenco, Mexico City, Mexico.">F. Rodriguez-Henriquez</a>, "<a href="https://doi.org/10.1109/TC.2013.145">Square Root Computation over Even Extension Fields</a>", In IEEE Transactions on Computers. vol 63 issue 11, pages 2829-2841, DOI 10.1109/TC.2013.145, November 2014.</td>
</tr>
<tr>
<td class="reference"><b id="BBJLP08">[BBJLP08]</b></td>
<td class="top">
<a title="Department of Computer Science, University of Illinois at Chicago, USA">Bernstein, D.</a>, <a title="Department of Mathematics and Computer Science, Technische Universiteit Eindhoven, The Netherlands">Birkner, P.</a>, <a title="Thomson R&amp;D France">Joye, M.</a>, <a title="Department of Mathematics and Computer Science, Technische Universiteit Eindhoven, The Netherlands">Lange, T.</a> and <a title="Department of Mathematics and Computer Science, Technische Universiteit Eindhoven, The Netherlands">C. Peters</a>, "<a href="https://doi.org/10.1007/978-3-540-68164-9_26">Twisted Edwards curves</a>", In AFRICACRYPT 2008, pages 389-405, DOI 10.1007/978-3-540-68164-9_26, 2008.</td>
</tr>
<tr>
<td class="reference"><b id="BCIMRT10">[BCIMRT10]</b></td>
<td class="top">
<a title="Ingenico">Brier, E.</a>, <a title="Universite du Luxembourg">Coron, J.</a>, <a title="Universite du Luxembourg">Icart, T.</a>, <a title="TELECOM-ParisTech">Madore, D.</a>, <a title="TELECOM-ParisTech">Randriam, H.</a> and <a title="Universite du Luxembourg, Ecole normale superieure">M. Tibouchi</a>, "<a href="https://doi.org/10.1007/978-3-642-14623-7_13">Efficient Indifferentiable Hashing into Ordinary Elliptic Curves</a>", In Advances in Cryptology - CRYPTO 2010, pages 237-254, DOI 10.1007/978-3-642-14623-7_13, 2010.</td>
</tr>
<tr>
<td class="reference"><b id="BF01">[BF01]</b></td>
<td class="top">
<a title="Stanford University">Boneh, D.</a> and <a title="UC Davis">M. Franklin</a>, "<a href="https://doi.org/10.1007/3-540-44647-8_13">Identity-based encryption from the Weil pairing</a>", In Advances in Cryptology - CRYPTO 2001, pages 213-229, DOI 10.1007/3-540-44647-8_13, August 2001.</td>
</tr>
<tr>
<td class="reference"><b id="BHKL13">[BHKL13]</b></td>
<td class="top">
<a title="Department of Computer Science, University of Illinois at Chicago, USA">Bernstein, D.</a>, <a title="Cryptography Research, a division of Rambus, USA">Hamburg, M.</a>, <a title="Privacy &amp; Identity lab, Institute for Computing and Information Sciences, Radboud University Nijmegen, The Netherlands">Krasnova, A.</a> and <a title="Department of Mathematics and Computer Science, Technische Universiteit Eindhoven, The Netherlands">T. Lange</a>, "<a href="https://doi.org/10.1145/2508859.2516734">Elligator: elliptic-curve points indistinguishable from uniform random strings</a>", In Proceedings of the 2013 ACM SIGSAC conference on computer and communications security., pages 967-980, DOI 10.1145/2508859.2516734, November 2013.</td>
</tr>
<tr>
<td class="reference"><b id="BLMP19">[BLMP19]</b></td>
<td class="top">
<a title="Department of Computer Science, University of Illinois at Chicago, USA">Bernstein, D.</a>, <a title="Department of Mathematics and Computer Science, Technische Universiteit Eindhoven, The Netherlands">Lange, T.</a>, <a title="Department of Mathematics and Computer Science, Technische Universiteit Eindhoven, The Netherlands">Martindale, C.</a> and <a title="Department of Mathematics and Computer Science, Technische Universiteit Eindhoven, The Netherlands">L. Panny</a>, "<a href="https://doi.org/10.1007/978-3-030-17656-3">Quantum circuits for the CSIDH: optimizing quantum evaluation of isogenies</a>", In Advances in Cryptology - EUROCRYPT 2019, DOI 10.1007/978-3-030-17656-3, 2019.</td>
</tr>
<tr>
<td class="reference"><b id="BLS01">[BLS01]</b></td>
<td class="top">
<a title="Stanford University">Boneh, D.</a>, <a title="Stanford University">Lynn, B.</a> and <a title="Stanford University">H. Shacham</a>, "<a href="https://doi.org/10.1007/s00145-004-0314-9">Short signatures from the Weil pairing</a>", In Journal of Cryptology, vol 17, pages 297-319, DOI 10.1007/s00145-004-0314-9, July 2004.</td>
</tr>
<tr>
<td class="reference"><b id="BLS03">[BLS03]</b></td>
<td class="top">
<a title="Universidade de Sao Paulo, Brazil">Barreto, P.</a>, <a title="Stanford University">Lynn, B.</a> and <a title="Dublin City University, Ireland">M. Scott</a>, "<a href="https://doi.org/10.1007/3-540-36413-7_19">Constructing Elliptic Curves with Prescribed Embedding Degrees</a>", In Security in Communication Networks, pages 257-267, DOI 10.1007/3-540-36413-7_19, 2003.</td>
</tr>
<tr>
<td class="reference"><b id="BMP00">[BMP00]</b></td>
<td class="top">
<a title="MIT Laboratory for Computer Science">Boyko, V.</a>, <a title="Bell Laboratories, Lucent Technologies">MacKenzie, P.</a> and <a title="Bell Laboratories, Lucent Technologies">S. Patel</a>, "<a href="https://doi.org/10.1007/3-540-45539-6_12">Provably secure password-authenticated key exchange using Diffie-Hellman</a>", In Advances in Cryptology - EUROCRYPT 2000, pages 156-171, DOI 10.1007/3-540-45539-6_12, May 2000.</td>
</tr>
<tr>
<td class="reference"><b id="BN05">[BN05]</b></td>
<td class="top">
<a title="Escola Politecnica, Universidade de Sao Paulo, Sao Paulo, Brazil">Barreto, P.</a> and <a title="Lehrstuhl fur Theoretische Informationstechnik, Rheinisch-Westfalische Technische Hochschule Aachen, Aachen, Germany">M. Naehrig</a>, "<a href="https://doi.org/10.1007/11693383_22">Pairing-Friendly Elliptic Curves of Prime Order</a>", In Selected Areas in Cryptography 2005, pages 319-331, DOI 10.1007/11693383_22, 2006.</td>
</tr>
<tr>
<td class="reference"><b id="BP18">[BP18]</b></td>
<td class="top">
<a title="University of Bergen, Norway and MIRACL Labs, London, England">Budroni, A.</a> and <a title="University of Trento, Italy">F. Pintore</a>, "<a href="https://doi.org/10.1145/3313880.3313884">Hashing to G2 on BLS pairing-friendly curves</a>", In ACM Communications in Computer Algebra, pages 63-66, DOI 10.1145/3313880.3313884, September 2018.</td>
</tr>
<tr>
<td class="reference"><b id="CFADLNV05">[CFADLNV05]</b></td>
<td class="top">
<a>Cohen, H.</a>, <a>Frey, G.</a>, <a>Avanzi, R.</a>, <a>Doche, C.</a>, <a>Lange, T.</a>, <a>Nguyen, K.</a> and <a>F. Vercauteren</a>, "<a href="https://www.crcpress.com/9781584885184">Handbook of Elliptic and Hyperelliptic Curve Cryptography</a>", publisher Chapman and Hall / CRC, ISBN 9781584885184, 2005.</td>
</tr>
<tr>
<td class="reference"><b id="CK11">[CK11]</b></td>
<td class="top">
<a title="Universite Bordeaux">Couveignes, J.</a> and <a title="Universite de Rennes">J. Kammerer</a>, "<a href="https://doi.org/10.1016/j.jsc.2011.11.003">The geometry of flex tangents to a cubic curve and its parameterizations</a>", In Journal of Symbolic Computation, vol 47 issue 3, pages 266-281, DOI 10.1016/j.jsc.2011.11.003, 2012.</td>
</tr>
<tr>
<td class="reference"><b id="F11">[F11]</b></td>
<td class="top">
<a title="Macquarie Universit">Farashahi, R.</a>, "<a href="https://doi.org/10.1007/978-3-642-21969-6_17">Hashing into Hessian curves</a>", In AFRICACRYPT 2011, pages 278-289, DOI 10.1007/978-3-642-21969-6_17, 2011.</td>
</tr>
<tr>
<td class="reference"><b id="FFSTV13">[FFSTV13]</b></td>
<td class="top">
<a title="Macquarie Universit">Farashahi, R.</a>, <a title="Ecole normale superieure">Fouque, P.</a>, <a title="Macquarie Universit">Shparlinski, I.</a>, <a title="Ecole normale superieure">Tibouch, M.</a> and <a title="University of Texas">J. Voloch</a>, "<a href="https://doi.org/10.1090/S0025-5718-2012-02606-8">Indifferentiable deterministic hashing to elliptic and hyperelliptic curves</a>", In Math. Comp. vol 82, pages 491-512, DOI 10.1090/S0025-5718-2012-02606-8, 2013.</td>
</tr>
<tr>
<td class="reference"><b id="FIPS186-4">[FIPS186-4]</b></td>
<td class="top">
<a>National Institute of Standards and Technology (NIST)</a>, "<a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf">FIPS Publication 186-4: Digital Signature Standard</a>", July 2013.</td>
</tr>
<tr>
<td class="reference"><b id="FJT13">[FJT13]</b></td>
<td class="top">
<a title="Ecole Normale Superieure and INRIA Rennes">Fouque, P.</a>, <a title="Sorbonne Universite">Joux, A.</a> and <a title="NTT Secure Platform Laboratories">M. Tibouchi</a>, "<a href="https://doi.org/10.1007/978-3-642-39059-3_14">Injective encodings to elliptic curves</a>", In ACISP 2013, pages 203-218, DOI 10.1007/978-3-642-39059-3_14, 2013.</td>
</tr>
<tr>
<td class="reference"><b id="FKR11">[FKR11]</b></td>
<td class="top">
<a title="Computer Science Department, CINVESTAV-IPN. Mexico">Fuentes-Castaneda, L.</a>, <a title="Dept. Combinatorics &amp; Optimization, University of Waterloo, Canada">Knapp, E.</a> and <a title="Computer Science Department, CINVESTAV-IPN. Mexico">F. Rodriguez-Henriquez</a>, "<a href="https://doi.org/10.1007/978-3-642-28496-0_25">Fast Hashing to G2 on Pairing-Friendly Curves</a>", In Selected Areas in Cryptography, pages 412-430, DOI 10.1007/978-3-642-28496-0_25, 2011.</td>
</tr>
<tr>
<td class="reference"><b id="FSV09">[FSV09]</b></td>
<td class="top">
<a title="Macquarie Universit">Farashahi, R.</a>, <a title="Macquarie Universit">Shparlinski, I.</a> and <a title="University of Texas">J. Voloch</a>, "<a href="https://doi.org/10.1515/JMC.2009.022">On hashing into elliptic curves</a>", In Journal of Mathematical Cryptology, vol 3 no 4, pages 353-360, DOI 10.1515/JMC.2009.022, 2009.</td>
</tr>
<tr>
<td class="reference"><b id="FT10">[FT10]</b></td>
<td class="top">
<a title="Ecole Normale Superieure and INRIA Rennes">Fouque, P.</a> and <a title="NTT Secure Platform Laboratories">M. Tibouchi</a>, "<a href="https://doi.org/10.1007/978-3-642-14712-8_5">Estimating the size of the image of deterministic hash functions to elliptic curves.</a>", In Progress in Cryptology - LATINCRYPT 2010, pages 81-91, DOI 10.1007/978-3-642-14712-8_5, 2010.</td>
</tr>
<tr>
<td class="reference"><b id="FT12">[FT12]</b></td>
<td class="top">
<a title="Ecole Normale Superieure and INRIA Rennes">Fouque, P.</a> and <a title="NTT Secure Platform Laboratories">M. Tibouchi</a>, "<a href="https://doi.org/10.1007/978-3-642-33481-8_1">Indifferentiable Hashing to Barreto-Naehrig Curves</a>", In Progress in Cryptology - LATINCRYPT 2012, pages 1-7, DOI 10.1007/978-3-642-33481-8_1, 2012.</td>
</tr>
<tr>
<td class="reference"><b id="hash2curve-repo">[hash2curve-repo]</b></td>
<td class="top">"<a href="https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve">Hashing to Elliptic Curves - GitHub repository</a>", 2019.</td>
</tr>
<tr>
<td class="reference"><b id="Icart09">[Icart09]</b></td>
<td class="top">
<a title="Sagem Securite and Universite du Luxembourg">Icart, T.</a>, "<a href="https://doi.org/10.1007/978-3-642-03356-8_18">How to Hash into Elliptic Curves</a>", In Advances in Cryptology - CRYPTO 2009, pages 303-316, DOI 10.1007/978-3-642-03356-8_18, 2009.</td>
</tr>
<tr>
<td class="reference"><b id="J96">[J96]</b></td>
<td class="top">
<a title="Integrity Sciences, Inc. Westboro, MA.">Jablon, D.</a>, "<a href="https://doi.org/10.1145/242896.242897">Strong password-only authenticated key exchange</a>", In SIGCOMM Computer Communication Review, vol 26 issue 5, pages 5-26, DOI 10.1145/242896.242897, 1996.</td>
</tr>
<tr>
<td class="reference"><b id="KLR10">[KLR10]</b></td>
<td class="top">
<a title="Universite de Rennes">Kammerer, J.</a>, <a title="Universite de Rennes">Lercier, R.</a> and <a title="Universite Pierre et Marie Curie">G. Renault</a>, "<a href="https://doi.org/10.1007/978-3-642-17455-1_18">Encoding points on hyperelliptic curves over finite fields in deterministic polynomial time</a>", In PAIRING 2010, pages 278-297, DOI 10.1007/978-3-642-17455-1_18, 2010.</td>
</tr>
<tr>
<td class="reference"><b id="KSS08">[KSS08]</b></td>
<td class="top">
<a title="School of Computing, Dublin City University, Ireland">Kachisa, E.</a>, <a title="Department of Mathematics and Computer Science of Santa Clara University, USA">Schaefer, E.</a> and <a title="School of Computing, Dublin City University, Ireland">M. Scott</a>, "<a href="https://doi.org/10.1007/978-3-540-85538-5_9">Constructing Brezing-Weng Pairing-Friendly Elliptic Curves Using Elements in the Cyclotomic Field</a>", In Pairing-Based Cryptography - Pairing 2008, pages 126-135, DOI 10.1007/978-3-540-85538-5_9, 2008.</td>
</tr>
<tr>
<td class="reference"><b id="L13">[L13]</b></td>
<td class="top">
<a>Langley, A.</a>, "<a href="https://www.imperialviolet.org/2013/12/25/elligator.html">Implementing Elligator for Curve25519</a>", 2013.</td>
</tr>
<tr>
<td class="reference"><b id="S05">[S05]</b></td>
<td class="top">
<a title="Department of Mathematics, University of Warsaw">Skalba, M.</a>, "<a href="https://doi.org/10.4064/aa117-3-7">Points on elliptic curves over finite fields</a>", In Acta Arithmetica, vol 117 no 3, pages 293-301, DOI 10.4064/aa117-3-7, 2005.</td>
</tr>
<tr>
<td class="reference"><b id="S85">[S85]</b></td>
<td class="top">
<a>Schoof, R.</a>, "<a href="https://doi.org/10.1090/S0025-5718-1985-0777280-6">Elliptic Curves Over Finite Fields and the Computation of Square Roots mod p</a>", In Mathematics of Computation vol 44 issue 170, pages 483-494, DOI 10.1090/S0025-5718-1985-0777280-6, April 1985.</td>
</tr>
<tr>
<td class="reference"><b id="SAGE">[SAGE]</b></td>
<td class="top">
<a>The Sage Developers</a>, "<a href="https://www.sagemath.org">SageMath, the Sage Mathematics Software System</a>", 2019.</td>
</tr>
<tr>
<td class="reference"><b id="SBCDBK09">[SBCDBK09]</b></td>
<td class="top">
<a title="School of Computing Dublin City University, Ballymun. Dublin, Ireland.">Scott, M.</a>, <a title="School of Computing Dublin City University, Ballymun. Dublin, Ireland.">Benger, N.</a>, <a title="School of Computing Dublin City University, Ballymun. Dublin, Ireland.">Charlemagne, M.</a>, <a title="School of Computing Dublin City University, Ballymun. Dublin, Ireland.">Dominguez Perez, L.</a>, <a title="School of Computing Dublin City University, Ballymun. Dublin, Ireland.">Benger, N.</a> and <a title="School of Computing Dublin City University, Ballymun. Dublin, Ireland.">E. Kachisa</a>, "<a href="https://doi.org/10.1007/978-3-642-03298-1_8">Fast Hashing to G2 on Pairing-Friendly Curves</a>", In Pairing-Based Cryptography - Pairing 2009, pages 102-113, DOI 10.1007/978-3-642-03298-1_8, 2009.</td>
</tr>
<tr>
<td class="reference"><b id="SEC2">[SEC2]</b></td>
<td class="top">
<a>Standards for Efficient Cryptography Group (SECG)</a>, "<a href="http://www.secg.org/sec2-v2.pdf">SEC 2: Recommended Elliptic Curve Domain Parameters</a>", January 2010.</td>
</tr>
<tr>
<td class="reference"><b id="SECG1">[SECG1]</b></td>
<td class="top">
<a>Standards for Efficient Cryptography Group (SECG)</a>, "<a href="http://www.secg.org/sec1-v2.pdf">SEC 1: Elliptic Curve Cryptography</a>", May 2009.</td>
</tr>
<tr>
<td class="reference"><b id="SS04">[SS04]</b></td>
<td class="top">
<a title="Department of Mathemetics, University of Warsaw">Schinzel, A.</a> and <a title="Department of Mathematics, University of Warsaw">M. Skalba</a>, "<a href="https://doi.org/10.4064/ba52-3-1">On equations y^2 = x^n + k in a finite field.</a>", In Bulletin Polish Acad. Sci. Math. vol 52, no 3, pages 223-226, DOI 10.4064/ba52-3-1, 2004.</td>
</tr>
<tr>
<td class="reference"><b id="SW06">[SW06]</b></td>
<td class="top">
<a title="Mathematics Department, University of Wisconsin-Madison. Madison, USA.">Shallue, A.</a> and <a title="Mathematisch Instituut, Universiteit Leiden. Leiden, The Netherlands.">C. van de Woestijne</a>, "<a href="https://doi.org/10.1007/11792086_36">Construction of rational points on elliptic curves over finite fields</a>", In Algorithmic Number Theory. ANTS 2006., pages 510-524, DOI 10.1007/11792086_36, 2006.</td>
</tr>
<tr>
<td class="reference"><b id="T14">[T14]</b></td>
<td class="top">
<a title="NTT Secure Platform Laboratories">Tibouchi, M.</a>, "<a href="https://doi.org/10.1007/978-3-662-45472-5_10">Elligator squared: Uniform points on elliptic curves of prime order as uniform random strings</a>", In Financial Cryptography and Data Security - FC 2014, pages 139-156, DOI 10.1007/978-3-662-45472-5_10, 2014.</td>
</tr>
<tr>
<td class="reference"><b id="TK17">[TK17]</b></td>
<td class="top">
<a title="NTT Secure Platform Laboratories">Tibouchi, M.</a> and <a title="NTT Secure Platform Laboratories">T. Kim</a>, "<a href="https://doi.org/10.1007/s10623-016-0288-2">Improved elliptic curve hashing and point representation</a>", In Designs, Codes, and Cryptography, vol 82, pages 161-177, DOI 10.1007/s10623-016-0288-2, 2017.</td>
</tr>
<tr>
<td class="reference"><b id="U07">[U07]</b></td>
<td class="top">
<a title="Institute of Mathematics, Jagiellonian University. Poland">Ulas, M.</a>, "<a href="https://doi.org/10.4064/ba55-2-1">Rational points on certain hyperelliptic curves over finite fields</a>", In Bulletin Polish Acad. Sci. Math. vol 55, no 2, pages 97-104, DOI 10.4064/ba55-2-1, 2007.</td>
</tr>
<tr>
<td class="reference"><b id="W08">[W08]</b></td>
<td class="top">
<a>Washington, L.</a>, "<a href="https://www.crcpress.com/9781420071467">Elliptic curves: Number theory and cryptography</a>", edition 2nd, publisher Chapman and Hall / CRC, ISBN 9781420071467, 2008.</td>
</tr>
<tr>
<td class="reference"><b id="WB19">[WB19]</b></td>
<td class="top">
<a title="Stanford University">Wahby, R.</a> and <a title="Stanford University">D. Boneh</a>, "<a href="https://eprint.iacr.org/2019/403">Fast and simple constant-time hashing to the BLS12-381 elliptic curve</a>", Technical report ePrint 2019/403, 2019.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> <a href="#related" id="related">Related Work</a>
</h1>
<p id="rfc.section.A.p.1">The problem of mapping arbitrary bit strings to elliptic curve points has been the subject of both practical and theoretical research.  This section briefly describes the background and research results that underly the recommendations in this document.  This section is provided for informational purposes only.</p>
<p id="rfc.section.A.p.2">A naive but generally insecure method of mapping a string alpha to a point on an elliptic curve E having n points is to first fix a point P that generates the elliptic curve group, and a hash function Hn from bit strings to integers less than n; then compute Hn(alpha) * P, where the * operator represents scalar multiplication. The reason this approach is insecure is that the resulting point has a known discrete log relationship to P.  Thus, except in cases where this method is specified by the protocol, it must not be used; doing so risks catastrophic security failures.</p>
<p id="rfc.section.A.p.3">Boneh et al. <a href="#BLS01" class="xref">[BLS01]</a> describe an encoding method they call MapToGroup, which works roughly as follows: first, use the input string to initialize a pseudorandom number generator, then use the generator to produce a pseudorandom value x in F.  If x is the x-coordinate of a point on the elliptic curve, output that point. Otherwise, generate a new pseudorandom value x in F and try again.  Since a random value x in F has probability about 1/2 of corresponding to a point on the curve, the expected number of tries is just two.  However, the running time of this method depends on the input string, which means that it is not safe to use in protocols sensitive to timing side channels.</p>
<p id="rfc.section.A.p.4">Schinzel and Skalba <a href="#SS04" class="xref">[SS04]</a> introduce the first method of constructing elliptic curve points deterministically, for a restricted class of curves and a very small number of points.  Skalba <a href="#S05" class="xref">[S05]</a> generalizes this construction to more curves and more points on those curves.  Shallue and van de Woestijne <a href="#SW06" class="xref">[SW06]</a> further generalize and simplify Skalba&#8217;s construction, yielding concretely efficient maps to a constant fraction of the points on almost any curve.  Ulas <a href="#U07" class="xref">[U07]</a> describes a simpler version of this map, and Brier et al. <a href="#BCIMRT10" class="xref">[BCIMRT10]</a> give a further simplification, which the authors call the &#8220;simplified SWU&#8221; map.  The simplified map applies only to fields of characteristic p = 3 mod 4; Wahby and Boneh <a href="#WB19" class="xref">[WB19]</a> generalize to fields of any characteristic.</p>
<p id="rfc.section.A.p.5">Icart gives another deterministic algorithm which maps to any curve over a field of characteristic p = 2 mod 3 <a href="#Icart09" class="xref">[Icart09]</a>.  Several extensions and generalizations follow this work, including <a href="#FSV09" class="xref">[FSV09]</a>, <a href="#FT10" class="xref">[FT10]</a>, <a href="#KLR10" class="xref">[KLR10]</a>, <a href="#F11" class="xref">[F11]</a>, and <a href="#CK11" class="xref">[CK11]</a>.</p>
<p id="rfc.section.A.p.6">Following the work of Farashahi <a href="#F11" class="xref">[F11]</a>, Fouque et al. <a href="#FJT13" class="xref">[FJT13]</a> describe a mapping to curves of characteristic p = 3 mod 4 having a number of points divisible by 4.  Bernstein et al. <a href="#BHKL13" class="xref">[BHKL13]</a> optimize this mapping and describe a related mapping that they call &#8220;Elligator 2,&#8221; which applies to any curve over a field of odd characteristic having a point of order 2.  This includes Curve25519 and Curve448, both of which are CFRG-recommended curves <a href="#RFC7748" class="xref">[RFC7748]</a>.</p>
<p id="rfc.section.A.p.7">An important caveat regarding all of the above deterministic mapping functions is that none of them map to the entire curve, but rather to some fraction of the points. This means that they cannot be used directly to construct a random oracle that outputs points on the curve.</p>
<p id="rfc.section.A.p.8">Brier et al. <a href="#BCIMRT10" class="xref">[BCIMRT10]</a> give two solutions to this problem.  The first, which Brier et al. prove applies to Icart&#8217;s method, computes f(H0(msg)) + f(H1(msg)) for two distinct hash functions H0 and H1 from bit strings to F and a mapping f from F to the elliptic curve E.  The second, which applies to essentially all deterministic mappings but is more costly, computes f(H0(msg)) + H2(msg) * P, for P a generator of the elliptic curve group and H2 a hash from bit strings to integers modulo n, the order of the elliptic curve group.  Farashahi et al. <a href="#FFSTV13" class="xref">[FFSTV13]</a> improve the analysis of the first method, showing that it applies to essentially all deterministic mappings.  Tibouchi and Kim <a href="#TK17" class="xref">[TK17]</a> further refine the analysis and describe additional optimizations.</p>
<p id="rfc.section.A.p.9">Complementary to the problem of mapping from bit strings to elliptic curve points, Bernstein et al. <a href="#BHKL13" class="xref">[BHKL13]</a> study the problem of mapping from elliptic curve points to uniformly random bit strings, giving solutions for a class of curves including Montgomery and twisted Edwards curves.  Tibouchi <a href="#T14" class="xref">[T14]</a> and Aranha et al. <a href="#AFQTZ14" class="xref">[AFQTZ14]</a> generalize these results.  This document does not deal with this complementary problem.</p>
<h1 id="rfc.appendix.B">
<a href="#rfc.appendix.B">Appendix B.</a> <a href="#rational-map-inverse" id="rational-map-inverse">Rational maps from twisted Edwards to Weierstrass and Montgomery curves</a>
</h1>
<p id="rfc.section.B.p.1">The inverse of the rational map specified in <a href="#rational-map" class="xref">Section 6.7.1</a>, i.e., the map from the point (x&#8217;, y&#8217;) on the Weierstrass curve y&#8217;^2 = x&#8217;^3 + A * x&#8217;^2 + B * x&#8217; to the point (x, y) on the twisted Edwards curve a * x^2 + y^2 = 1 + d * x^2 * y^2 is given by:</p>
<p></p>

<ul>
<li>x&#8217; = (1 + y) / (B&#8217; * (1 - y))</li>
<li>y&#8217; = (1 + y) / (B&#8217; * x * (1 - y))</li>
</ul>
<p id="rfc.section.B.p.3">where</p>
<p></p>

<ul>
<li>A = (a + d) / 2</li>
<li>B = (a - d)^2 / 16</li>
<li>B&#8217; = 1 / sqrt(B) = 4 / (a - d)</li>
</ul>
<p id="rfc.section.B.p.5">This map is undefined when y == 1 or x == 0.  In this case, return the point (0, 0).</p>
<p id="rfc.section.B.p.6">It may also be useful to map to a Montgomery curve of the form B&#8217; * y&#8217;&#8216;^2 = x&#8217;&#8216;^3 + A&#8217; * x&#8217;&#8216;^2 + x&#8217;&#8217;.  This curve is equivalent to the twisted Edwards curve above via the following rational map (<a href="#BBJLP08" class="xref">[BBJLP08]</a>, Theorem 3.2):</p>
<p></p>

<ul>
<li>A&#8217; = 2 * (a + d) / (a - d)</li>
<li>B&#8217; = 4 / (a - d)</li>
<li>x&#8217;&#8217; = (1 + y) / (1 - y)</li>
<li>y&#8217;&#8217; = (1 + y) / (x * (1 - y))</li>
</ul>
<h1 id="rfc.appendix.C">
<a href="#rfc.appendix.C">Appendix C.</a> <a href="#samplecode" id="samplecode">Sample Code</a>
</h1>
<p id="rfc.section.C.p.1">Sample Sage <a href="#SAGE" class="xref">[SAGE]</a> code for each algorithm can be found in the draft repository <a href="#hash2curve-repo" class="xref">[hash2curve-repo]</a>.</p>
<p id="rfc.section.C.p.2">A future version of this document will give optimized examples for all curves listed in <a href="#suites" class="xref">Section 8</a>, and accompanying test vectors.</p>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Armando Faz-Hernandez</span> 
	  <span class="n hidden">
		<span class="family-name">Faz-Hernandez</span>
	  </span>
	</span>
	<span class="org vcardline">Cloudflare</span>
	<span class="adr">
	  <span class="vcardline">101 Townsend St</span>

	  <span class="vcardline">
		<span class="locality">San Francisco</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United States of America</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:armfazh@cloudflare.com">armfazh@cloudflare.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Sam Scott</span> 
	  <span class="n hidden">
		<span class="family-name">Scott</span>
	  </span>
	</span>
	<span class="org vcardline">Cornell Tech</span>
	<span class="adr">
	  <span class="vcardline">2 West Loop Rd</span>

	  <span class="vcardline">
		<span class="locality">New York, New York 10044</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United States of America</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:sam.scott@cornell.edu">sam.scott@cornell.edu</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Nick Sullivan</span> 
	  <span class="n hidden">
		<span class="family-name">Sullivan</span>
	  </span>
	</span>
	<span class="org vcardline">Cloudflare</span>
	<span class="adr">
	  <span class="vcardline">101 Townsend St</span>

	  <span class="vcardline">
		<span class="locality">San Francisco</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United States of America</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:nick@cloudflare.com">nick@cloudflare.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Riad S. Wahby</span> 
	  <span class="n hidden">
		<span class="family-name">Wahby</span>
	  </span>
	</span>
	<span class="org vcardline">Stanford University</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:rsw@cs.stanford.edu">rsw@cs.stanford.edu</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Christopher A. Wood</span> 
	  <span class="n hidden">
		<span class="family-name">Wood</span>
	  </span>
	</span>
	<span class="org vcardline">Apple Inc.</span>
	<span class="adr">
	  <span class="vcardline">One Apple Park Way</span>

	  <span class="vcardline">
		<span class="locality">Cupertino, California 95014</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United States of America</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:cawood@apple.com">cawood@apple.com</a></span>

  </address>
</div>

</body>
</html>

